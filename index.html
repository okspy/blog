<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="OLomwgvPJUusE2fSmaSFCe7mLON5KNDocZQjKQDZdp0">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="okspy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="okspy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="okspy">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>okspy</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5c2fc5dbac76adc09ece072c66e802cd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">okspy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hashMap/" itemprop="url">hashMap源码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T00:29:29+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA集合/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDK1.8的hashMap采用数组+链表+红黑树的结构，jdk1.7的hashMap采用数组+链表的结构，红黑树的目的是为了解决过长链表效率低的问题。JDK1.8修改了扩容机制，扩容时不需要计算hash，这个在后文会详细说明。</p>
<p>HashMap有几个重要的成员变量，见下表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>initialCapacity</td>
<td>HashMap容量</td>
</tr>
<tr>
<td>loadFactory</td>
<td>负载因子</td>
</tr>
<tr>
<td>threadshold</td>
<td>扩容阈值，capacity*loadFactory</td>
</tr>
<tr>
<td>modCount</td>
<td>修改次数，用于并发时判断数据是否过期（CAS）</td>
</tr>
</tbody></table>
<p>通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现。</p>
<ul>
<li>调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</li>
<li>增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。一般情况下，用默认值就可以了</li>
</ul>
<h1 id="计算哈希"><a href="#计算哈希" class="headerlink" title="计算哈希"></a>计算哈希</h1><p>hashMap的所有操作都离不开hash值的计算，因此，有必要将hash值的计算写在前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，hash值的计算是由key的hashCode进行位运算后得到的，在Java中，hash是int型，32位，前16位为高位，后16位为低位，先取hash的低位，和高位进行异或运算，得到hash值，位运算如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/hash%E5%80%BC%E8%AE%A1%E7%AE%97.png" alt="1567838656869"></p>
<p>这么做的好处就是最大限度的发挥高位和低位的作用，提高hash值的复杂度（当我们覆写hashCode方法时，有可能会写出分布性不佳的hashCode方法）。</p>
<p>计算一个键值对在数组中的下标时，采用了公式：<code>(n-1) &amp; hash</code>，n为数组容量，n-1与hash值进行与运算，等价于hash%n，往往只有低位参与了计算，因此，hashMap在计算key的hash值进行的位运算，有利于hash值的高位与低位均可以参与到计算数组下标中去，这就是为什么不直接使用key.hashCode()的原因。</p>
<p><strong>为什么说N-1 &amp; hash 等价于 hash%N</strong></p>
<p>N总是2的n次幂，即只有一位为1，N-1的后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位全部为1（此处不明白的可以查看2.4.3节的表2.1《数组容量与二进制值》），N-1 &amp; hash 即hash的后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位为1的位组成的值，它正是hash%N的余数，如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/n-1&hash.png" alt="1567840630947"></p>
<h1 id="put"><a href="#put" class="headerlink" title="put"></a>put</h1><p>先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对放置于链表最后一个位置或插入红黑树中，或者覆盖键完全相同的值。最后，以put后的容量对比threadshold决定是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 初次使用时，初始化table</span></span><br><span class="line"><span class="number">8</span>    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">9</span>        n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 数组中tab[(n-1)&amp;hash]尚未使用，不存在哈希碰撞，直接将键值对存入tab[(n-1)&amp;hash]</span></span><br><span class="line"><span class="number">10</span>   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">11</span>       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">12</span>   <span class="keyword">else</span> &#123; <span class="comment">// 待存入的键key与已存在的键值对p有哈希冲突，解决冲突</span></span><br><span class="line"><span class="number">13</span>       Node&lt;K,V&gt; e; K k; </span><br><span class="line">    	 <span class="comment">//　若键已存在于桶中第一个节点，将e指向该节点，目的是省去稍后树查找或遍历链表</span></span><br><span class="line"><span class="number">14</span>       <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">15</span>           e = p;</span><br><span class="line">    	 <span class="comment">// 若p为TreeNode，说明该数组下标处（该桶中）已经有8个以上的哈希冲突了，调用红黑树插入方法</span></span><br><span class="line"><span class="number">16</span>       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">17</span>           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    	 <span class="comment">// 当前桶中使用的是链表 </span></span><br><span class="line"><span class="number">18</span>       <span class="keyword">else</span> &#123;</span><br><span class="line">    		  <span class="comment">// 遍历链表，插入尾部</span></span><br><span class="line"><span class="number">19</span>            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    			  <span class="comment">// 判断是否为尾节点，若是，将键值对插入至尾节点后面</span></span><br><span class="line"><span class="number">20</span>                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">21</span>                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">22</span>                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line"><span class="number">23</span>                            treeifyBin(tab, hash);</span><br><span class="line"><span class="number">24</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">25</span>                &#125;</span><br><span class="line">    			  <span class="comment">// 若链表存在该键，跳出循环，此时e=p.next</span></span><br><span class="line"><span class="number">26</span>                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">27</span>                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">28</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">29</span>                p = e;</span><br><span class="line"><span class="number">30</span>            &#125; <span class="comment">// end for loop</span></span><br><span class="line"><span class="number">31</span>       &#125;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">// 上面的if、elseif、else用于确定待插入节点e的位置，现在确定key相同时，是否覆盖value</span></span><br><span class="line"><span class="number">32</span>    	<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">33</span>            V oldValue = e.value;</span><br><span class="line"><span class="number">34</span>            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">35</span>                 e.value = value;</span><br><span class="line"><span class="number">36</span>            afterNodeAccess(e);</span><br><span class="line"><span class="number">37</span>            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">38</span>      &#125;</span><br><span class="line"><span class="number">39</span>   &#125; <span class="comment">// 结束哈希冲突的解决，已完成键值对的插入</span></span><br><span class="line"><span class="number">40</span>   ++modCount; <span class="comment">// 更新hashMap的修改次数</span></span><br><span class="line">     <span class="comment">// 键值对数量+1 超过threadshold时，提前扩容，便于下一次put</span></span><br><span class="line"><span class="number">41</span>   <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">42</span>       resize();</span><br><span class="line"><span class="number">43</span>       afterNodeInsertion(evict);</span><br><span class="line"><span class="number">44</span>       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码块的核心逻辑是：</p>
<ul>
<li>1）数组table是否为空？为空则通过扩容的方式初始化</li>
<li>2）要插入的键是否与桶中第一个节点的键是同一个（equals）？若是，则标记该节点并进行第4步，若不是，则遍历树或链表。</li>
<li>3 )  遍历树或链表，待插入的键是否已存在？若存在，则标记该节点进行第4步，若不存在，则插入链表的尾节点或红黑树对应节点。</li>
<li>4）上述3步已完成了带插入节点e的定位，根据onlyIfAbsent判断是否用新值覆盖旧值</li>
<li>5）最后，根据键值对数量与threadshold的比较，判断是否需要进行扩容</li>
</ul>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><p>hashMap查找操作比插入操作更简单，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 定位键值在数组中的下标位置，记为first</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断first是否为要查找的值，目的是省去后面遍历链表或树</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// fisrt不是要查找的值，遍历链表或树，找到就跳出循环，找不到返回Null</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>在调用put方法将元素插入后，会判断是否超出负载因子*容量，超出后便调用resize()方法进行扩容。</p>
<p>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过（数组大小*loadFactor）时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作</p>
<h2 id="JDK1-7的扩容"><a href="#JDK1-7的扩容" class="headerlink" title="JDK1.7的扩容"></a>JDK1.7的扩容</h2><p>JDK1.7版本的HashMap是数组+链表的结构</p>
<p>扩容机制：新生成一个数组，然后拷贝旧数组里面的每一个数组元素表示的链表（Entry）到新数组里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; <span class="comment">//当当前数据长度已经达到最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">// 创建新的数组</span></span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing; <span class="comment">// 是否需要重新计算hash值</span></span><br><span class="line">        transfer(newTable, rehash);  <span class="comment">// 将table的数据转移到新的table中</span></span><br><span class="line">        table = newTable; <span class="comment">// 数组重新赋值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">//重新计算阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// transfer()方法负责创建将旧数组移动至新数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class="line"> </span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next; <span class="comment">// 先把next存下来，最后再处理</span></span><br><span class="line">                 <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                     e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 计算每个元素在新数组中的位置</span></span><br><span class="line">                 <span class="comment">// 将元素插入新数组，使用头部插入法</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">// e.next 指向 newTable[i]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">// newTable[i]赋值为e,完成了e插入newTable[i]对应链表的头部</span></span><br><span class="line">                 e = next; <span class="comment">// 处理next节点</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有下面的数组大小为2，loadFactory为默认值0.75的HashMap，在插入第二个元素后（key = 5）会进行扩容，扩容的新数组大小为4（假设hash的计算方法是key%数组大小）</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize01.png" alt="1567598584397"></p>
<p>创建新数组，假设hash的计算方法是key%数组大小，那么key为3和7的Entry均应落在新数组下标为3的位置，即<code>newTable[i]</code>的i为3。此时进入<code>while(null != e)</code>开始遍历旧数组下标为1的Entry</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize02.png" alt="1567599032354"></p>
<center>resize初始阶段</center>
执行`e.next = newTable[i]`，经计算，i的值为3，新的e.next 指向了新数组`newTable[3]`，`newTable[3]`是空的，所以新的e.next指向了null；

<p>执行<code>newTable[i] = e</code>，将e插入<code>newTable[3]</code>对应的链表的头部</p>
<p>执行<code>e=next</code>，此处的next存放的是旧的e.next，即上图中e.next（key=7）， 将e置为key的7的元素。</p>
<p>经过上述三步，HashMap处于下图的状态，记为resize第二阶段完成：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize03.png" alt="1567599724514"></p>
<center>resize第二阶段结束</center>
然后，再进行一次while循环，将key的7的元素移动至`newTable[3]`的头部，next指向了key=3的元素，这样就完成了整个Resize的过程。

<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize04.png" alt="1567599830776"></p>
<center>resize完成</center>
## JDK1.7扩容的线程不安全问题

<p>为了便于理解，将transfer简化，只留下关键步骤：假设两个线程同时执行put操作，进入了transfer环节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"><span class="number">1</span>	  Entry&lt;K, V&gt; next = e.next; <span class="comment">// 线程1开始，此时e.next指向key为7的Entry</span></span><br><span class="line"><span class="number">2</span>	  e.next = newTable[i];<span class="comment">//线程1继续，e.next指向newTable[3],newTable[3]为空，e.next指向null</span></span><br><span class="line"><span class="number">3</span>     newTable[i] = e; <span class="comment">//线程1继续，将newtTable[3]赋值为key为3的Entry</span></span><br><span class="line">      <span class="comment">// 线程2在此刻开始执行第1步 Entry&lt;K, V&gt; next = e.next = null</span></span><br><span class="line">      <span class="comment">// 线程2执行第2步，e.next = newTable[3] = e</span></span><br><span class="line"><span class="number">4</span>	  e = next;</span><br><span class="line"><span class="number">5</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>代码块的注释是按照时间顺序的，在第3行线程1将<code>newTable[3]</code>的赋值为key为3的Entry后（未执行<code>e=next</code>），线程1的状态如下;<br><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7resizeUnsafe01.png" alt="1567645309918"></p>
<center>线程1执行完1~3步</center>
线程2开始执行第1步，` Entry<k, v> next = e.next`，`e.next`此时被线程1修改为了null，所以对于线程2，`next = e.next = null`，然后线程2执行第二步，`e.next = newTable[3]`，`newTable[3]`已被线程1插入了e，所以对于线程2`e.next = e`，然后，线程2执行第3步，将key为3的Entry赋给`newTable[3]`，这个与线程1的操作重复了，不会有影响。此时，线程2的状态如下图。

<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7ResizeUnsafe02.png" alt="1567647285939"></p>
<p>然后，线程2执行最后一步，<code>e = next</code>，发现<code>e = null</code>不满足<code>while</code>条件，跳出循环，此时，并没有出现死循环的问题，<strong>现在的问题仅仅是链表出现了闭环</strong>。</p>
<p><strong>待下一次扩容时，才会出现死循环的问题</strong>，<code>e.next</code>永远为<code>e</code>，再也无法跳出循环。</p>
<p>上述只是链表闭环的一种情况，而且是简化版，实际情况过多，逐个赘述没有意义，不再赘述，重点是需要了解到<strong>多线程put时出现resize，可能会导致链表闭环，从而CPU占用率达到100%。</strong></p>
<h2 id="JDK1-8的扩容"><a href="#JDK1-8的扩容" class="headerlink" title="JDK1.8的扩容"></a>JDK1.8的扩容</h2><p>在JAVA 8版本，HashMap改进了扩容的方式，不再使用JDK 1.7的头部插入法。</p>
<p>为了便于理解，只摘取源码中扩容相关的核心代码：一个for循环用于将旧的数组每个元素e迁移至新数组中。</p>
<ul>
<li>如果<code>e.next == null</code>，表示旧数组中该位置没有哈希碰撞，直接计算e在新数组中的位置并赋值</li>
<li>如果e是TreeNode的实例，计算在新数组的下标，并添加到新数组对应位置的红黑树中，先不赘述</li>
<li>e是链表，按照链表的逻辑插入，本节主要介绍链表情况下的插入，用以比较与JDK1.7的不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line"><span class="number">2</span>     Node&lt;K,V&gt; e;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">4</span>          oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">5</span>          <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>              newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//如果e后面没有元素，说明没有哈希碰撞，直接赋值</span></span><br><span class="line"><span class="number">7</span>          <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">8</span>              ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);<span class="comment">//如果e是红黑树，添加到红黑树</span></span><br><span class="line"><span class="number">9</span>          <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="number">10</span>                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">11</span>                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">12</span>                Node&lt;K,V&gt; next;</span><br><span class="line"><span class="number">13</span>                <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">14</span>                    next = e.next;</span><br><span class="line"><span class="number">15</span>                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 此处是重点，后文有分析</span></span><br><span class="line"><span class="number">16</span>                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 判断链表尾节点是否为null，即链表是否为空（不为空17    的链表尾节点不可能为null，只包含一个节点的链表头节点与尾节点是同一个节点）</span></span><br><span class="line"><span class="number">18</span>                             loHead = e; <span class="comment">// 如果为null，表示链表为空，loHead = e </span></span><br><span class="line"><span class="number">19</span>                         <span class="keyword">else</span></span><br><span class="line"><span class="number">20</span>                             loTail.next = e; <span class="comment">// 不为null，说明链表已有元素，将尾部指向e</span></span><br><span class="line"><span class="number">21</span>                         </span><br><span class="line"><span class="number">22</span>                        loTail = e; <span class="comment">// 将e插入链表尾部</span></span><br><span class="line"><span class="number">23</span>                     &#125;</span><br><span class="line"><span class="number">24</span>                     <span class="keyword">else</span> &#123; <span class="comment">// 与e.hash &amp; oldCap) == 0原理一样，只不过是插入至另一个链表</span></span><br><span class="line"><span class="number">25</span>                         <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">26</span>                              hiHead = e;</span><br><span class="line"><span class="number">27</span>                         <span class="keyword">else</span></span><br><span class="line"><span class="number">28</span>                              hiTail.next = e;</span><br><span class="line"><span class="number">29</span>                              </span><br><span class="line"><span class="number">30</span>                         hiTail = e;</span><br><span class="line"><span class="number">31</span>                     &#125;</span><br><span class="line"><span class="number">32</span>                 &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">33</span>                 </span><br><span class="line"><span class="number">34</span>                 <span class="comment">// 链表尾节点指向null、数组放置链表头节点</span></span><br><span class="line"><span class="number">35</span>                 <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="number">36</span>                      loTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">37</span>                      newTab[j] = loHead;</span><br><span class="line"><span class="number">38</span>                 &#125;</span><br><span class="line"><span class="number">39</span>                 <span class="comment">// 与loTail相同       </span></span><br><span class="line"><span class="number">40</span>                 <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">41</span>                      hiTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>                      newTab[j + oldCap] = hiHead;</span><br><span class="line"><span class="number">43</span>                 &#125;</span><br><span class="line"><span class="number">44</span>          &#125; <span class="comment">// else end</span></span><br><span class="line"><span class="number">45</span> &#125; <span class="comment">// for (int j = 0; j &lt; oldCap; ++j) end</span></span><br></pre></td></tr></table></figure>

<p>e是链表的情况下，声明了loHead、loTail、hiHead、hiTail，他们分别是lo和hi链表的头结点与尾节点。lo链表会插入与旧数组相同的下标处<code>newTab[j] = loHead</code>，hi链表插入旧下标偏移旧容量处<code>newTab[j+oldCap] = hiHead</code>。</p>
<p>上述代码块都很好理解，建立了两个链表，依次在末端插入新的元素，在多线程环境下，JDK 1.7由于头部插入法导致了链表闭环，<strong>JDK 1.8采用尾部插入法，有效的避免了JDK1.7链表闭环的问题</strong>。但是</p>
<ul>
<li>没有解决JDK1.7中的数据丢失的问题，比如多个线程同时put的时候，当index相同而又同时达到链表的末尾时，另一个线程put的数据会把之前线程put的数据覆盖掉，就会产生数据丢失。</li>
<li>多线程下操作同一对象时，对象内部属性的不一致性还会导致死循环</li>
</ul>
<p>不过，HashMap本来就不是为多线程环境设计的，多线程应该使用ConcurrentHashMap。</p>
<p>现在把目光放在上述代码块第15行的<code>if ((e.hash &amp; oldCap) == 0)</code>，它用来判断元素放置在lo链表还是hi链表，这两个链表分别插入在数组下标为旧下标<code>newTab[j]</code>和旧下标+旧容量处<code>newTab[j+oldCap]</code>。上述代码块的第一个注释为<code>如果e后面没有元素，说明没有哈希碰撞，直接赋值</code>，此处将e放置在了<code>newTab[e.hash &amp; (newCap - 1)]</code>处。而在前面介绍的put方法中，也出现了<code>tab[(n - 1) &amp; hash]</code>，我们发现总是将<code>n-1、hash</code>进行与操作<code>(&amp;)</code>，n表示数组容量，它总是2的n次幂，n的二进制如下：</p>
<center>表2.1 数组容量与二进制值</center>
| 数组容量N的十进制值 | 数组容量N的二进制值 | N-1的二进制值 |
| ------------------- | ------------------- | ------------- |
| 2                   | 0000 0010           | 0000 0001     |
| 4                   | 0000 0100           | 0000 0011     |
| 8                   | 0000 1000           | 0000 0111     |
| 16                  | 0001 0000           | 0000 1111     |
| ....                | 000100000..         | 0001111...    |

<p>数组容量N的二进制值总是只有1位为1，其他位全是0，<strong>对于N-1的二进制，后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位全部为1，将<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位记为标记位M，那么对于2N-1的二进制，它的标记位为M+1</strong>。<code>(n-1)&amp;hash</code>实际上就是<code>hash%(n-1)</code>，只不过JDK1.8采用了速度更快的位运算。<br>根据HashMap的数据散落原理，是取hash值然后对数组的大小取余，且每次扩容后，容量为扩容前的二倍，那么将旧数组容量oldCap记为N：</p>
<p>​        e.hash &amp;（N-1） = oldPos  // 标记位为M</p>
<p>​        e.hash &amp;  (2N-1) = newPos // 标记位为M+1</p>
<p>它们等价于：</p>
<p>​        e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>​        e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>上述两个式子分别用来计算e在新旧数组中的位置newPos、oldPos，它们实际上是e.hash对一个低位全部为1，高位全部为0的二进制的与运算，所以在计算Position时，e.hash比标记位更高的位是无意义的，这个标记位取决于数组的容量大小：</p>
<ul>
<li>对于旧的数组，容量N、标记位M，只考虑e.hash的低M位。</li>
<li>对于新的数组，容量2N、标记位M+1，只考虑e.hash的低M+1位。</li>
</ul>
<p>现在来看<code>if ((e.hash &amp; oldCap) == 0)</code>的意义：</p>
<p>​    e.hash &amp; N = 0  ==&gt;  e.hash &amp; 0000…01000  = 0 </p>
<p>N的二进制中唯一的1出现在标记位M+1处，即oldCap的唯一的1出现在此处，所以这个if语句用来判断e的hash值的倒数M+1位是否为0：</p>
<ul>
<li><p>如果e.hash倒数第M+1位为0，有下面三个式子：</p>
<p>e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>e.hash &amp; 0000 1000…..= 0  </p>
<p>因此，newPos = e.hash &amp; 0000 1111… = e.hash &amp; 0000 0111…. =oldPos</p>
<p>只考虑e.hash的低M位，与旧数组中位置计算方式一样，得到的结果也必然相同，所以e在新旧数组中位置相同。</p>
</li>
<li><p>如果 e.hash倒数第M+1位不为0（为1），则有下面的三个式子：</p>
<p>e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>e.hash &amp; 0000 1000…..= 000..10000       //   倒数第M+1位为1</p>
<p>因此，newPos = e.hash &amp; 0000 1111… = （e.hash &amp; 0000 0111….）+ （e.hash &amp; 0000 1000…..） = oldPos + oldCap</p>
</li>
</ul>
<p><strong>通过以上的位运算，不需要再重新计算hash值，即可完成旧数组向新数组的迁移，大大地提高了效率</strong></p>
<h1 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>Object的equals比较的是对象的内存地址。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj); <span class="comment">// 如果对象内存地址相同，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在实际的业务中，往往判断两个对象是否equals时，是根据对象所对应的“值”去判断的，这时，就需要重写equals方法。比如JDK的String类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123; <span class="comment">// 如果对象内存地址相同，返回true        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;        </span><br><span class="line">        String anotherString = (String)anObject;        </span><br><span class="line">        <span class="keyword">int</span> n = value.length;        </span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;   <span class="comment">// 比较两个字符串长度是否相等         </span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;            </span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;            </span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;            </span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123; <span class="comment">// 逐个字符比较，全部相等时返回true                </span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                </span><br><span class="line">                i++;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><p>java.lang.Object中对hashCode的约定：如果两个对象根据equals方法比较是相等的，那么调用这两个对象的任意一个hashcode方法都必须产生相同的结果。比如String类，因为重写了equals，那么必须重写hashcode。</p>
<p>首先看Object的hashcode的计算方式（<a href="https://www.jianshu.com/p/be943b4958f4" target="_blank" rel="noopener">参考博客</a>），下面的代码为openjdk1.8的Native源码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> intptr_t <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it's possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we'll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::random() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia's xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we'll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  assert (value != markOopDesc::no_hash, <span class="string">"invariant"</span>) ;</span><br><span class="line">  TEVENT (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8默认采用的是最后一个else语句中的计算方式<code>xor-shift算法</code>，该算法根据四个初始值可以生成一系列随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xor-shift 伪随机数生成算法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">xor128</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> x=<span class="number">123456789</span>,y=<span class="number">362436069</span>,z=<span class="number">521288629</span>,w=<span class="number">88675123</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> t;</span><br><span class="line">t=(xˆ(x&lt;&lt;<span class="number">11</span>));x=y;y=z;z=w; <span class="keyword">return</span>( w=(wˆ(w&gt;&gt;<span class="number">19</span>))ˆ(tˆ(t&gt;&gt;<span class="number">8</span>)) );</span><br></pre></td></tr></table></figure>

<p>其中，hashStateX计算方式为<code>hashStateX=Slef-&gt;os::random()</code>，hashStateY、hashStateZ、hashStateW都是固定初始值，最终的Value由这四个值计算得出。</p>
<p>在第一个if语句<code>if(hashCode==0)</code>中有一行注释： so it’s possible for two threads to race and generate the same RNG，说明了两个线程竞争调用os::random()时有可能产生相同的随机数，这个是我们不想看到的，因此，JDK采用了<code>xor-shift算法</code>，即便初始值相同，产生的随机数也不同，有效的规避了这种情况，最终产生的随机数是线程相关的，支持多线程并发，有可能是目前最好的hashCode算法。（最后一个else语句中的注释：Marsaglia’s xor-shift scheme with thread-specific state This is probably the best overall implementation ）</p>
<p>总之，<strong>默认地，Object.hashCode()产生一个线程安全的唯一随机值，可以通过在JVM启动参数中添加-XX:hashCode=2，改变默认的hashCode计算方式，JVM参数里的hashCode为0时hashCode的计算方式是os随机值，多线程竞争时可能会出现重复，为1时是对象的内存地址做位移运算后与一个随机数进行异或得到的结果，为2时是固定值、为3时是自增值</strong></p>
<p>再看String类的hashcode方法，String对象的hash值与每个字符都有关，所以该hash值更看重的是业务层面的“值”的比较。这也对应了<strong>重写了equals，那么必须重写hashcode</strong>的约定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;         </span><br><span class="line">        <span class="keyword">char</span> val[] = value;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123; <span class="comment">// 逐个字符修改原始hash值           </span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i];        </span><br><span class="line">        &#125;        </span><br><span class="line">        hash = h;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">//返回的hash值与每个字符相关。满足equals的两个不同的new String对象，对应完全相同的hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用重写过equals-和hashcode-的对象作为Map的键"><a href="#使用重写过equals-和hashcode-的对象作为Map的键" class="headerlink" title="使用重写过equals()和hashcode()的对象作为Map的键"></a>使用重写过equals()和hashcode()的对象作为Map的键</h2><p>在使用hashMap时，判断是不是同一个键的条件如下，为true时表示同一个键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>

<p>对于第一个条件：比较的是Node的hash值，它通过构造方法设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node的hash值通过构造方法设置</span></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以put为例，调用过程如下，可以看出，<strong>Node的hash值等于key的hash值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// 调用putVal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 调用newNode()</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        	... <span class="comment">// 省略，与此处逻辑无关</span></span><br><span class="line">&#125;        	</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，满足下面任一个条件即视为同一个键：</p>
<ul>
<li>key的hash值相同且key为同一个（==表示指向同一个堆地址，是同一个对象）</li>
<li>两个键满足equals</li>
</ul>
<p>对于第一个条件，与key的hash值完全相关，前面介绍了JDK1.8hash值默认是一个线程相关的随机数，而在业务层面上，往往键都是有实际意义的，因此，尽量不要使用JDK的随机数作为对象的hash值。如果不注意，将没有重写hashCode()的对象作为了Map的Key，在调用get、put、remove方法时，可能会出现一些意外的错误，比如，你不想让两个键相同（这里的相同指的是值相同，业务意义相同，比如人名、身份证ID）的对象同时出现在Map中，那么，有必要重写hashCode，否则会出现冲突，例子如下：。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Person tom = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>)</span><br><span class="line">Person tom2 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>)</span><br><span class="line"></span><br><span class="line">Map&lt;Person, Blog&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(tom);</span><br><span class="line">map.put(tom2);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，你本来不想让姓名重复的用户插入到Map中，但是因为没有重写Person的hashCode，导致这两个对象tom、tom2的hashCode不同，都成功插入Map。</p>
<p>对于第二个条件，Object.equals()比较的是键的内存地址，这也与业务无关。示例可参考上面的示例。</p>
<p><strong>因此，尽量使用那些已经覆写了equals和hashCode的类，比如String、Integer等，如果要使用自定义的类作为hashMap的key，要覆写equals和hashCode方法，将它改为值的判断，避免使用时出现意外的错误。</strong></p>
<h1 id="细节疑问"><a href="#细节疑问" class="headerlink" title="细节疑问"></a>细节疑问</h1><ol>
<li><p>为什么HashMap实现了Serializable接口，却将table声明为transient？（声明为transient，不会被序列化）</p>
<p>答：参考<a href="https://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria" target="_blank" rel="noopener">StackOverfolw回答</a>，HashMap使用wirteObject、readObject实现自定义的序列化和反序列化，序列化时记录了的table的size、键值对的size、以及所有的key-value映射，没有序列化table（Node数组），Node包含了hash值、key、value、以及下一个Node指针，Node的作用是便于遍历键值对，<strong>table不序列化的目的只是为了节省空间</strong>，当反序列化的时候，通过readObject重新构建table。</p>
</li>
<li><p>为什么链表长度为8时进行树化，怎么不是2、4、16、32？</p>
<p>红黑树占据的空间是链表的两倍，删除和新增数据都需要调整树，所以会尽量避免使用红黑树，在hashMap源码196行的有一段注释提到：当选择计算hash值的算法足够好时，数据均匀分布，呈现泊松状，同一个桶中的节点数等于8的概率为亿分之6，因此，为8时链表转换为红黑树的概率已经极低了。</p>
<ul>
<li>一个桶中链表长度达到4的概率为1.5%，此时链表查询复杂度为4，红黑树为2，差距不大</li>
<li>一个桶中链表长度为8的概率为亿分之6，此时链表复杂度为8，红黑树为3，差距开始明显，有必要树化</li>
<li>一个桶中长度为16的概率更低，除非你重写的hashCode方法真的很烂，此时链表复杂度为16，红黑树为4，差距较大，树化已经晚了</li>
</ul>
</li>
<li><p>为什么是树的节点数是6的时候，退化成链表，怎么不是8？</p>
<p>如果是8,或者7，假如有大量的操作在长度7和8之间来回切换，这种结构的变换导致耗时更多，所以用6进行一个过渡。</p>
</li>
</ol>
</k,>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/threadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/threadLocal/" itemprop="url">threadLocal原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T00:29:29+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h1><p>在了解threadLocal之前，有必要了解JAVA中的四种引用：</p>
<ul>
<li>强引用：正常new出来对象就是强引用，<strong>当内存不够的时候</strong>，JVM宁可抛出异常，也不会回收强引用对象。</li>
<li>软引用(<code>SoftReference</code>)：软引用生命周期比强引用低，<strong>在内存不够的时候</strong>，会进行回收软引用对象。软引用对象经常和引用队列<code>ReferenceQueue</code>一起使用，在软引用所引用的对象被GC回收后，会把该引用加入到引用队列中。</li>
<li>弱引用(<code>WeakReference</code>)：弱引用生命周期比软引用要短，<strong>在下一次GC的时候</strong>，扫描到它所管辖的区域存在这样的对象： <code>一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向,</code>，不管当前内存是否够，该对象都会被回收。弱引用和软引用一样，也会经常和引用队列<code>ReferenceQuene</code>一起使用，在弱引用所引用的对象被GC回收后，会把该引用加入到引用队列中。</li>
<li>虚引用（<code>PhantomReference</code>)：又叫幻象引用，与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象将被回收时，自己被加入到引用队列，用作记录该引用指向的对象即将被销毁。</li>
</ul>
<p>finallized方法： 当对象变成(GC Roots)不可达时（第一次回收），GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达（第二次回收），若不可达，则进行回收，否则，对象“复活”。因此，对于重写了finallized方法的对象，会出现两个垃圾回收周期，这两个周期之间可能相隔了很久（取决于finalized方法执行是否及时），所以可能会出现大部分堆被标记为垃圾却还没有被回收，出现内存溢出的错误。</p>
<p>使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>通常情况下，线程中对全局变量赋值后，可以被任何一个线程访问并修改的。</p>
<p>而创建全局变量<code>ThreadLocal</code>，通过<code>ThreadLocal</code>全局变量传递局部变量，该局部变量只能被当前线程访问，而且可以<strong>在线程的上下文传递</strong>，其他线程则无法访问和修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; mystr = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mystr.set(<span class="string">"test_str_1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上通过<code>ThreadLocal</code>设置的值是放入了当前线程的一个<code>ThreadLocalMap</code>实例中，所以只能在本线程中访问，其他线程无法访问。</p>
<h2 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h2><p><strong>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例，value是真正需要存储的Object。</strong></p>
<p><em>从set()方法的实现，理解ThreadLocal实现</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 source code </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用set方法时</p>
<ul>
<li>首先获取当前线程  <code>Thread.currentThread()</code></li>
<li>利用当前线程获取一个<code>ThreadLocalMap</code>对象</li>
<li>判断map是否为空，若为空，创建这个<code>ThreadLocalMap</code>对象并设置值，不为空，则设置值。</li>
</ul>
<p><code>getMap()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Thread</code>类中，定义了两个属性，<code>threadLocals</code>的初始化是在调用<code>ThreadLocal</code>类中的<code>getMap()</code>方法时完成的，当线程退出时，会将<code>threadLocals</code>和<code>inheritableThreadLocals</code>置为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>; <span class="comment">// ThreadLocalMap对象</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>; <span class="comment">// 子类可继承的ThreadLocalMap对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程退出后，将threadLocals和inheritableThreadLocals置为null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">   target = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">   threadLocals = <span class="keyword">null</span>; </span><br><span class="line">   inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">   inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">   blocker = <span class="keyword">null</span>;</span><br><span class="line">   uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，完成了前两步，获取当前线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，是基于Entry数组的map。<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>弱引用，目的是当线程退出时把<code>threadLocal</code>实例置为null时，不再有强引用指向<code>threadLocal</code>实例，不影响<code>threadLocal</code>实例的垃圾回收。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>threadlocal</code>的生命周期中,存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/threadlocal/ThreadLocal%E5%BC%95%E7%94%A8.png" alt="img"></p>
<p>与上面的分析一致，Entry的key为弱引用，它的引用链是<code>ThreadLocalRef -&gt; ThreadLocal ---&gt; key</code>，当栈中的<code>ThreadLocalRef</code>与堆中的<code>ThreadLocal</code>断开时，<code>ThreadLocal</code>实例就会被垃圾回收。</p>
<p>value为强引用，它的引用链是<code>CurrentThreadRef -&gt; CurrentThread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</code>，只要当前线程没有关闭，<code>CurrentThreadRef -&gt; CurrentThread</code>的引用就不会断开，value就不会被垃圾回收。只有当前thread结束以后, <code>CurrentThread</code>就不会存在栈中,强引用断开, CurrentThread, Map, value将全部被GC回收.</p>
<h2 id="是否存在内存泄露？"><a href="#是否存在内存泄露？" class="headerlink" title="是否存在内存泄露？"></a>是否存在内存泄露？</h2><p>上节提到当前线程没有退出，将会一直存在CurrentThread至value的引用链，即便将threadLocal手动设置为null也依然存在CurrentThread至value的引用链。这会给开发者产生一种<strong>内存泄露的错觉</strong>（错觉：value是通过threadLocal设置的，我明明将threadLocal设置为了null，为什么value还会占用内存？），尤其在使用线程池时更容易出现这样的错觉，因为线程池的线程结束后，会放回线程池中不销毁。</p>
<p>可以理解为：threadLocal没有内存泄露，泄露的是Entry。</p>
<p><strong>JDK的优化</strong></p>
<p>为了减缓这种错觉的产生，Java会在调用threadLocal实例的get、set方法且key为null时，清除Entry。以get方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadlocal.get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">//此处调用threadlocalMap.getEntry（）</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threadlocalMap.getEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key) </span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> getEntryAfterMiss(key, i, e); <span class="comment">// 没找到该key(threadlocal)时，调用该方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash未命中时调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// ThreadRef这条链还没断，thread未被销毁，entry不为Null</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)   <span class="comment">// threadLocalRef这条链已断开，threadLocal实例为Null</span></span><br><span class="line">             expungeStaleEntry(i); <span class="comment">// 删除所有key为null的Entry</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">             e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅在调用get方法，在调用set、remove方法时，threadLocal为null时，也会最终调用到<code>expungeStaleEntry()</code>方法 ，清除所有threadLocal为null时entry的强引用，这里不赘述了。</p>
<p>因此，正确的使用方式是，首先判断是否存在场景：threadLocal置为null？</p>
<p>如果存在，在调用完set、get后，记得调用remove方法显示的清除Entry的强引用。如果不存在，threadLocal一直在使用，没有被回收的必要，也不care脏读的情况，那更没必要去回收threadLocalMap中的Entry了。</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>示例如下，创建一个大小为8的线程池，向该线程池提交100次任务，因为使用的是线程池，线程不会被销毁，所以假设某一个线程写入了值，然后该线程处于空闲态，然后该线程再次读取时，读取到的是上次该线程运行时设置的值。</p>
<p>可能下面的例子很明显就看的出问题所在，但是当项目复杂时，在多处调用get，就比较容易出现这种问题。</p>
<p>不过这种情况也很容易避免，有两种方法：</p>
<ul>
<li>set、get成对出现，set在前、get在后</li>
<li>使用remove</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; mystr = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	ExecutorService executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        String s = mystr.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                	mystr.set(<span class="string">"test"</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hash碰撞"><a href="#Hash碰撞" class="headerlink" title="Hash碰撞"></a>Hash碰撞</h2><p>在某个线程中，每new一个ThreadLocal实例，该线程的<code>ThreadLocalMap</code>中就会新增的一个key，当ThreadLocal实例过多时，自然会出现hash碰撞。</p>
<p>和<code>HashMap</code>的最大的不同在于，<code>ThreadLocal.ThreadLocalMap</code>结构非常简单，没有next引用，也就是说<code>ThreadLocalMap</code>中解决Hash冲突的方式并非链表/红黑树的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p>
<p>线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。所以在开发的过程中，要避免这一点，提高运行效率。</p>
<h2 id="与synchronized的区别"><a href="#与synchronized的区别" class="headerlink" title="与synchronized的区别"></a>与synchronized的区别</h2><ul>
<li><code>ThreadLocal</code>用于处理线程内部上下文变量的传递，变量不会被其他线程访问，而<code>synchronized</code>修饰的变量，只要其他线程获取了锁，就能访问、修改</li>
<li><code>ThreadLocal</code>没有锁的机制，没有锁的开销</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（四）MongoDB副本集与分片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（四）MongoDB副本集与分片/" itemprop="url">MongoDB系列（四）MongoDB副本集与分片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T00:00:00+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h1><p>副本集是一组服务器，其中有一个主服务器(primary)，用于处理客户端请求，还有多个备用服务器(secondary)，用于保存主服务器的数据副本，如果主服务器崩溃了，备份服务器会自动选举出一个新的主服务器。</p>
<p>一般的，只有主服务器才会用作写操作，备用服务器最多支持读操作，甚至读写均不支持，只用来做备份。</p>
<h2 id="大多数"><a href="#大多数" class="headerlink" title="大多数"></a>大多数</h2><p>副本集中有一个很重要的概念是”大多数“，选择主节点时由”大多数“决定，主节点只有在得到”大多数“支持时才能继续作为主节点，这里的”大多数“被定义为副本集中一半以上的成员。它是动态变化的，如果某一个节点挂了，那么”大多数“就有可能发送变化，举个例子：</p>
<table>
<thead>
<tr>
<th align="center">副本集的成员总数</th>
<th align="center">”大多数“</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>$$<br>“大多数” &gt;= （总数+1）/2<br>$$</p>
<p>下图是一个包含5个节点的副本集，其中3个位于数据中心A，另外2个位于数据中心B，如果节点1、2、3全挂了，节点4、5不能选举出主节点。这种规定是有目的的：</p>
<p>对于节点4、5而言，节点1、2、3全挂掉与下图情况（数据中心A与B之间的链路中断了）完全相同，此时，数据中心A中还有3个可用节点，满足”大多数“，会选举出一个主节点，数据中心B只有两个可用节点，如果允许数据中心B选举出主节点，那么会出现两个主节点，这就是为什么一定要保证”大多数“的原因，时刻保证只有一个主节点可用，避免多个主节点写入出现冲突所导致的开发的复杂性。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%89%AF%E6%9C%AC%E9%9B%86-%E5%A4%A7%E5%A4%9A%E6%95%B0.png" alt="1566905821363"></p>
<p>还有另外一种情况，同样是两个数据中心，A与B的节点数完全相等，A与B链路断开时，任何一边都无法满足”大多数“。为避免这种情况，有两种做法：</p>
<ul>
<li>将大多数放在同一个数据中心，如节点1、2、3放置在中心A，节点4放在中心B，这样做很简单，但是还会遇到上面的问题，节点1、2全部挂掉了，节点3、4无法提供服务</li>
<li>添加一个仲裁节点，只用来做仲裁，不用来做备份，放置在数据中心C，这样任何一个数据中心的服务器都可以满足”大多数“的条件，这样做的缺点是：将服务器分布到三个地方。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%89%AF%E6%9C%AC%E9%9B%86-%E4%BB%B2%E8%A3%81.png" alt="1566906750134"></p>
<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>当一个备份节点A无法与主节点连通时，它就会请求其他的副本集成员将自己选举为主节点。其他副本集成员会进行以下检查：</p>
<ul>
<li>自身能否与主节点连通</li>
<li>通过比较A的oplog与自身的oplog，确定A节点的数据是否最新</li>
<li>是否有其他优先级更高的节点请求被选举为主节点</li>
</ul>
<p>赞成票的权重为1，反对票的权重为-10000，所以即使”大多数“成员中只有一个否决了本次选举，选举就会取消。选举的过程一般只需要几毫秒，实际情况可能会遇到网络问题、服务器过载导致响应慢、选举打成平局，平局后每个成员需要等待30s才能进行下一轮选举，所以，如果有太多错误发生的话，选举可能需要几分钟。</p>
<p>首先关注第二点，确定被选举人的数据是否是最新的。如下图所示，一共有3个节点，主节点网络故障，备用节点1发现主节点无法连通，向备用节点2请求选举自身为主节点，备用节点2首先检查到主节点无法连通，然后将对比备用节点1的<code>local.oplog.rs</code>与自身的<code>local.oplog.rs</code>数据，发现备用节点1的oplog中没有记录自身的最新写操作5，投出反对票。此时，备用节点1获悉自身数据不是最新的，会向备用节点2请求最新的oplog，然后再次请求选举为主节点，新一轮的选举中，之前投否决票的的可以重新投票；同时，备用节点2也可以向备用节点1发起请求，请求被选举为主节点。最终，只要备用节点1与备用节点2之间保持连通的状态，一定能选举出新的主节点。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E9%80%89%E4%B8%BE.png" alt="1566982864577"></p>
<p>上面描述的是备用节点1和备用节点2相等时的情况，假如备用节点1和备用节点2已经选举出新的主节点—备用节点1。运行一段时间后，使用下面的命令新添加一个节点，称之为节点3，节点3此时没有任何数据，会从新的主节点（之前的备用节点1）获取最新的<code>oplog</code>，数据更新到最新后，新的主节点（之前的备用节点1）检测到节点3为高优先级节点，新的主节点（之前的备用节点1）主动退位，重新进行选举，直到选举节点3为主节点为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&#123;<span class="string">"_id"</span>:<span class="number">4</span>, <span class="string">"host"</span>:<span class="string">"172.28.70.1:27017"</span>, <span class="string">"priority"</span>:<span class="number">1.5</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>让主节点永远保持最新的oplog是非常重要的，因此，所有的写操作都在主节点进行，在对读取数据一致性要求不高或希望主节点挂掉仍能读数据的场景下，备用节点可以分担主节点读操作的压力。</strong></p>
<p>通过设置<code>readPreference=secondaryPreferred</code>将读请求设置路由至备用节点，建立索引会消耗内存和硬盘空间、降低写操作性能，为进一步缓解主节点压力，</p>
<ul>
<li>可以设置一个与主节拥有不同索引的备份节点</li>
<li>也可以使驱动程序创建一个直接连接到目标备用节点用作读操作（而不是连接到整个副本集）</li>
<li>甚至部分数据从主节点读另一部分从备用节点读。</li>
</ul>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>每个节点都需要知道其他成员的状态，用来确定下列信息：</p>
<ul>
<li>哪个是主节点</li>
<li>哪个挂掉了</li>
<li>是否满足”大多数”</li>
<li>是否有比主节点优先级更高的节点</li>
</ul>
<p>为了维护集合的最新视图，每个成员每隔2s就会向其他成员发送一次心跳，心跳请求的信息量非常小，用来检查每个成员的状态，获取简要信息。</p>
<h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ul>
<li>STARTUP                       节点刚刚启动，还未加载副本集配置</li>
<li>STARTUP2                     节点加载副本集配置，进行初始化同步</li>
<li>RECOVERING                初始化完成，进行检查以确保自身处于有效状态，当节点与其他节点脱节时，也会进入该状态，这时，这个成员处于无效状态，需要重更新同步（不是初始化同步，不过于初始化同步动作是一样的，都是同步oplog），同步完成后，回到正常状态（主节点状态、备份节点状态）</li>
<li>PRIMARY                       主节点正常运行的状态</li>
<li>SECONDARY                 备份节点正常运行的状态</li>
<li>ARBITER                        在正常操作中，仲裁节点始终处于该状态，仲裁节点没有oplog，没有数据</li>
<li>DOWN                           节点无法连通</li>
<li>UNKNOW                      所有的节点都无法连通该节点</li>
<li>REMOVED                     节点被踢出副本集</li>
<li>ROLLBACK                     回滚，主节点执行一个写操作后挂掉了，备份节点没有复制该操作，新的主节点也会漏掉该操作，旧的主节点重新上线后，会回滚该操作，然后重新同步。</li>
<li>FATAL                             节点发生不可挽回的错误，也不再尝试恢复正常，这是应该重启该节点、重新同步。</li>
</ul>
<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>分片（sharding）是指将数据拆分，将其分散在不同的机器上的过程。分片可以分为：</p>
<ul>
<li>手动分片（manual sharding）</li>
<li>自动分片（autosharing）</li>
</ul>
<p>几乎所有的数据库都支持手动分片，应用维护与各个服务器之间的连接，每个连接是完全独立的，由应用管理数据的路由规则，这种方式的缺点是：难以维护、向集群新增节点或删除节点都很麻烦、调整分布以及负载模式也不轻松，因此，MongoDB提供了自动分片机制。</p>
<h2 id="基于Mongos的自动分片"><a href="#基于Mongos的自动分片" class="headerlink" title="基于Mongos的自动分片"></a>基于Mongos的自动分片</h2><p>MongoDB支持自动分片，使得数据库架构对应用不可见，对于应用而言，好像始终在使用一台单机的MongoDB服务器一样，同时，MongoDB自动处理数据在分片上的分布，也更加容易新增或删除节点。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%88%86%E7%89%87.png" alt="img"></p>
<p>Mongos作为分片集群的访问入口，所有的请求都由mongos来路由、分发、合并，这些动作对客户端驱动透明，用户连接mongos就像连接mongod一样使用，mongos可以是一个或多个，一般部署两个做高可用即可。</p>
<p>Mongos会根据请求类型及片键将请求路由到对应的分片</p>
<h3 id="查询请求"><a href="#查询请求" class="headerlink" title="查询请求"></a>查询请求</h3><ul>
<li>查询请求不包含片键，则必须将查询分发到所有的分片，然后合并查询结果返回给客户端</li>
<li>查询请求包含片键，则直接根据片键计算出需要查询的块（chunk），向对应的分片发送查询请求</li>
</ul>
<h3 id="插入请求"><a href="#插入请求" class="headerlink" title="插入请求"></a>插入请求</h3><p>写操作必须包含片键，mongos根据片键算出文档应该存储到哪个chunk，然后将写请求发送到chunk所在的分片。</p>
<h3 id="更新-删除请求"><a href="#更新-删除请求" class="headerlink" title="更新/删除请求"></a>更新/删除请求</h3><p>更新、删除请求的查询条件必须包含片键或者<code>_id</code>，如果是包含片键，则直接路由到指定的chunk，如果只包含<code>_id</code>，则需将请求发送至所有的分片。</p>
<h3 id="其他命令请求"><a href="#其他命令请求" class="headerlink" title="其他命令请求"></a>其他命令请求</h3><p>除增删改查外的其他命令请求处理方式都不尽相同，有各自的处理逻辑，比如listDatabases命令，会向每个分片转发listDatabases请求，然后将结果进行合并。</p>
<h2 id="何时分片"><a href="#何时分片" class="headerlink" title="何时分片"></a>何时分片</h2><p>通常，不必太早分片，因为分片不仅会增加部署的复杂度、还要求做出设计决策，而且该决策在以后很难再改。</p>
<p>另外，不能太晚分片，因为在一个过载的系统上不停机进行分片是非常困难的。</p>
<p>分片的目的：</p>
<ul>
<li>增加可用内存空间</li>
<li>增加可用磁盘空间</li>
<li>减轻单台服务器的负载</li>
<li>处理单个MongoDB服务器无法承受的吞吐量</li>
</ul>
<p>随着不断增加分片的数量，系统性能大致会呈线性增长，但是，如果从一个未分片的系统转换为只有几个分片的系统，性能通常会有所下降。由于迁移数据、维护元数据、路由等开销，少量分片的系统与未分片的系统相比，通常延迟更大，吞吐量甚至更小。<strong>一般的，至少应该创建3个或以上的分片</strong>。</p>
<h2 id="选择片键"><a href="#选择片键" class="headerlink" title="选择片键"></a>选择片键</h2><p>使用分片时，最重要、最困难的任务时选择数据的分发方式。对集合分片时，要选择一个或两个字段用于拆分数据。这个键（或这些键）称为片键。一旦拥有多个分片，再修改片键几乎是不可能的，所以必需在一开始就确定好片键。</p>
<p>最常见的片键有三种：</p>
<ul>
<li>升序片键（ascending key）</li>
<li>随机分发的片键（random key）</li>
<li>基于位置的片键（location-based key）</li>
</ul>
<h3 id="升序片键"><a href="#升序片键" class="headerlink" title="升序片键"></a>升序片键</h3><p>升序片键有点类似于<code>“data“</code>字段或<code>_id</code>字段，是一种会随着时间稳定增长的字段。</p>
<p>假设已存在一个集合，有5百万条数据，以简化的<code>_id</code>（实际<code>_id</code>是24个16进制字符组成，这里简化便于理解）建立三个分片0001-0003，集合根据<code>_id</code>拆分为多个范围的块，<code>$maxKey</code>指正无穷，<code>5000000-&gt;$maxKey</code>是一个最大块。之后插入的数据都会在最大块中，最大块不是无限大的，它会继续拆分成多个小块，不过还是有以下缺点：</p>
<ul>
<li>会导致之后所有的写操作均被路由至分片0003中</li>
<li>MongoDB必须不断地将一些块从分片0003移动至其他分片。</li>
</ul>
<p>优点是：很好的满足范围查询的请求，比如想查询范围在2500000~2500010的文档，mongos直接路由至分片0002就能查询出所有符合条件的文档。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%8D%87%E5%BA%8F%E5%88%86%E7%89%87.png" alt="1566993777773"></p>
<h3 id="随机分发的片键"><a href="#随机分发的片键" class="headerlink" title="随机分发的片键"></a>随机分发的片键</h3><p>随机分发的片键可以是用户名、邮件地址、设备id、md5散列值等没有规律的键。</p>
<p>假设片键是0-1之间的随机数，数据的随机性意味着新插入的数据会比较均衡的分发至不同的块中，因此，各分片的增长速度大致相同，这就减少了需要进行迁移的次数。</p>
<p>随机分发片键的缺点：范围查询要分发到后端所有的分片才能找出满足条件的文档</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%8F%91%E7%9A%84%E7%89%87%E9%94%AE.png" alt="1566995020969"></p>
<h3 id="基于位置的片键"><a href="#基于位置的片键" class="headerlink" title="基于位置的片键"></a>基于位置的片键</h3><p>片键是用户IP、经纬度、地址等，数据会依据这个位置进行分组，与该位置接近的文档会保存在同一个范围的块中，优点是可以将数据与相关联的用户、相关联的数据保存在一起。</p>
<h2 id="片键策略"><a href="#片键策略" class="headerlink" title="片键策略"></a>片键策略</h2><p>好的片键策略应该拥有如下特性：</p>
<ul>
<li>key 分布足够离散 </li>
<li>写请求均匀分布</li>
<li>读请求均匀分布，尽量避免 scatter-gather 查询 （所有读请求皆在一个分片上，targeted read）</li>
</ul>
<p>目前主要支持2种数据分布的策略，范围分片（Range based sharding）或hash分片（Hash based sharding） </p>
<ul>
<li>范围分片的策略的一种实现是升序片键，能很好的满足『范围查询』的需求，缺点在于，如果片键有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个块，无法扩展写的能力。</li>
<li>Hash分片是根据用户的片键计算hash值（64bit整型），根据hash值按照『范围分片』的策略将文档分布到不同的块。Hash分片与范围分片互补，能将文档随机的分散到各个chunk，充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要分发到后端所有的分片才能找出满足条件的文档。</li>
</ul>
<p>举个例子，某IOT应用使用 MongoDB分片集群存储海量设备（假设100W台）的工作日志，设备每10s向 MongoDB汇报一次日志数据（这个量级，无论从写入还是数据量上看，都应该使用 分片，以便能水平扩张），日志包含<code>deviceId</code>，<code>timestamp</code>信息，应用最常见的查询请求是：查询某个设备某个时间内的日志信息</p>
<ul>
<li><p>方案1：使用时间戳作为片键，采用范围分片策略</p>
<p>时间戳是递增的，支持范围分片策略，新的写入都是连续的时间戳，写入请求会集中到同一个分片上，写请求分布不均匀，但是<code>deviceId</code>不是片键，根据<code>deviceId</code>查询会分散到所有的分片上，效率低下。</p>
</li>
<li><p>方案2：使用时间戳作为片键，采用hash分片策略</p>
<p>由于采用了hash分片策略，保证了写请求均匀分布，与方案1一样，<code>deviceId</code>不是片键，根据<code>deviceId</code>查询会分散到所有的分片上，效率低下。</p>
</li>
<li><p>方案3：使用<code>deviceId</code>作为片键，采用范围分片策略</p>
<p>如果deviceId是没有明显规则的，写请求会均匀分布，根据<code>deviceId</code>的查询均会路由至该分片，查询的要求是某个设备的某个时间段，所以，路由至该分片后，还需要全表扫描并排序，才能找出该设备某时间段内的日志信息。</p>
</li>
<li><p>方案4：使用<code>deviceId</code>作为片键，采用hash分片</p>
<p>与方案3<code>deviceId</code>无规则时基本一致。</p>
</li>
<li><p>方案5：使用<code>deviceId</code>+时间戳作为片键，建立复合索引，采用范围分片策略</p>
<p>同一个设备的数据能够根据时间戳进一步分散到多个chunk，根据deviceId查询时间范围的数据，能够利用复合索引来完成，性能是最优的，不过前提是<code>deviceId</code>无明显规则。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（三）MongoDB索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（三）MongoDB索引/" itemprop="url">MongoDB系列（三）MongoDB索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T00:00:00+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>索引是特殊的数据结构，它以易于遍历的形式存储部分集合数据集。索引存储特定字段或字段集的值，按字段值排序。</p>
<p>MongoDB的索引几乎与传统的关系型数据库索引一模一样，第二章提到的<code>_id</code>实际上也是一个索引，MongoDB的数据按照<code>_id</code>的顺序存储在内存页与磁盘块上。但是，<code>_id</code>与业务毫无关联，在业务相关的条件查询时，还是需要进行全表扫描才能找到对应页，效率并不高。</p>
<ul>
<li>为了避免性能瓶颈，可以根据常用的查询建立索引</li>
<li>索引的值是按照一定的顺序排列的，因此，使用索引键对文档进行排序效率非常高。</li>
</ul>
<p>不过，使用索引也是有代价的，不仅会增加磁盘与内存的消耗，对于添加的每一个索引，每次写操作（插入、更新、删除）都会耗费更多时间，这是因为，数据发生变动时，还需要额外的开销更新索引。</p>
<h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>在介绍索引之前，先了解下聚簇索引与非聚簇索引。<br>磁盘上的数据某一时刻只能有一种排序方式，而聚簇索引的特点是：索引顺序与数据存储顺序一致，所以聚簇索引只能有一个。</p>
<p>《数据库原理》中对聚簇索引的定义：聚簇索引的叶子节点是数据节点，非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<p>所以Mysql的InnoDB引擎的主键索引是聚簇索引、MyIsam引擎使用的是非聚簇索引。</p>
<p>MongoDB不会将<code>_id</code>索引与文档内容放在一起，所以MongoDB的<code>_id</code>索引不是聚簇索引，mogoDB将数据与索引分开存放，通过RecordId间接引用。假设为字段<code>”name“</code>创建了索引，主键<code>id</code>为主键索引，那么该集合就通过索引查找RecordId，再查找数据。</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566960990983.png" alt="1566960990983"></p>
<h1 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h1><p>前面提到的<code>_id</code>索引是默认的主键索引，与业务相关联的项不适合用作主键（难以保障全局唯一、非null），建议使用<code>_id</code>作为主键。</p>
<h1 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h1><p>即对单个filed建立索引，也是常说的“普通索引”；建立索引时可以指定索引数据的order：正序还是倒序。MongoDB 3.0后的版本，使用<code>createIndex</code>、<code>ensureIndex</code>是一样的，均是创建索引的命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;) <span class="comment">//对score字段建立索引、1表示正序、-1表示倒序</span></span><br><span class="line">db.mycollection.createIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;) <span class="comment">// MongoDB 3.0后的版本，可以使用createIndex</span></span><br></pre></td></tr></table></figure>

<h1 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h1><p>两个或两个以上的键建立索引，可以减小检索的范围。复合索引与Mysql一样，也是按照左侧匹配规则，这里不赘述，主要介绍下复合索引与排序共用的情况。</p>
<p>首先，在集合<code>”myc“</code>上创建一个复合索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.ensureIndex(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;); <span class="comment">// 索引1</span></span><br></pre></td></tr></table></figure>

<p>再创建一个:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;); <span class="comment">// 索引2</span></span><br></pre></td></tr></table></figure>

<p>这两个复合索引的唯一区别就是键顺序不同，排序规则都是正序（1表示正序、-1表示倒序）。</p>
<p>由于存在了多个索引，使用<code>hint</code>命令指明使用哪个索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询1使用索引1</span></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询2使用索引2</span></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于查询1，先根据索引<code>age</code>查找复合条件的结果集，然后在内存中排序（<code>age</code>索引是有序的，但是排序规则用不到）</li>
<li>对于查询2，遍历整个索引树，找出所有匹配的文档，不需要排序（<code>name</code>索引本身就是有序的），按正序遍历即可。</li>
</ul>
<p>查询1和查询2究竟哪个性能更强，取决于结果集的大小，一般的，结果集越大，在内存中排序耗时越久，超过一定大小（32MB）后，MongoDB会抛出异常，拒绝对如此多的数据排序。一般的：</p>
<ul>
<li>结果集只有几条、十几条，使用查询1，排序的开销跟遍历树的开销相比并不大</li>
<li>结果集有几百条、甚至几千条，使用查询2，排序的开销显得过大。</li>
<li>结果集有几万条，使用查询1或查询2建议具体比较一下</li>
</ul>
<p>结果集的大小可以使用<code>limit</code>关键字人为限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).limit(<span class="number">1000</span>).hint(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;); \\使用查询<span class="number">2</span>，并限制结果集</span><br></pre></td></tr></table></figure>

<p>最后，具体使用哪种查询，使用<code>explain</code>关键字在shell中比较一下再做选择。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;).explain()[<span class="string">`millis`</span>]; \\获取查询<span class="number">1</span>耗时</span><br><span class="line"></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;).explain()[<span class="string">`millis`</span>]; \\获取查询<span class="number">2</span>耗时</span><br></pre></td></tr></table></figure>

<h1 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h1><p>唯一索引用来确保集合的每一个文档的指定键都有唯一值，允许null值。例如：在集合mycollection中，给”name“键建立唯一索引，试图插入重复name的值时，会抛出异常，也会影响效率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;, &#123;<span class="string">"unique"</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>使用场景：应对<strong>偶尔</strong>可能会出现重复的键重复问题，而不是在运行时对重复键进行过滤。比如：为避免消息重复消费，可以为”消息id“键创建唯一索引。</p>
<h2 id="复合唯一索引"><a href="#复合唯一索引" class="headerlink" title="复合唯一索引"></a>复合唯一索引</h2><p>复合的唯一索引，单个键的值可以相同，<strong>但所有键的组合值必须是唯一的</strong>。</p>
<p>例如，如果有一个{”username”:1, “age”:100}上的唯一索引，下面的插入是合法的，不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>&#125;);</span><br><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125;);</span><br><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"fred"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h2><p>在已有的集合上创建唯一索引时，可能会失败，因为集合中可能已经存在重复的值了。此时，有三种办法：</p>
<ul>
<li><p>找出重复数据，想办法去除</p>
</li>
<li><p>直接删除重复的值，创建索引时使用<code>”dropDups“</code>选项，如果遇到重复的值，只会保留第一个值。正是由于这种不确定性（不确定哪条记录被删除），MongoDB 3.0以后移除了该选项。</p>
</li>
<li><p>新建一个集合，建立索引，然后把旧集合的数据拷贝至新集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>&#125;,&#123;<span class="string">"unique"</span>:<span class="literal">true</span>,<span class="string">"dropDups"</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h1><p>唯一索引会把null看做值，假如集合中有以下两个文档，假设对键<code>”age“</code>建立唯一索引，则文档2中的<code>&quot;age&quot;</code>就是<code>null</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125; <span class="comment">// 文档1</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>&#125; <span class="comment">// 文档2</span></span><br></pre></td></tr></table></figure>

<p>现在想新增文档3，是无法添加的，因为文档3中<code>”age“</code>也是<code>null</code>，与文档2冲突了，违反了唯一性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"addresss"</span>:<span class="string">"sz"</span>&#125; <span class="comment">// 文档3</span></span><br></pre></td></tr></table></figure>

<p>此时，应该使用稀疏索引（sparse index），就可以插入文档3，同时也能保证文档4无法插入，满足唯一性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建稀疏索引</span></span><br><span class="line">db.ensureIndex(&#123;<span class="string">"age"</span>:<span class="number">1</span>&#125;, &#123;<span class="string">"unique"</span>: <span class="literal">true</span>, <span class="string">"sparse"</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"dod"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125; <span class="comment">// 文档4</span></span><br></pre></td></tr></table></figure>

<p>稀疏索引定义如下：如果集合中的文档存在索引键，则必须是唯一的，如果文档不存在索引键，则不要求该文档的唯一性。</p>
<p><strong>注意事项：</strong></p>
<p>根据是否使用稀疏索引，查询结果可能有所不同。例如：对于下面的查询，查询1和查询2是完全相同的语句，不同的是，查询1对应未创建稀疏索引的情况，查询2对应创建稀疏索引的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$ne"</span>:<span class="number">23</span>&#125;&#125;) <span class="comment">// 查询1，未创建稀疏索引</span></span><br><span class="line">db.mycollection.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$ne"</span>:<span class="number">23</span>&#125;&#125;) <span class="comment">// 查询2</span></span><br></pre></td></tr></table></figure>

<p>查询结果如下，查询2没有查询到文档，这是因为<strong>建立了稀疏索引后，查询只根据索引查询，不再全表扫描，因此，会遗漏那些没有索引键的文档。</strong>如果一定要获取与查询1相同的结果，通过<code>hint</code>命令指明不使用索引，执行全表扫描。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询1的查询结果</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"addresss"</span>:<span class="string">"sz"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询2的查询结果</span></span><br><span class="line"><span class="comment">// nothing...</span></span><br></pre></td></tr></table></figure>

<h1 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h1><p>TTL（Time-to-live index）索引指具有生命周期的索引，这种索引会为文档设置一个超时时间，一旦文档存活时间超过该时间就会被删除。这种类型的索引可以用在：消息日志、服务器会话等具有时效性的场景。</p>
<p>在<code>&quot;createdTime&quot;</code>字段上创建TTL索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.createIndex(&#123;<span class="string">"createdTime"</span>:<span class="number">1</span>&#125;, <span class="string">"expireAfterSecs"</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p><code>&quot;createdTime&quot;</code>字段必需是日期类型，一般设置为当前时间，</p>
<p>​        记录被删除的时间点=<code>&quot;createdTime&quot;</code>字段对应的时间点+<code>&quot;expireAfterSecs&quot;</code>对应的单位为秒的时间段</p>
<p>为了避免活跃的会话被删除，可以在会话上有活动发生时，更新<code>&quot;createdTime&quot;</code>为当前时间。</p>
<p>一个集合上可以创建多个TTL索引。</p>
<h1 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h1><p>与Mysql一样，MongoDB也支持全文检索。创建全文索引的开销较大，MongoDB本身就很耗内存，在一个操作频繁的集合上创建全文索引更容易导致内存不足，全文本索引的集合写入性能更差、分片时迁移速度更慢，一般的，如果不是特别强烈的业务需要，不建议使用全文索引。</p>
<p>在<code>&quot;mytext&quot;</code>字段上创建全文索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"mytext"</span>:<span class="string">"text"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>使用全文索引检索关键字<code>&quot;keyword&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">"keyword"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h1><p>MongoDB支持几种类型的索引，最常见的是2dsphere索引（用于球面图）和2d索引（用于平面图）。这里只简单介绍下这两种索引的创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"myloc"</span>:<span class="string">"2dsphere"</span>&#125;)</span><br><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"myloc"</span>:<span class="string">"2d"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>如果数据库中已有大量数据，此时建立索引将会导致大量的IO操作（内存，磁盘读写），耗时较长。MongoDB提供了2种方式：foreground和background。</p>
<ul>
<li>foreground即前台操作，它会阻塞用户对数据的读写操作直到index构建完毕，即任何需要获取read、write锁的操作都会阻塞，默认情况下为foreground；</li>
<li>background即后台模式，不阻塞数据读写操作，独立的后台线程异步构建索引，此时仍然允许对数据的读写操作；<strong>其中background比foreground更加耗时。</strong></li>
</ul>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul>
<li><p>对频繁访问的查询，尽量使用覆盖索引，如果一个索引包含（或者说覆盖）所有需要查询的数据，就称为“覆盖索引”，使用覆盖索引时，需要强制不显示objectId字段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.createIndex(&#123;<span class="string">"name"</span>, <span class="number">1</span>&#125;)</span><br><span class="line">db.mycollection.find(&#123;<span class="string">"name"</span>:bob, <span class="string">"_id"</span>:<span class="number">0</span>&#125;) <span class="comment">// 0表示不显示该字段</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选用差异性较强的字段作为索引，不要选用类似于性别、国家这种字段作为索引键。</p>
</li>
<li><p>需要哪些字段查询哪些字段，尽量不要查询整个文档</p>
</li>
<li><p>使用hint强制使用特定的索引</p>
</li>
<li><p>使用explain对比分析多种查询方式的性能</p>
</li>
</ul>
<h2 id="写操作优化"><a href="#写操作优化" class="headerlink" title="写操作优化"></a>写操作优化</h2><ul>
<li>尽量不要创建过多的索引，索引会增加该集合写入、更新、删除的开销，因为要额外维护索引</li>
<li>合理设置journal相关参数，journal日志实现日志预写功能，开启journal保证了数据持久化，但也会存在一定的性能消耗，合理的设置commitIntercalMs控制journal写入磁盘的频率，该参数过大，影响MongoDB写操作的性能，该参数过小，MongoDB意外宕机期间预写日志未持久化的可能增大。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/ MongoDB系列（二）MongoDB存储引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ MongoDB系列（二）MongoDB存储引擎/" itemprop="url">MongoDB系列（二）MongoDB存储引擎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T00:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MongoDB 2.6版本之前（包括2.6），只有一种存储引擎：MMAP（Memory mapping，内存映射引擎）。MongoDB 3.0以后，MMAP升级为MMAPv1， 同时提供了插件式引擎API，引入wiredTiger，mongoDB 3.2默认使用WiredTiger引擎，MongoDB 4.0版本删除了MMAP引擎。</p>
<h1 id="MMAPv1引擎"><a href="#MMAPv1引擎" class="headerlink" title="MMAPv1引擎"></a>MMAPv1引擎</h1><p>常规的文件系统操作（调用read等函数）为了提高读写效率和保护磁盘，采用的是页缓存机制，读文件时需要先将文件页从磁盘拷贝至页缓存中，页缓存处在内核空间，不能被用户进程直接寻址，还需要将页缓存中的数据再次拷贝到内存对应的用户空间中，所以需要通过两次数据拷贝的过程，才能完成进程对文件内容的获取。</p>
<p>在MMAP操作文件时，创建新的虚拟存储区域，建立文件磁盘地址与虚拟地址的映射关系，<strong>此时MMAP只是在虚拟内存分配了地址空间，所以32位的机器，最多支持2GB的文件映射</strong>。之后访问数据时，通过已建立好的映射关系,只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/MMAP%E6%98%A0%E5%B0%84.png" alt="img"></p>
<p>在MongoDB的MMAPv1引擎机制中，服务器启动时，其内存对所有数据文件进行映射，接下来<strong>完全由操作系统负责将数据刷新到磁盘，以及管理内存中数据页的交换</strong>。</p>
<h2 id="MMAPv1引擎的命名空间与区段"><a href="#MMAPv1引擎的命名空间与区段" class="headerlink" title="MMAPv1引擎的命名空间与区段"></a>MMAPv1引擎的命名空间与区段</h2><p>MMAPv1引擎中，每个数据库由一个.ns文件和若干数据文件组成，数据文件从0开始编号，mydb.0、mydb.1、mydb.2等，文件大小从64MB起，依次倍增，最大为2GB。这一特性使得较小的数据库不会浪费过多的空间，而较大的数据库可使用连续的磁盘空间。图中，mydb.1、mydb.2、mydb.3（为便于理解，此处省略了mydb.0）分别是数据库mydb的三个数据文件，mydb.ns的文件用于保存mydb数据库的命名空间元数据，图中未给出。</p>
<p>每个数据库包含多个命名空间（namespace），存放在.ns文件中，单个命名空间128字节，数据库按照命名空间进行组织，每个命名空间中存放特定集合的数据，<strong>集合中的文档、索引都拥有自己的命名空间</strong>。mydb.ns文件实际是一个hash表，用于快速定位某个namespace的起始位置。</p>
<p>如下图，数据库mydb包含了两个集合c1、c2，对应<strong>两个命名空间mydb.c1、mydb.c2</strong>，mydb.$freelist是一个特殊的命名空间，用于跟踪记录不再使用的区段（如被删除的集合或索引所在的区段），最后，还有一个预分配命名空间。</p>
<p>每个命名空间的数据可以在磁盘上分为几组数据，即区段。这几个区段在磁盘上未必是连续的（图例中不连续）。</p>
<p>MongoDB也会预分配数据文件，数据文件一旦被填满，就开始预分配，这意味着MongoDB服务器总会为每个数据库维护一个额外的空白数据文件（如图中的mydb.3），以提前避免文件分配失败。使用 <code>-- noprealloc</code>选项可以关闭预分配功能。</p>
<p>mydb.1、mydb.2，分成了分属于不同命名空间的区段，mydb.1有三个区段、mydb.2有四个区段、mydb.3只有一个区段，该区段属于预分配空间。在为命名空间分配一个新的区段时，会先搜索空闲列表mydb.$freelist，查看是否存在合适大小的区段。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8C%BA%E6%AE%B5.png" alt="1566543786631"></p>
<p>前面提到，mydb.ns是一个hash表，一个namespace对应一个集合或索引，该hash表中，一个节点元数据结构如下，每个节点628字节，16MB的.ns文件最多存储26715个namespace。哈希碰撞的概率也较低，采用的线性探针的方式解决哈希冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Namespace key;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    NamespcaeDetails value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>key为namespace的名字，固定分配128字节的空间</li>
<li>hash为namespace的hash值</li>
<li>value包含该namespace的所有元数据，定义如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamespaceDetails</span> &#123;</span></span><br><span class="line">    DiskLoc firstExtent; <span class="comment">// 第一个区段</span></span><br><span class="line">    DiskLoc lastExtent; <span class="comment">// 最后一个区段</span></span><br><span class="line">    <span class="comment">// 不同大小的删除列表</span></span><br><span class="line">    DiskLoc deletedListSmall[SmallBuckets];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskLoc</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _a; <span class="comment">// 数据文件编号，mydb.1编号为1，定位文件</span></span><br><span class="line">    <span class="keyword">int</span> ofs; <span class="comment">// 文件内部偏移量，定位文件内部的存储位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>firstExtent描述了第一个区段的位置</li>
<li>lastExtent描述了最后一个区段的位置</li>
<li>deletedList描述了各个被删除的元素</li>
</ul>
<p>通过这些信息，可以遍历一个namespace下的所有区段的有效数据，区段的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Extent</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> magic; <span class="comment">// 魔法数，校验合法性</span></span><br><span class="line">    DiskLoc myLocation; <span class="comment">// extent自身位置指针</span></span><br><span class="line">    DiskLoc next; <span class="comment">// 下一个extent位置指针</span></span><br><span class="line">    DiskLoc pre; <span class="comment">// 上一个extent位置指针</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// extent长度</span></span><br><span class="line">    DiskLoc firstRecord; <span class="comment">// extent内第一个record位置指针</span></span><br><span class="line">    DiskLoc lastRecord; <span class="comment">// extent内最后一个record位置指针</span></span><br><span class="line">    <span class="keyword">char</span> _extentData[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _len;</span><br><span class="line">    <span class="keyword">int</span> _extentOfs;</span><br><span class="line">    <span class="keyword">int</span> _nextOfs;</span><br><span class="line">    <span class="keyword">int</span> _preOfs;</span><br><span class="line">    <span class="keyword">char</span> _data[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record 被删除后，以deletedRecord存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeletedRecord</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> _len;  <span class="comment">// record长度</span></span><br><span class="line">   <span class="keyword">int</span> _extentOfs; <span class="comment">// record所在的extent位置指针</span></span><br><span class="line">   DiskLoc _nextDeleted; <span class="comment">// 下一个已删除记录的位置</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>一条record对应mongoDB的一个文档，即一条数据记录。同一个区段（extent）下的所有<strong>record以双向链表的形式组织</strong>，record 被删除后，以deletedRecord存储，<strong>deletedRecord以单向链表的形式组织</strong>。</p>
<h2 id="MMAPv1引擎CRUD"><a href="#MMAPv1引擎CRUD" class="headerlink" title="MMAPv1引擎CRUD"></a>MMAPv1引擎CRUD</h2><p><strong>写入</strong></p>
<p>1、检查namespaceDetail中的deletedList中是否有合适的deletedRecord可以利用，如果有，则删除该记录并复用删除空间。</p>
<p>2、检查数据文件的<strong>$freelist</strong>里是否有大小合适的不再使用的区段，如果有则复用该空间</p>
<p>3、第1、2步均不成功，创建新的区段，如果当前数据文件没有足够空间创建新区段，创建新数据文件。</p>
<p><strong>删除</strong></p>
<p>删除的记录会以DeleteRecord的形式插入到对应集合的删除链表里，删除的空间在下一次写入新的记录时可能会被利用上；但也有可能一直用不上而浪费。比如某个128Bytes大小的记录被删除后，接下来写入的记录一直大于128B，则这个128B的DeletedRecord不能有效的被利用。当删除很多时，可能产生很多不能重复利用的”存储碎片”，从而导致存储空间大量浪费；<strong>可通过compact命令整理碎片。</strong>该命令会持有数据库级别的锁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand ( &#123; <span class="attr">compact</span>: <span class="string">'&lt;collection&gt;'</span> &#125; )</span><br></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<p>更新跟删除类似，也有可能产生很多存储碎片</p>
<ul>
<li>更新的Record比原来小，可以直接复用现有的空间（原地更新）；多余的空间如果足够多，会将剩余空间插入到DeletedRecord链表；</li>
<li>更新的Record比原来大，更新相当于删除 + 新写入，原来的空间会插入到DeletedRecord链表里。文档需要移动到文件中的其他位置，这种因更新导致的文档位置移动会严重降低写入性能，因为一旦文档移动，集合中的所有索引都要同步修改文档新的存储位置，<strong>可通过设置填充因子（paddingFactor）进行优化</strong>，比如：如果填充因子为2，一个大小为200字节的文档插入是，会自动在文档后填充100个字节的空间，这样在更新时，会使用第一种方式（更新的record比原来小）。</li>
</ul>
<p><strong>查询</strong></p>
<p>没有索引的情况下，查询某个Record需要遍历整个集合，读取出符合条件的Record；如果经常需要根据每个纬度查询Record，则需要给集合建立索引以提供查询效率。</p>
<h2 id="MMAPv1引擎锁粒度"><a href="#MMAPv1引擎锁粒度" class="headerlink" title="MMAPv1引擎锁粒度"></a>MMAPv1引擎锁粒度</h2><p>MMAPv1 3.0版本之前锁粒度是库，3.0版本后所粒度是集合，即表级锁，不支持事务，原子操作是文档的保存、修改、删除。</p>
<h1 id="WiredTiger引擎"><a href="#WiredTiger引擎" class="headerlink" title="WiredTiger引擎"></a>WiredTiger引擎</h1><p>mongoDB 3.2设置wiredTiger为默认的存储引擎（之前版本默认MMAPv1），WiredTiger存储引擎负责将写操作写入cache（<strong>B树结构</strong>），满足条件后持久化（默认条件每隔60s或达到2GB）</p>
<p>与MMAPv1一样，journal日志（<strong>预写式日志，write ahead log，WAL</strong>）用于数据恢复。对于write操作，首先被持久写入journal，然后在内存中保存变更数据，<strong>条件满足后提交一个新的检测点checkpoint</strong>，即检测点之前的数据只是在journal中持久存储，但并没有在mongodb的数据文件中持久化，延迟持久化可以提升磁盘效率，如果在提交checkpoint之前，mongodb异常退出，此后再次启动可以根据journal日志恢复数据。，如果60s内机器宕机，且未开启journal日志，会丢失这60s的数据。journal日志默认每100毫秒同步磁盘一次，每100M数据生成一个新的journal文件，journal默认使用了snappy压缩，检测点创建后，此前的journal日志即可清除。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="1566802633253"></p>
<h2 id="WiredTiger引擎文件空间分配"><a href="#WiredTiger引擎文件空间分配" class="headerlink" title="WiredTiger引擎文件空间分配"></a>WiredTiger引擎文件空间分配</h2><p>MMAPv1引擎中，集合和索引都以命名空间的方式混合存储在数据库文件中mydb.1、mydb.2等，同一个数据库文件存在多个集合的数据，例如mydb.1保存了集合c1、c2，即便删除了某个集合或索引，其占用的磁盘空间也会产生碎片难易清除。文件的存储级别是<strong>数据库级别</strong></p>
<p>WiredTiger引擎中，文件的存储级别是<strong>集合和索引级别</strong>。将每个数据库中的所有集合和索引分别存储在单独的文件中，删除了集合或索引后，对应的文件自动清除，磁盘回收效率更高。</p>
<p>data/db目录下的文件如下：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D1.png" alt="1566795516284"></p>
<p>整体的目录结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="1566796884855"></p>
<ul>
<li>collection.wt存储集合信息，以编号不同区分，collection1.wt、collection2.wt</li>
<li>index.wt存储索引信息，编号区分</li>
<li>WiredTiger.lock定义锁操作</li>
<li>WiredTiger.wt 存储collection.wt与index.wt的元数据</li>
<li>WiredTiger.turtle 存储WiredTiger.wt 元数据</li>
<li>journal 目录 存储journal日志</li>
</ul>
<h2 id="WiredTiger引擎存储模型"><a href="#WiredTiger引擎存储模型" class="headerlink" title="WiredTiger引擎存储模型"></a>WiredTiger引擎存储模型</h2><p>WiredTiger在执行写入任务时，不是直接写入到磁盘，首先写入的是cache，然后批量持久化，这也是MongoDB吃内存的主要原因，cache中使用B树保存数据，每个B树对应磁盘上的一个物理文件，树节点对应一个内存页、硬盘块，<strong>所以根节点与内部节点均会用于存储数据</strong>，目的是尽可能减少磁盘IO从而提高性能。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="1566801831809"></p>
<p>cache中的一个Page对应磁盘上的一个Extent（Mysql Innodb是1对4的关系），Extent大小为4K，存储了一系列键值对。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger-Page.png" alt="1566869294605"></p>
<h3 id="WiredTiger引擎更新、插入、删除"><a href="#WiredTiger引擎更新、插入、删除" class="headerlink" title="WiredTiger引擎更新、插入、删除"></a>WiredTiger引擎更新、插入、删除</h3><ul>
<li>遍历B树，找到待更新的页（如果cahce中没有热数据，从磁盘中获取，生成一个WT_ROW）</li>
<li>如果有必要，生成预写日志</li>
<li>在待更新的页执行更新、插入、删除操作</li>
</ul>
<p>当对某个键的值进行更新、删除时，将创建一个用于更新的结构，包含了事务id、已更改数据、指向后续更新的指针，之后的更新会将自己添加到前一个结构的末尾，随着时间的推移创建一个不同版本值的链式结构，N次更新组成长度为N的linkedlist。</p>
<p>当进行插入时，生成一个skip linkedlist用于保存插入的信息，N次插入生成长度为N的保存了各skip linkedlist头信息的linkedlist—WT_INSERT_HEAD。</p>
<h3 id="Copy-on-write"><a href="#Copy-on-write" class="headerlink" title="Copy on write"></a>Copy on write</h3><p>WiredTiger引擎采用Copy on write的方式管理修改操作（insert、update、delete），修改操作会先缓存在cache里，持久化时，<strong>修改操作不会在原来的leaf page上进行，而是写入新分配的page，每次checkpoint都会产生一个新的Root Page</strong>。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WireTiger%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png" alt="1566804600903"></p>
<p>与MMAPv1引擎类似，当一个文档被删除时，WiredTiger不会立即归还该空间，会在后续的删除、更新、插入操作中优先复用该空间，可能会存在碎片，但影响不大，如果要整理碎片，可以调用compact命令。</p>
<h2 id="为什么WiredTiger引擎使用B树而不是B-树"><a href="#为什么WiredTiger引擎使用B树而不是B-树" class="headerlink" title="为什么WiredTiger引擎使用B树而不是B+树"></a>为什么WiredTiger引擎使用B树而不是B+树</h2><p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/B%E6%A0%91.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/B+%E6%A0%91.png" alt="img"></p>
<p>B树与B+树的简要图如上，二者最大的区别就是B树所有节点都用来存储key+data，而B+树只有叶子节点存储key+data，根节点与中间节点保存的是key的副本，相应的页存储的是key+指针，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</p>
<p><strong>无论是MongoDB选择B树，还是Mysql的InnoDB、MyIsam引擎选择B+树，目的都是尽可能减少磁盘IO。</strong></p>
<p>MongoDB是一种聚合型数据库，它组织数据的特点就是将经常访问的数据放在一块（同一个JSON下包含所有信息），对于单个查询能够在与数据库的一次交互中将所有数据全部取出来，对于上图中key为37的数据，无论是B树还是B+树，都是3次IO，而对于key为50的数据，使用B树只需要1次IO，使用B+树需要3次IO。</p>
<p>而Mysql是关系型数据库，使用B+树提高根节点和内部节点存放的信息量（由于内节点无 data 域，每个节点能索引的范围更大更精确），从而减少查询次数，达到减小磁盘IO的目的。最重要的是，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历，然而，MongoDB很少有区间访问的需求，也就没有这种磁盘预读机制的需求。</p>
<h2 id="WiredTiger引擎锁粒度"><a href="#WiredTiger引擎锁粒度" class="headerlink" title="WiredTiger引擎锁粒度"></a>WiredTiger引擎锁粒度</h2><p>WiredTiger的锁粒度为文档，对应Mysql的行级锁。</p>
<h2 id="WiredTiger引擎4-0——事务"><a href="#WiredTiger引擎4-0——事务" class="headerlink" title="WiredTiger引擎4.0——事务"></a>WiredTiger引擎4.0——事务</h2><p>mongoDB对一个文档的写操作，会产生三个动作：</p>
<ul>
<li>对存储数据的Btree执行写操作</li>
<li>对存储索引的Btree执行写操作</li>
<li>对oplog（option log，与预写日志不是一回事，一个是已发生的，一个是将要发生的）执行写操作</li>
</ul>
<p>MongoDB的单文档事务指：上述三个动作的更新是原子的，处于同一个事务中。不存在<strong>索引段中的某个RecordId，在数据段中找不到</strong>，也不存在<strong>一条记录的更改被应用，但是没有记录到oplog中</strong>, 反之亦然。</p>
<p>MongoDB  4.0提供了事务API，开始支持事务操作。它的事务是基于快照SANPSHOT、MVCC（Multi-Version Concurrency Control，多版本并发控制）实现的。</p>
<h3 id="sanpshot"><a href="#sanpshot" class="headerlink" title="sanpshot"></a>sanpshot</h3><p>snapshot即快照。事务开始时，对整个WiredTiger内部正在执行或将要执行的所有事务进行一次截屏，保存当时整个引擎所有事务的状态。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger%E4%BA%8B%E5%8A%A1.png" alt="1566873597953"></p>
<p>snapshot_object保存了快照信息。</p>
<ul>
<li>snap_min 最小执行事务</li>
<li>snap_max 最大执行事务</li>
<li>snap_array 位于snap_min与snap_max之间正在执行的事务，是不可见的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snapshot_object = &#123;</span><br><span class="line">    snap_min=T1,</span><br><span class="line">    snap_max=T5,</span><br><span class="line">	snap_array=&#123;T1, T4, T5&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>凡是出现在snap_array中或事务ID&gt;snap_max的事务均是不可见的。</strong>即便建立snapshot之后T1、T4、T5提交了，T6也无法访问的T1、T4、T5的修改。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC基于事务ID和记录值实现一个链表，新的事务与相应的修改value，插入链表头部，链表中的节点定义抽象如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wt_mvcc&#123;</span><br><span class="line">	transaction_id:    本次修改事务的ID	</span><br><span class="line">	value:             本次修改后的值</span><br><span class="line">    next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取值时从链表头开始，根据snapshot来判断是否可读，如果不可读，向链表尾方向移动，直到找到第一个能够读的数据版本，下图中，读事务T5与读事务T3均会读到V1。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/MVCC.png" alt="1566880968502"></p>
<h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>传统的数据库事务隔离分为:Read-Uncommited(未提交读)、Read-Commited(提交读)、Repeatable-Read(可重复读)和Serializable(串行化)，WiredTigerT引擎并没有按照传统的事务隔离实现这四个等级，而是基于snapshot的特点实现了下列事务隔离方式：</p>
<ul>
<li>Read-Uncommited</li>
<li>Read-Commited</li>
<li>snapshot-Isolation(快照隔离)</li>
</ul>
<p><strong>Read-Uncommited</strong></p>
<p>又称为脏读，是最低的隔离级别，<strong>总是读取到系统中最新的修改（包括未提交）</strong>。WiredTiger的实现方式很简单，将snap_array置为空即可。在上图中，隔离级别设置为脏读后，事务T5读取到的值为V4。一般数据库不会设置成这种隔离方式，它违背了事务的ACID的特性。</p>
<p><strong>Read-Commited</strong></p>
<p>又称为幻读，<strong>总是读取到最新的、已提交的修改</strong>。这种隔离级别可能在一个长事务多次读取一个值的时候前后读到的值可能不一样。</p>
<p>假设上图中的T5包含了两次读操作，中间sleep了2s，在这2s内T4提交了，则事务T5中，第一次读到的值为V1，第二次读到的值为V4。</p>
<p><strong>snapshot-Isolation(快照隔离)</strong></p>
<p>只在事务开始时生成一次快照，无论事务持续的过程中其他事务修改了几次值，该快照都不改变，<strong>所以值在整个事务执行过程中只有一个版本</strong>。</p>
<p>事务T4的修改对T5不可见，如果T5也是一个写事务，在T5开始时，T4未提交，T5执行过程中，T4提交了，T5再去修改值，会产生失败回滚。这样做的目的是防止忽略不可见数据的修改。</p>
<h3 id="与Mysql事务的区别"><a href="#与Mysql事务的区别" class="headerlink" title="与Mysql事务的区别"></a>与Mysql事务的区别</h3><p>通过上面对三种事务隔离方式的分析，<strong>WiredTiger并没有使用传统的事务独占锁和共享访问锁来保证事务隔离</strong>，而是通过对系统中<strong>写事务的snapshot截屏来实现</strong>。这样做的目的是在<strong>保证事务隔离的情况下又能提高系统事务并发的能力</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（一）MongoDB简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（一）MongoDB简介/" itemprop="url">MongoDB系列（一）MongoDB简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T00:00:00+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB是一款强大、灵活、易于扩展的、由C++编写的聚合型、文档型、NoSQL数据库，支持二级索引、范围查询、排序、聚合、地理空间索引等功能。</p>
<p>MongoDB是面向文档的数据库，不是关系型数据库，不采用关系模型是为了更好的扩展性。与关系型数据库相比，有以下特点：</p>
<ul>
<li>没有“一行数据”的概念，取而代之的是“一条文档”</li>
<li>不再有预定义模式，文档的键和值不再是固定的类型和大小，可以随意扩展。</li>
<li>易于扩展，随着数据的增长，横向扩展（增加机器）变得更加方便，MongoDB能够自动处理跨集群的数据和负载，自动重新分配文档、自动将用户请求路由至正确的机器上。</li>
<li>功能丰富，支持索引、聚合、文件存储、以及特殊集合，如会过期的数据：日志、会话等。</li>
<li>性能更强，4.0版本前不支持事务，但提供了诸多原子操作：文档的保存、修改、删除。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/NoSQL.png" alt="img"></p>
<h1 id="文档与集合"><a href="#文档与集合" class="headerlink" title="文档与集合"></a>文档与集合</h1><p>文档是MongoDB中数据的基本单元，类似于关系型数据库管理系统中的行，但灵活性更高。例如：</p>
<p><code>{&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:20}</code></p>
<p>集合是一组文档，可以看做是一个拥有动态模式的表。因此，MongoDB中的文档没有预定义模，一个集合中可以保存多个完全不同的文档，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  &#123;<span class="string">"name"</span>:<span class="string">"xiaoming"</span>, <span class="string">"age"</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="number">2</span>  &#123;<span class="string">"name"</span>:<span class="string">"xiaohei"</span>, <span class="string">"age"</span>:<span class="number">20</span>, <span class="string">"man"</span>:<span class="literal">true</span>, <span class="string">"address"</span>:<span class="string">"sz"</span>&#125; </span><br><span class="line"><span class="number">3</span>  &#123;<span class="string">"device"</span>:<span class="string">"rcu"</span>,<span class="string">"devId"</span>:<span class="string">"1234567890"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>备注：集合命名时，不能有空字符串、不能包含\0、不能包含$、不能以system.开头</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>多个集合组成一个数据库、一个MongoDB实例包含多个数据库，每个数据库拥有独立的权限，在磁盘上，不同的数据库放置在不同的文件夹中，一般的，一个应用程序使用一个数据库。</p>
<p>有三个数据库是默认保留的：admin（root库）、local（用于副本集模式）、config（用于分片模式）</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MongoDB的文档与JavaScript中对象相近，类似于JSON，MongoDB支持JSON包含的6种数据类型：null、布尔型、数值、字符串、数组、对象，MongoDB还添加了其他一些数据类型：日期、正则表达式、数组、内嵌文档、对象id、二进制数据、JavaScript代码。</p>
<p>下面只介绍：日期、数组、内嵌文档、对象id。</p>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>对应JAVA、JS中的Date类，存入数据库的是Date对象，不是日期字符串。数据库中存储的日期为新纪元以来的毫秒数，并未存储时区，Date对象与毫秒之间的转换，由MongoDB负责，客户端不需要关心。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与JAVA数组不同的是，数组可以包含不同类型的元素，数组可以嵌套数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"things"</span>:[<span class="string">"apple"</span>, <span class="number">3.1415926</span>]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h2><p>文档可以作为键的值，这样的文档就是内嵌文档。类似于JSON嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"things"</span>:&#123;</span><br><span class="line">    	<span class="string">"name"</span>:<span class="string">"apple"</span></span><br><span class="line">        <span class="string">"price"</span>:<span class="number">3.14</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="objectId"><a href="#objectId" class="headerlink" title="objectId"></a>objectId</h2><p>MongoDB存储的文档必需有一个”_id“键，这个键可以是任意类型，默认是个ObjectId对象。objectId作为文档的唯一标识符。如果插入文档时，没有设置objectId，MongoDB客户端驱动会自动创建一个。</p>
<p>object_id大小为12字节，是一个由24个十六进制数字组成的字符串。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/OBJECT_ID.png" alt="1566887583799"></p>
<ul>
<li><p>时间戳：占用前4个字节，从标准纪元开始的时间戳，单位为秒，</p>
</li>
<li><p>机器标识位：占用3个字节，是所在主机名的唯一标识，通常是机器名的hash值。</p>
</li>
<li><p>PID：产生 objectId的进程的ID</p>
</li>
<li><p>计数器： 前9个字节保证了同一秒钟不同机器不同进程的ObjectId是唯一的，最后三个字节用来确保同一秒同机器同进程的objectId的唯一性。所以每个进程同一秒最多允许产生<br>$$<br>（2^8)^3=16777216<br>$$<br>个不同的objectId。对于服务器来说，1600W个足够用了。</p>
</li>
</ul>
<p>从objectId的设计可以看出，MongoDB的设计初衷就是用作分布式数据库，能够在副本集、分片环境下生成全局唯一id。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列(四)MessageConvert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列(四)MessageConvert/" itemprop="url">springboot+RabbitMQ系列（四）MessageConvert</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T00:00:00+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可以为<code>ListenerContainer</code>和<code>RabbitTemplate</code>设置<code>MessageConverter</code>。这样就不用每次都写重复的消息格式转换代码了。spring提供的Message Converter均是双向的，负责将入站消息转换为特定结构（如：字节数组、序列化java对象、字符串、自定义的消息domain对象），将特定格式转换为出站消息。</p>
<h1 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h1><p>springboot-amqp涉及到两种消息格式，定义如下：</p>
<ol>
<li><p>org.springframework.messaging.Message&lt;?&gt; message，spring框架中通用的Message。简称<code>spring-messaging Message</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">		<span class="function">T <span class="title">getPayload</span><span class="params">()</span></span>;    </span><br><span class="line">		<span class="function">MessageHeaders <span class="title">getHeaders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>spring AMQP Message</code>，spring为了适配AMQP协议，简化接口参数引入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>spring-messaging Message</code>中的<code>payload</code>对应了<code>spring AMQP Message</code>中的<code>byte[] body</code>，他们均是Rabbit Client 中的body，即消息内容。</p>
<p><code>spring-messaging Message</code>中的<code>MessageHeaders</code>对应了<code>spring AMQP Message</code>中的<code>MessageProperties</code>，他们均是Rabbit Client 中的<code>BasicProperties</code>，即消息头。</p>
<p>因此，后文的MessgeConverter如不加特殊说明，均指的消息内容的格式转换。消息头的格式转换见<code>2.3.7 MessagePropertiesConverter</code></p>
<h1 id="RabbitListener底层实现原理"><a href="#RabbitListener底层实现原理" class="headerlink" title="@RabbitListener底层实现原理"></a>@RabbitListener底层实现原理</h1><p>在了解MessageConveter之前，有必要清楚spring底层消息处理机制，此处以最常用的<code>@RabbitListener</code>为例。</p>
<p>通过注解<code>@RabbitListener</code>声明一个消费者时，底层由<code>MessagingMessageListenerAdapter</code>的<code>onMessage()</code>负责处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message amqpMessage, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    org.springframework.messaging.Message&lt;?&gt; message = </span><br><span class="line"><span class="number">4</span>        <span class="keyword">this</span>.toMessagingMessage(amqpMessage);    </span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">6</span>    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;        </span><br><span class="line"><span class="number">7</span>        <span class="keyword">this</span>.logger.debug(<span class="string">"Processing ["</span> + message + <span class="string">"]"</span>);    </span><br><span class="line"><span class="number">8</span>    &#125;</span><br><span class="line"><span class="number">9</span>    </span><br><span class="line"><span class="number">10</span>    <span class="keyword">try</span> &#123;        </span><br><span class="line"><span class="number">11</span>        Object result = <span class="keyword">this</span>.invokeHandler(amqpMessage, channel, message);        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">13</span>            <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);        </span><br><span class="line"><span class="number">14</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">15</span>            <span class="keyword">this</span>.logger.trace(<span class="string">"No result object given - no result to handle"</span>);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException var7) &#123;       </span><br><span class="line"><span class="number">18</span>        ListenerExecutionFailedException e = var7;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">try</span> &#123;               </span><br><span class="line"><span class="number">21</span>                Object result = <span class="keyword">this</span>.errorHandler.handleError(amqpMessage, message, e); <span class="number">22</span>               </span><br><span class="line"><span class="number">23</span>                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;                    </span><br><span class="line"><span class="number">24</span>                    <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);           <span class="number">25</span>  </span><br><span class="line"><span class="number">26</span>                &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line"><span class="number">27</span>                    <span class="keyword">this</span>.logger.trace(<span class="string">"Error handler returned no result"</span>);             <span class="number">28</span>  </span><br><span class="line"><span class="number">29</span>                &#125;            </span><br><span class="line"><span class="number">30</span>            &#125; <span class="keyword">catch</span> (Exception var6) &#123;                </span><br><span class="line"><span class="number">31</span>                <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var6, var6);         <span class="number">32</span>  </span><br><span class="line"><span class="number">33</span>            &#125;        </span><br><span class="line"><span class="number">34</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">35</span>            <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var7.getCause(), var7);   <span class="number">36</span>     </span><br><span class="line"><span class="number">37</span>        &#125;    </span><br><span class="line"><span class="number">38</span>    &#125;</span><br><span class="line"><span class="number">39</span> &#125;</span><br></pre></td></tr></table></figure>

<p>3~4行，通过<code>toMessagingMessage()</code>将spring AMQP的Message转换为spring-messaging的Message。<code>this.getMessagingMessageConverter</code>是一个内部类的实例，内部类继承了<code>MessagingMessageConverter</code>，最终调用的是<code>MessagingMessageConverter</code>的<code>fromMessage</code>。完成Spring AMQP Message至spring-messaging Message的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> org.springframework.messaging.Message&lt;?&gt; toMessagingMessage(Message amqpMessage) &#123;    </span><br><span class="line">    <span class="keyword">return</span> (org.springframework.messaging.Message)<span class="keyword">this</span></span><br><span class="line">        .getMessagingMessageConverter()</span><br><span class="line">        .fromMessage(amqpMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fromMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        Map&lt;String, Object&gt; mappedHeaders = </span><br><span class="line">            <span class="keyword">this</span>.headerMapper.toHeaders(message.getMessageProperties()); </span><br><span class="line">        </span><br><span class="line">        Object convertedObject = <span class="keyword">this</span>.extractPayload(message);  </span><br><span class="line">        </span><br><span class="line">        MessageBuilder&lt;Object&gt; builder = convertedObject <span class="keyword">instanceof</span> </span><br><span class="line">            org.springframework.messaging.Message ? </span><br><span class="line">       MessageBuilder.fromMessage((org.springframework.messaging.Message)convertedObject) </span><br><span class="line">            : MessageBuilder.withPayload(convertedObject);        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11行通过反射处理消息，调用的是<code>HandlerAdapter</code>中的<code>invoke()</code>，为了简便，把这些调用全部放在了同一个代码块中，一般地，使用<code>@RabbitListener</code>时不会自定义<code>invokHandler</code>，所以调用的是代理的反射方法：<code>delegatingHandler.invoke()</code></p>
<p>再继续关注下<code>getMethodArgumentValues</code>，包含了两部分，一部分是预设参数转换，如：<code>Message</code>、<code>Channel</code>，这个也是最开始传入Spring AMQP的<code>Message</code>的原因，它的作用就是作为预设参数，另一部分是Listener中消息处理的其他自定义参数，如@Payload注解、@Headers注解等声明的参数，<code>args[i] == null</code>时，抛出<code>MethodArgumentResolutionException</code>异常，这就是1.3中异常抛出的地方，参数为空。该异常会一直向上抛，直至17行被捕获，如果在Listener容器中注册了<code>errorHandler</code>，调用<code>errorHandler</code>处理异常。</p>
<p>还有一点值得注意的是：在整个过程中，真正作为消息载体的就是<code>spring-messaging.Message</code>而不是Spring AMQP的`Message。因此，<strong>消息处理的过程实际如下：</strong></p>
<p><strong>调用RabbitMQ JAVA API接收消息并封装为<code>Spring AMQP Message</code>，在消息处理onMessage中调用<code>toMessagingMessage(Message amqpMessage)</code>将消息转换至<code>spring-messaging.Message</code>,通过反射处理消息。</strong></p>
<p><strong>因此，消息转换实际上包含了两个过程，一个是消息的反序列化并封装为<code>Spring AMQP Message</code>，另一个是<code>Spring AMQP Message</code>与<code>spring-messaging.Message</code>之间的转换。</strong>后文中所指的消息转换如果不加特别说明，均指第一个转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeHandler</span><span class="params">(Message amqpMessage, Channel channel, org.springframework.messaging.Message&lt;?&gt; message)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMethod.invoke(message, <span class="keyword">new</span> Object[]&#123;amqpMessage, channel&#125;);   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException var5) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">            ListenerExecutionFailedException(<span class="keyword">this</span>.createMessagingErrorMessage(<span class="string">"Listener         	  method could not be invoked with the incoming message"</span>,                                   message.getPayload()),             </span><br><span class="line">            var5, amqpMessage);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception var6) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">"Listener method '"</span> +                  		  <span class="keyword">this</span>.handlerMethod.getMethodAsString(message.getPayload())                               + <span class="string">"' threw exception"</span>, var6, amqpMessage);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandlerAdapter中的invoke</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.invokerHandlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokerHandlerMethod.invoke(message, providedArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.delegatingHandler.hasDefaultHandler()) &#123;</span><br><span class="line">            Object[] args = <span class="keyword">new</span> Object[providedArgs.length + <span class="number">1</span>];</span><br><span class="line">            args[<span class="number">0</span>] = message.getPayload();</span><br><span class="line">            System.arraycopy(providedArgs, <span class="number">0</span>, args, <span class="number">1</span>, providedArgs.length);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, providedArgs);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegatingHandler.invoke()</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;? extends Object&gt; payloadClass = message.getPayload().getClass();</span><br><span class="line">        InvocableHandlerMethod handler = <span class="keyword">this</span>.getHandlerForPayload(payloadClass);</span><br><span class="line">        Object result = handler.invoke(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders().get(<span class="string">"amqp_replyTo"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Expression replyTo = (Expression)<span class="keyword">this</span>.handlerSendTo.get(handler);</span><br><span class="line">            <span class="keyword">if</span> (replyTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ResultHolder(result, replyTo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理完成的invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">this</span>.getMethodArgumentValues(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Invoking '"</span> + 	 	                                                 ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(), <span class="keyword">this</span>.getBeanType())</span><br><span class="line">                              + <span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = <span class="keyword">this</span>.doInvoke(args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Method ["</span> + 				    			                             ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(),<span class="keyword">this</span>.getBeanType()) </span><br><span class="line">            + <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注下getMethodArgumentValues</span></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(Message&lt;?&gt; message, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        MethodParameter[] parameters = <span class="keyword">this</span>.getMethodParameters();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            MethodParameter parameter = parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args[i] = <span class="keyword">this</span>.resolveProvidedArgument(parameter, providedArgs);<span class="comment">//预设参数的转换</span></span><br><span class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        args[i] = <span class="keyword">this</span>.argumentResolvers</span><br><span class="line">                            .resolveArgument(parameter, message);<span class="comment">// 自定义的参数的转换</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="keyword">this</span>.getArgumentResolutionErrorMessage(</span><br><span class="line">                                <span class="string">"Failed to resolve"</span>, i), var8);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> var8;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentResolutionException(</span><br><span class="line">                        message, parameter, <span class="keyword">this</span>.getArgumentResolutionErrorMessage( </span><br><span class="line">                                            <span class="string">"No suitable resolver for"</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    <span class="keyword">return</span> args;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="已有的MessageConverter"><a href="#已有的MessageConverter" class="headerlink" title="已有的MessageConverter"></a>已有的MessageConverter</h1><p>前面提到，消息格式转换有两次，第一次转换完成序列化与反序列化的工作，被称为<code>Message Converter</code>，spring AMQP提供了默认的转换器<code>SimpleMessageConverter</code>。以反序列化为例，将Spring AMQP Message转换为字符串、序列化对象、字节数组，这次转换也是文中所指的Message Convert。反序列化源码如下：</p>
<p>第二次转换，springboot默认使用的是GenericMessageConverter。它是属于org.springframework.messaging.包下的，继承了该包下的SimpleMessageConverter（第一次转换的SimpleMessageConverter在org.springframework.amqp包下），默认情况下，不需要特别的设置。</p>
<p>spring-messaging的<code>MessageConverter</code>是所有消息转换器（无论是<code>spring-messaging</code>还是spring AMQP`）最底层的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.messaging.converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;   </span><br><span class="line">    <span class="meta">@Nullable</span>    </span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message&lt;?&gt; var1, Class&lt;?&gt; var2)</span></span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span>    Message&lt;?&gt; toMessage(Object var1, <span class="meta">@Nullable</span> MessageHeaders var2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleMessageConverter"><a href="#SimpleMessageConverter" class="headerlink" title="SimpleMessageConverter"></a>SimpleMessageConverter</h2><p>spring AMQP的<code>SimpleMessageConverter</code>实现了<code>MessageConverter</code>接口（最底层），是默认的消息转换器。在未给<code>RabbitTemplate</code>配置message conveter时，将会调用<code>SimpleMessageConverter</code>的<code>fromMessage</code>和<code>createMessage</code>处理消息，从源码可以看出，支持三种类型：字符串、序列化java对象，字节数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.support.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamClass;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.utils.SerializationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.remoting.rmi.CodebaseAwareObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMessageConverter</span> <span class="keyword">extends</span> <span class="title">WhiteListDeserializingMessageConverter</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CHARSET = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String defaultCharset = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> String codebaseUrl;    </span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageConverter</span><span class="params">()</span> </span>&#123;    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader beanClassLoader)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.beanClassLoader = beanClassLoader;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCodebaseUrl</span><span class="params">(String codebaseUrl)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.codebaseUrl = codebaseUrl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultCharset</span><span class="params">(String defaultCharset)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.defaultCharset = defaultCharset != <span class="keyword">null</span> ? defaultCharset : <span class="string">"UTF-8"</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123; </span><br><span class="line">        Object content = <span class="keyword">null</span>;        </span><br><span class="line">        MessageProperties properties = message.getMessageProperties();        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            String contentType = properties.getContentType();            </span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentType.startsWith(<span class="string">"text"</span>)) &#123;                </span><br><span class="line">                String encoding = properties.getContentEncoding();                </span><br><span class="line">                <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    encoding = <span class="keyword">this</span>.defaultCharset;                </span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    content = <span class="keyword">new</span> String(message.getBody(), encoding);                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var8) &#123;                    </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert text-based                                                            Message content"</span>, var8);         </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType != <span class="keyword">null</span> </span><br><span class="line">                       &amp;&amp; contentType.equals(<span class="string">"application/x-java-serialized-object"</span>)) &#123;                </span><br><span class="line">              		<span class="keyword">try</span> &#123;                    </span><br><span class="line">                        content = SerializationUtils</span><br><span class="line">                            .deserialize(<span class="keyword">this</span>.createObjectInputStream(</span><br><span class="line">                       <span class="keyword">new</span> ByteArrayInputStream(message.getBody()),<span class="keyword">this</span>.codebaseUrl));                &#125; <span class="keyword">catch</span> (IllegalArgumentException                                                                 | IllegalStateException                                                                   | IOException var7) &#123;                    </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert                                                           serialized Message content"</span>, var7);       </span><br><span class="line">                    &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            content = message.getBody();        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> content;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Message <span class="title">createMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span> </span></span><br><span class="line"><span class="function">                                                    <span class="keyword">throws</span> MessageConversionException </span>&#123;        </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;            </span><br><span class="line">            bytes = (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])object);            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/octet-stream"</span>);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = ((String)object).getBytes(<span class="keyword">this</span>.defaultCharset);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var6) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to Message                                                             content"</span>, var6);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"text/plain"</span>);           </span><br><span class="line">            messageProperties.setContentEncoding(<span class="keyword">this</span>.defaultCharset);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Serializable) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = SerializationUtils.serialize(object);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to serialized                                                          Message content"</span>, var5);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/x-java-serialized-object"</span>);        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            messageProperties.setContentLength((<span class="keyword">long</span>)bytes.length);            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(bytes, messageProperties);        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" only                            supports String, byte[] and Serializable payloads, received: "</span> + </span><br><span class="line">                                               object.getClass().getName());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">createObjectInputStream</span><span class="params">(InputStream is, String </span></span></span><br><span class="line"><span class="function"><span class="params">                                                        codebaseUrl)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CodebaseAwareObjectInputStream(is, <span class="keyword">this</span>.beanClassLoader, codebaseUrl) </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass classDesc) <span class="keyword">throws</span> </span><br><span class="line">                IOException, ClassNotFoundException &#123;                </span><br><span class="line">                Class&lt;?&gt; clazz = <span class="keyword">super</span>.resolveClass(classDesc);                </span><br><span class="line">                SimpleMessageConverter.<span class="keyword">this</span>.checkWhiteList(clazz);                </span><br><span class="line">                <span class="keyword">return</span> clazz;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SerializerMessageConverter"><a href="#SerializerMessageConverter" class="headerlink" title="SerializerMessageConverter"></a>SerializerMessageConverter</h2><p>与<code>SimpleMessageConverter</code>类似，唯一不同的是，多了一个属性用来自定义序列化与反序列化规则。</p>
<h2 id="Jackson2JsonMessageConverter"><a href="#Jackson2JsonMessageConverter" class="headerlink" title="Jackson2JsonMessageConverter"></a>Jackson2JsonMessageConverter</h2><p>消息载体是网络字节序时，使用默认的<code>SimpleMessageConverter</code>就足够了，但是消息载体为java序列化对象<code>application/x-java-serialized-object</code>时，不利于跨语言和跨平台，更推荐使用JSON作为消息的载体，<code>Jackson2JsonMessageConverter</code>负责JSON和java bean之间转换。使用时将<code>jsonConverter</code>注入<code>rabbitTemplate</code>实例中,替换<code>SimpleMessageConverter</code>。在替换后，收发消息可以直接发送消息Object的实例，大大得简化了开发。</p>
<p><strong>注意事项：</strong></p>
<p>使用时，需要生产者额外在消息头中添加一个字段<code>”__ TypeId __ “</code>用于注明该消息映射的domain对象，在下方的示例中，头信息中的字段<code>&quot;__ TypeId __&quot;</code>分别<code>&quot;foo&quot;</code>和<code>”bar“</code>如果生产者未注明，可以为classMapper设置默认值映射domain对象，例如：<code>classMapper.setDefaultType(MyMessage.class)</code>。</p>
<p>需要生产者在消息头注明contentType为<code>application/json或text/x-json</code> 或者生产者也使用 <code>Jackson2JsonMessageConverter</code>，它会自动在消息头中声明contentType。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    <span class="keyword">return</span> jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultClassMapper <span class="title">classMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultClassMapper classMapper = <span class="keyword">new</span> DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(<span class="string">"foo"</span>, Foo.class);</span><br><span class="line">    idClassMapping.put(<span class="string">"bar"</span>, Bar.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    <span class="keyword">return</span> classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentTypeDelegatingMessageConverter"><a href="#ContentTypeDelegatingMessageConverter" class="headerlink" title="ContentTypeDelegatingMessageConverter"></a>ContentTypeDelegatingMessageConverter</h2><p>顾名思义，<code>ContentTypeDelegatingMessageConverter</code>是一个根据消息头中<code>content-Type</code>动态选择<code>MessageConverter</code>的Message Converter。当<code>content-Type</code>为空或根据<code>content-Type</code>匹配不到<code>MessageConverter</code>时，将Message Convert的任务委托给<code>SimpleMessageConverter</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"contentTypeConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ContentTypeDelegatingMessageConverter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"delegates"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/json"</span> value-ref=<span class="string">"jsonMessageConverter"</span> /&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/xml"</span> value-ref=<span class="string">"xmlMessageConverter"</span> /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MarshallingMessageConverter"><a href="#MarshallingMessageConverter" class="headerlink" title="MarshallingMessageConverter"></a>MarshallingMessageConverter</h2><p>负责Spring的Object与XML之间的转换。</p>
<h1 id="为默认的Message-Converter设置反序列化权限"><a href="#为默认的Message-Converter设置反序列化权限" class="headerlink" title="为默认的Message Converter设置反序列化权限"></a>为默认的Message Converter设置反序列化权限</h1><p>在处理 <code>content-type</code> 为<code>application/x-java-serialized-object</code>的java序列化对象时，默认会扫描所有的packages/classes，为了提高安全性，可以设置白名单，所有的Message Converter都有一个属性whiteListPatterns，示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleMessageConverter messageConverter = <span class="keyword">new</span> SimpleMessageConverter();List&lt;String&gt; </span><br><span class="line"></span><br><span class="line">myWhiteList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"safe.*"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"unstable.recent.SafeClass"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"*.MySafeClass"</span>);</span><br><span class="line"></span><br><span class="line">messageConverter.setWhiteListPatterns(myWhiteList);</span><br></pre></td></tr></table></figure>

<p>注意：该属性仅在<code>Message Converter</code>使用<code>DefaultDeserializer</code>有效，即不要主动去配置<code>DefaultDeserializer</code>。</p>
<h1 id="特殊的Conerter——MessagePropertiesConverter"><a href="#特殊的Conerter——MessagePropertiesConverter" class="headerlink" title="特殊的Conerter——MessagePropertiesConverter"></a>特殊的Conerter——MessagePropertiesConverter</h1><p>前面介绍的MessageConverter负责body的转换，MessagePropertiesConverter 负责Rabbit Client的<code>BasicProperties</code>与Spring AMQP <code>MessageProperties</code>之间的转换，它的默认实现是<code>DefaultMessagePropertiesConverter</code>，足以满足绝多数场景下的需求。部分源码如下，仅截取了构造器和属性声明，当<code>BasicProperties</code>中的某一元素长度小于等于<code>longStringLimit</code>时，转化为<code>MessageProperties</code>中的String属性，当<code>BasicProperties</code>中的某一元素长度超过<code>longStringLimit</code>时，根据<code>convertLongLongStrings</code>判断是否需要转换为LongString，如果不需要则转换为<code>DataInputStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessagePropertiesConverter</span> <span class="keyword">implements</span> <span class="title">MessagePropertiesConverter</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LONG_STRING_LIMIT = <span class="number">1024</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> longStringLimit;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> convertLongLongStrings;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1024</span>, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(longStringLimit, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> convertLongLongStrings)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.longStringLimit = longStringLimit;        </span><br><span class="line">        <span class="keyword">this</span>.convertLongLongStrings = convertLongLongStrings;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convertLongString</span><span class="params">(LongString longString, String charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (longString.length() &lt;= (<span class="keyword">long</span>)<span class="keyword">this</span>.longStringLimit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(longString.getBytes(), charset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.convertLongLongStrings ? longString.getStream() : longString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列(三)消费者/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列(三)消费者/" itemprop="url">springboot+RabbitMQ系列（三）消费者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T00:00:00+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>消息接收有两种模式，简单的模式是消费者不断地去轮询，轮询到一条就消费一条，复杂些的模式是注册一个异步Listener，由容器负责接收消息并选择对应的Listener处理消息。</em></p>
<h1 id="轮询模式消费者"><a href="#轮询模式消费者" class="headerlink" title="轮询模式消费者"></a>轮询模式消费者</h1><p>在<code>springboot-amqp</code>中，可使用<code>AmqpTemplate（rabbitTemplate）</code>实现轮询模式接收消息，默认是阻塞的，有消息时就拉去消息，没有消息时，立刻返回null。</p>
<p>从springboot1.5版本以后，可以设置单次轮8询的超时时间，即消费者接收消息的阻塞时间，超时时间设置为负值，意味着无限期阻塞。并发量高时，建议使用异步Listener或将超时时间设为0.</p>
<p>如果需要转换消息格式，需要预先为AmpqTemplate设置<code>MessageConverter</code>，然后调用<code>receiveAndConvert（）</code>方法接收消息。</p>
<p>如果需要Replay，可以在调用<code>amqpTemplate.receiveAndReply()</code>接口时传入<code>ReceiveAndReplyCallBack</code>。</p>
<h1 id="异步消费者"><a href="#异步消费者" class="headerlink" title="异步消费者"></a>异步消费者</h1><p> 异步消费者中有一个预取消息（prefetch）的概念，即一个消费者预取一定数目的消息，这可能会导致多消费者情况下其他消费者利用率不足。springboot 2.0之前，预取消息默认值是1，spring boot 2.0以后，默认值为250, 预取值的设置取决于你的业务，要尽可能保证所有消费者的高效运行从而提升吞吐量。比如：</p>
<ol>
<li>当单条消息体很大，消息处理的又比较慢时，预取值如果设置的过大，将导致客户端内存占用率飙升。</li>
<li>如果严格的要求执行顺序时，建议预取值设置为1 </li>
<li>在消息吞吐量不高、消费者又多时，预取值设置的过大会导致消费者利用率不足。</li>
<li>在手动确认的模式下，预取值应该设置为1，如果prefech不为1，basicAck是异步的操作，如果出现异常时，消费者会继续处理其他预取消息，但是不会ack（批量成功时才会ack），因此，其他的消息处于unack的状态，其他的消费者会重新获取该消息，消息会出现重复消费的情况。</li>
</ol>
<h2 id="Message-Consuming-callback"><a href="#Message-Consuming-callback" class="headerlink" title="Message Consuming callback"></a>Message Consuming callback</h2><p>异步消费是通过回调实现的，消息的消费逻辑在回调方法onMessage()中实现，springboot AMQP提供了两个回调接口，MessageListener、ChannelAwareMessageListener，究竟用哪个取决于你是否需要获取channel信息，比如手动ack时必须要有channel才可以。</p>
<h2 id="MessageListenerAdapter"><a href="#MessageListenerAdapter" class="headerlink" title="MessageListenerAdapter"></a>MessageListenerAdapter</h2><p>接口回调已经可以实现消息的消费了，这还不够灵活，如果业务需要动态的指定queue或tag对应哪个methodName时，可以继承MessageListenerAdapter。它包含了下面的构造器，使用该构造器时，与前面提到的接口回调本质上是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageListenerAdapter</span><span class="params">(Object delegate)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.queueOrTagToMethodName = <span class="keyword">new</span> HashMap();    </span><br><span class="line">    <span class="keyword">this</span>.defaultListenerMethod = <span class="string">"handleMessage"</span>;</span><br><span class="line">    <span class="keyword">this</span>.doSetDelegate(delegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delegate（代理）即自定义的消费者bean，它必须是ChannelAwareMessageListener或MessageListener的实例，否则，它不会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object delegate = <span class="keyword">this</span>.getDelegate();</span><br><span class="line"><span class="keyword">if</span> (delegate != <span class="keyword">this</span>) &#123;    </span><br><span class="line">	<span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> ChannelAwareMessageListener) &#123;        </span><br><span class="line">		<span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;            	 												 			((ChannelAwareMessageListener)delegate).onMessage(message, channel);                     <span class="keyword">return</span>;        </span><br><span class="line">		&#125;       </span><br><span class="line">        <span class="keyword">if</span> (!(delegate <span class="keyword">instanceof</span> MessageListener)) &#123;           </span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">"MessageListenerAdapter cannot handle a ChannelAwareMessageListener delegate if it hasn't been invoked with a Channel itself"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> MessageListener) &#123;        	  					 							((MessageListener)delegate).onMessage(message);        </span><br><span class="line">     			<span class="keyword">return</span>;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态的指定消息处理method由下面两个接口实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultListenerMethod(String defaultListenerMethod) &#123;</span><br><span class="line">    this.defaultListenerMethod = defaultListenerMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setQueueOrTagToMethodName(Map&lt;String, String&gt; queueOrTagToMethodName) &#123;</span><br><span class="line">    this.queueOrTagToMethodName.putAll(queueOrTagToMethodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们在getListenerMethodName中被调用，如果你没有定义queueOrTagToMethodName，那么将会调用你设置的defaultListenerMethod，如果你都没有设置，那么默认值是“handleMessage”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws Exception &#123;    </span><br><span class="line">	if (this.queueOrTagToMethodName.size() &gt; 0) &#123;        </span><br><span class="line">		MessageProperties props = originalMessage.getMessageProperties();        </span><br><span class="line">		String methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerQueue());        </span><br><span class="line">		if (methodName == null) &#123;            </span><br><span class="line">			methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerTag());        &#125;        </span><br><span class="line">		if (methodName != null) &#123;            </span><br><span class="line">			return methodName;       </span><br><span class="line">        &#125;    </span><br><span class="line">      &#125;    </span><br><span class="line">     </span><br><span class="line">     return this.getDefaultListenerMethod();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器完成了回调"><a href="#容器完成了回调" class="headerlink" title="容器完成了回调"></a>容器完成了回调</h2><p>前面介绍了如何实现异步消费的回调接口，而真正完成回调的是容器（container），容器是有生命周期的，如启动、运行、停止，容器本质上就是桥接AMQP queue和MessageListener的实例。因此，如果想实现消费者的功能，必须为容器配置connectionFactory、队列、MessageLisener, 即告知容器：如何连接MQ服务器、成功连接后哪个队列的消息应该交给哪个消费者。</p>
<p>在springboot 2.0之前，只有一种容器：SimpleMessageListenerContainer。在springboot2.0以后，新增了一种容器：DirectMessageListenerContainer。二者的区别就是消费者的线程与RabbitMQ客户端线程是否共用，对于SimpleMessageListenerContainer，每一个消费者配置一个线程，如果为容器配置了多个队列，可能会使用同一个线程处理多个队列（消费者数量&lt;队列数）。并发性能取决于你设置的消费者的数conCurrentConsumer，它等于消费者线程数。</p>
<p>一个消息的后半生是这样的：spring-amqp负责将消息从MQ服务器传递给消费者，springboot-amqp提供了默认的容器，用来从MQ服务器接收消息，我们提供的消费者完成onMessage()的消息处理逻辑，并将它注册到容器上。</p>
<p>当消息从RabbitMQ客户端传递过来时，客户端线程通过队列将消息传递给消费线程（消息处理线程）。这是由于早期MQ客户端不支持并发传递消息，一个队列只会有一个线程传递消息，更不可能让它完成消息的处理，这个机制的设置当然是低效的，会增加线程之间切换的开销。</p>
<p>在新版本后，MQ客户端已经支持并发了，完全可以使用MQ客户端的线程完成消息的接收、处理工作，在DirectMessageListenerContainer中，不再区分客户端线程和消费线程，并发的控制由参数consumersPerQueue控制，不再使用conCurrentConsumer、maxConCurrentConsumer、txSize（事务大小，一次事务中传递txSize条消息，用来减少ack的次数，这个参数&gt;1且消息消费出现异常时，会导致同一个事务中后续的消息重复消费）。DirectMessageListenerContainer中提供了messagesPerAck，但是它不是事务，每一条消息都有一个独立的事务用来传递和确认，出现异常时，后续的消息会一直处于unack的状态，所以，不会重复消费。</p>
<h2 id="自定义容器"><a href="#自定义容器" class="headerlink" title="自定义容器"></a>自定义容器</h2><p>前面介绍了两种容器，而且springboot-amqp会提供默认地容器，如果想个性化的设置或有需要设置多种容器时，就需要考虑自定义容器了，在实际项目中，建议使用自定义容器。</p>
<p>现在以SimpleMessageListenerContainer为例介绍下容器的使用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAmqpConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setQueueName(<span class="string">"some.queue"</span>);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListener <span class="title">exampleListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"received: "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是使用@RabbitListener注解+Java Config。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"example.queue"</span>, containerFactory = <span class="string">"exampleContainer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器工厂"><a href="#容器工厂" class="headerlink" title="容器工厂"></a>容器工厂</h2><p>容器工厂专门用来配合@RabbitListener使用，前面提到，springboot为@RabbitListener提供了默认的容器，但为了个性化的设置，建议自定义容器工厂，然后在@RabbitListener中设置”containerFactory“属性。容器和容器工厂的对应如下：</p>
<ol>
<li>SimpleMessageListenerContainer   对应   SimpleRabbitListenerContainerFactory</li>
<li>DirectMessageListenerContainer    对应    DirectRabbitListenerContainerFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>（name=<span class="string">"myContainerFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> 				       					SimpleRabbitListenerContainerFactory();</span><br><span class="line">    	factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    	factory.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">    	factory.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = ”myqueue“, containerFactory = <span class="string">"myContainerFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>前文涉及的conCurrentConsumer、connectionFactory都是容器的属性，还有其他常用的属性：</p>
<p><a href="https://docs.spring.io/spring-amqp/docs/2.0.3.RELEASE/reference/html/_reference.html#containerAttributes" target="_blank" rel="noopener">Springboot2.0.3.RELEASE容器属性介绍</a></p>
<h3 id="channelTransacted"><a href="#channelTransacted" class="headerlink" title="channelTransacted"></a>channelTransacted</h3><p>是否在事务中ack（确认）所有消息。为true时表示需要确认事务中的所有消息。</p>
<h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><p>提供给Listener的外部事务管理器，是channelTransacted的补充，如果channel是事务的，它的事务会与外部事务进行同步。</p>
<h3 id="acknowledgeMode"><a href="#acknowledgeMode" class="headerlink" title="acknowledgeMode"></a>acknowledgeMode</h3><ul>
<li>NONE         配合channelTransacted=false使用，不发送ACK，MQ服务器认为所有的消息都会被确认，所以                        在RabbitMQ中称为自动ACK，但在springboot中，称为NONE ACK，视角不同导致的称谓不同。</li>
<li>MANUAL   消费者必须手动确认所有的消息，包括异常情况</li>
<li>AUTO         容器自动确认消息，除非Listener抛出容器无法自动处理的异常。该模式也是channelTransacted为true时的默认模式。追求并发时可以配合使用。</li>
</ul>
<h3 id="prefetchCount"><a href="#prefetchCount" class="headerlink" title="prefetchCount"></a>prefetchCount</h3><p>每个消费者能够持有的未ack的消息数，该值越大消息传输给消费者的速度越快。该参数越大，消息的顺序处理性越差。值得注意的是：在AcknowledgeMode.NONE模式下，该参数的设置是无效的，这是由于该模式下根本不存在ack。</p>
<h3 id="txSize"><a href="#txSize" class="headerlink" title="txSize"></a>txSize</h3><p>适用于SimpleMessageListenerContainer，该参数仅在AcknowledgeMode.AUTO模式下生效，容器在发送一次ack之前批量处理txSize条消息，这一批消息处于同一个事务中，会一直等待它们到超时时间，如果prefetchCount小于txSize，会自动将prefetchCount设置的与txSize相等。只能用于channelTransacted为true的场景下。</p>
<h3 id="messagePerAck"><a href="#messagePerAck" class="headerlink" title="messagePerAck"></a>messagePerAck</h3><p>适用于DirectMessageListenerContainer，容器在两次ack之间处理的消息数目，目的是减少向MQ服务器发送ack的次数，代价就是在出现异常时，增大重传消息的可能性，往往用在高并发场景下。在出现异常时（比如拒绝了一批消息中的某一条），则其他消息不管有没有消费完都会被ack，异常的消息被拒绝。所以它不能用在channelTransacted为true的场景。</p>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><p>自定义未捕获的异常的处理机制，默认使用ConditionalRejectingErrorHandler</p>
<h3 id="RabbitListener"><a href="#RabbitListener" class="headerlink" title="@RabbitListener"></a>@RabbitListener</h3><p>异步接收消息最简单的方式是通过注解实现，前面的@RabbitListener即是，底层是MessagingMessageListenerAdapter实现的，使用注解，不需要指定methodName，因为@RabbitListener已经注明了该方法用来接收消息。在一个类中，可以定义多个不同的Listener，如下：</p>
<p>processOrder中，使用@QueueBinding声明了队列、routingkey、exchange以及他们的绑定关系</p>
<p>processInvoice中，绑定、声明了一个匿名队列，也可以声明多个@QueueBinding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = &#123;<span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue"</span>,         </span><br><span class="line">                                                         durable = <span class="string">"true"</span>,         </span><br><span class="line">                                                         autoDelete = <span class="string">"false"</span>),         </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss"</span>)),        </span><br><span class="line">                            <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue2"</span>), </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss1"</span>))&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rcv</span><span class="params">(Message message, Channel channel)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>handleWithSimpleDeclare中，没有声明exchange，routingkey，使用默认地exchange，routingkey与队列名称相同，是direct模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"myQueue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>, ignoreDeclarationExceptions = <span class="string">"true"</span>),</span><br><span class="line">        key = <span class="string">"orderRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>),</span><br><span class="line">        key = <span class="string">"invoiceRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInvoice</span><span class="params">(Invoice invoice)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"$&#123;my.queue&#125;"</span>, durable = <span class="string">"true"</span>))</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleWithSimpleDeclare</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多个方法使用同种@RabbitListener时，可以自定义元注解（常用于广播fanout模式）,比如下面的例子，就使用了一个自动删除（默认地，如果不想自动删除，需要设置auto-delete为false）、匿名、广播模式的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"metaFanout"</span>, type = ExchangeTypes.FANOUT)))</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RabbitListener异常处理"><a href="#RabbitListener异常处理" class="headerlink" title="@RabbitListener异常处理"></a>@RabbitListener异常处理</h1><p>Springboot2.0版之后，@RabbitListener注解新增了errorHandler和returnException属性，默认是无配置的。自定义errorHandler，需要实现RabbitListenerErrorHander接口， 并将其配置在@RabbitListener上。第二个参数messaging.Message是Message Converter产生的，ListenerExecutionFailedException是Listener抛出的。可以在自定义的handleError中处理异常，或抛出其他异常至容器，默认地，如果没有自定义errorHandler，异常将会抛至容器中。由容器的errorHandler处理，见后文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RabbitListenerErrorHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">handleError</span><span class="params">(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt;                     message,ListenerExecutionFailedException exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>returnException属性为“true”时，表示异常需要通知到生产者，一般地，不需要设置该属性，毕竟引入MQ的目的是解耦。</p>
<h2 id="容器的errorHandler"><a href="#容器的errorHandler" class="headerlink" title="容器的errorHandler"></a>容器的errorHandler</h2><p>前面提到，没有自定义errorHandler时，异常会抛至容器默认异常处理器ConditionalRejectingErrorHandler，包含两个构造器，一个无参，一个含参，通过含参构造器可以自定义异常处理策略。若使用的无参构造器，则默认使用内部类DefaultExceptionStrategy中定义的异常处理策略。</p>
<p>ConditionalRejectingErrorHandler源码如下，11行是处理异常的接口，在13行中，异常如果不是AmqpRejectAndDontRequeueException而且是致命异常时，会抛出AmqpRejectAndDontRequeueException，致命异常的判断在37行，首先判断异常产生的原因：</p>
<p>MessagingException位于spring-messiging包下的，是异常MessageConversionException、MethodArgumentResolutionException、MessageDeliveryException、MessageHandlingException、DestinationResolutionException、MethodArgumentNotValidException、MethodArgumentTypeMismatchException、MissingSessionUserException的父类。</p>
<p>ListenerExecutionFailedException是所有异常被抛出时的最上层栈信息，所有异常都以该形式抛出。</p>
<p>39~42行是一个for循环，遍历异常产生的栈信息一层层解析异常产生的原因，一旦有MessageConversionException、MethodArgumentResolutionException就跳出循环，处理该异常，如果遍历完整个循环都没有出现，则处理最后一个异常（42行cause = cause.getCause()）。<strong>因此，如果有多个异常均需要处理时，建议重写isFatal方法</strong>。</p>
<p>59-67行判断cause是否致命，有六种：</p>
<ul>
<li>Spring AMQP的MessageConversionException异常</li>
<li>spring-messaging的MessageConversionException异常</li>
<li>spring-messaging的MethodArgumentResolutionException异常</li>
<li>NoSuchMethodException异常</li>
<li>ClassCastException异常</li>
<li>自定义的异常isUserCauseFatal</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.rabbit.listener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// omit the package import for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRejectingErrorHandler</span> <span class="keyword">implements</span> <span class="title">ErrorHandler</span> </span>&#123;    </span><br><span class="line"><span class="number">2</span>    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());    </span><br><span class="line"><span class="number">3</span>    <span class="keyword">private</span> <span class="keyword">final</span> FatalExceptionStrategy exceptionStrategy;    </span><br><span class="line"><span class="number">4</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">5</span>        <span class="keyword">this</span>.exceptionStrategy = <span class="keyword">new</span> </span><br><span class="line"><span class="number">6</span>            ConditionalRejectingErrorHandler.DefaultExceptionStrategy();    </span><br><span class="line"><span class="number">7</span>    &#125;    </span><br><span class="line"><span class="number">8</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">(FatalExceptionStrategy exceptionStrategy)</span> </span>&#123; <span class="number">9</span>       		<span class="keyword">this</span>.exceptionStrategy = exceptionStrategy;                               <span class="number">10</span>          &#125;    </span><br><span class="line"><span class="number">11</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">this</span>.log(t);        </span><br><span class="line"><span class="number">13</span>        <span class="keyword">if</span> (!<span class="keyword">this</span>.causeChainContainsARADRE(t) &amp;&amp; <span class="keyword">this</span>.exceptionStrategy.isFatal(t)) &#123;   <span class="number">14</span>              <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"Error Handler converted     15                       exception to fatal"</span>, t);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125;    </span><br><span class="line"><span class="number">18</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">this</span>.logger.warn(<span class="string">"Execution of Rabbit message listener failed."</span>, t);       </span><br><span class="line"><span class="number">21</span>        &#125;    </span><br><span class="line"><span class="number">22</span>    &#125;    </span><br><span class="line"><span class="number">23</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">causeChainContainsARADRE</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">24</span>        <span class="keyword">for</span>(Throwable cause = t.getCause(); cause != <span class="keyword">null</span>; cause = cause.getCause()) &#123; <span class="number">25</span>               <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> AmqpRejectAndDontRequeueException) &#123;               </span><br><span class="line"><span class="number">26</span>                	<span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">27</span>             &#125;        </span><br><span class="line"><span class="number">28</span>        &#125;        </span><br><span class="line"><span class="number">29</span>        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line"><span class="number">30</span>    &#125;    </span><br><span class="line"><span class="number">31</span>    </span><br><span class="line"><span class="number">32</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExceptionStrategy</span> <span class="keyword">implements</span> <span class="title">FatalExceptionStrategy</span> </span>&#123;   <span class="number">33</span>     </span><br><span class="line"><span class="number">34</span>        <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());        </span><br><span class="line"><span class="number">35</span>        <span class="function"><span class="keyword">public</span> <span class="title">DefaultExceptionStrategy</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">36</span>        &#125;        </span><br><span class="line"><span class="number">37</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFatal</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line"><span class="number">38</span>            Throwable cause;            </span><br><span class="line"><span class="number">39</span>            <span class="keyword">for</span>(cause = t.getCause(); cause <span class="keyword">instanceof</span> MessagingException </span><br><span class="line"><span class="number">40</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MessageConversionException) </span><br><span class="line"><span class="number">41</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MethodArgumentResolutionException); </span><br><span class="line"><span class="number">42</span>                cause = cause.getCause()) &#123;                </span><br><span class="line"><span class="number">43</span>                ;            </span><br><span class="line"><span class="number">44</span>            &#125;            </span><br><span class="line"><span class="number">45</span>            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ListenerExecutionFailedException </span><br><span class="line"><span class="number">46</span>                &amp;&amp; <span class="keyword">this</span>.isCauseFatal(cause)) &#123;                </span><br><span class="line"><span class="number">47</span>                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;                    </span><br><span class="line"><span class="number">48</span>                    <span class="keyword">this</span>.logger.warn(<span class="string">"Fatal message conversion error; message rejected; 49                      it will be dropped or routed to a dead letter exchange, if so     50                        configured: "</span> + ((ListenerExecutionFailedException)t)</span><br><span class="line"><span class="number">51</span>                                     .getFailedMessage());                </span><br><span class="line"><span class="number">52</span>                &#125;                </span><br><span class="line"><span class="number">53</span>                <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">54</span>            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line"><span class="number">55</span>                <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line"><span class="number">56</span>            &#125;        </span><br><span class="line"><span class="number">57</span>        &#125;        </span><br><span class="line"><span class="number">58</span>                                                                                     </span><br><span class="line"><span class="number">59</span>		<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">60</span>            <span class="keyword">return</span> cause <span class="keyword">instanceof</span> </span><br><span class="line"><span class="number">61</span>                org.springframework.amqp.support.converter.MessageConversionException </span><br><span class="line"><span class="number">62</span>                || cause <span class="keyword">instanceof</span> MessageConversionException </span><br><span class="line"><span class="number">63</span>                || cause <span class="keyword">instanceof</span> MethodArgumentResolutionException </span><br><span class="line"><span class="number">64</span>                || cause <span class="keyword">instanceof</span> NoSuchMethodException </span><br><span class="line"><span class="number">65</span>                || cause <span class="keyword">instanceof</span> ClassCastException </span><br><span class="line"><span class="number">66</span>                || <span class="keyword">this</span>.isUserCauseFatal(cause);        </span><br><span class="line"><span class="number">67</span>        &#125;        </span><br><span class="line"><span class="number">68</span>        </span><br><span class="line"><span class="number">69</span>      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isUserCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">70</span>            <span class="keyword">return</span> <span class="keyword">false</span>;        </span><br><span class="line"><span class="number">71</span>      &#125;    </span><br><span class="line"><span class="number">72</span>   &#125;</span><br><span class="line"><span class="number">73</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以选择完全自定义异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listenerContainerFactory.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line">        <span class="comment">// do something handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>对于消息的异常处理springboot2.0.3还不够完善。比如使用的@RabbitListener、AcknowledgeMent.MANUAL发送一条空的消息，这条消息无法到达自定义的onMessage()方法，提前抛出了异常，若尝试通过RabbitListenerErrorHandler处理异常，并按照下面的方式自定义了一个errorHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"myErrorHandler"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerErrorHandler <span class="title">rabbitListenerErrorHandler</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerErrorHandler() &#123;       </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleError</span><span class="params">(Message message, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  org.springframework.messaging.Message&lt;?&gt; message1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ListenerExecutionFailedException e)</span> <span class="keyword">throws</span> Exception </span>&#123;            <span class="comment">// 如果消息是空的，这条消息不再归队            </span></span><br><span class="line">            <span class="keyword">if</span> (message.getBody().length == <span class="number">0</span>) &#123;                </span><br><span class="line">                Channel channel = message1.getHeaders().get(AmqpHeaders.CHANNEL, </span><br><span class="line">                                                            Channel.class);</span><br><span class="line">                logger.error(<span class="string">"rcv error"</span>);</span><br><span class="line">                Channel channel1 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line">                Channel channel2 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line"></span><br><span class="line">                logger.error(<span class="string">"channel1=&#123;&#125;"</span>, channel);</span><br><span class="line">                logger.error(<span class="string">"channel2=&#123;&#125;"</span>, channel2);</span><br><span class="line">                <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.error（”channel <span class="keyword">null</span>，can not send ack...“）</span><br><span class="line">                    <span class="keyword">throw</span> e;                </span><br><span class="line">                &#125;                </span><br><span class="line">                channel.basicReject(message1.getHeaders().get(AmqpHeaders.DELIVERY_TAG, </span><br><span class="line">                                                              Long.class), <span class="keyword">false</span>);              </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"msg format error"</span>);         </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">throw</span> e;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送10条empty的消息，打印了10次：channel null，can not send ack…</p>
<p>这10条消息一直处于unack的状态，消息并没有被reject，而是一直处于unack的状态,但是该消息是无意义的,不应该再重新入队.</p>
<p>原因：<br>springboot ListenerContainer负责传递消息给消费者，容器通过反射调用自定义的Listener并处理消息时出现参数错误异常，message转byte异常报错。<br>由于方法参数反射错误，无法调用到onMessage方法，又采用的手动确认的方式，导致没办法通过channel.basicReject拒绝该消息，所以这条消息会一直处于unack的状态。</p>
<p>解决的方法有四种：<br>1、升级springboot至2.1.6版本，在Listener容器中注册RabbitListenerErrorHandler，该版本中，可以通过org.springframework.messaging.Message获取channel信息。通过channel拒绝该消息。在之前的版本中，获取到的channel都是null(如代码所示，channel、channel1、channel2均为null，说明spring没有将channel信息封装在org.springframework.messaging.Message)，无法给MQ服务器发送ACK。<br>2、修改onMessage()的参数，使用Message类型作为消息的载体，不再使用byte、string等其他类型，定义MessageConverter或使用默认的MessageConverter实现消息格式转换。<br>3、使用springboot的Acknowledge.AUTO模式，该模式下Listener容器会自动发送ACK给MQ服务器</p>
<p>4、自定义MessageConveter</p>
<p>最后使用了方法2，springboot升级会带来兼容性的问题，比如数据库驱动、数据库版本等，方法3中交给容器自动确认更适合高并发设置多个消费者同时消费1个队列、添加一些批量拉取消息、批量事务处理的场景，该场景会牺牲消息的有序性、异常时可能会有重复消费的问题。我们现在的业务场景更偏向于保证消息的可靠性，一个队列只会有一个消费者，消费一条拉取一条，消息处理的线程池也是自定义的，这样的方式更灵活稳定。所以最后否定了方法3，选用方案2</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列（二）生产者/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列（二）生产者/" itemprop="url">springboot+RabbitMQ系列（二）生产者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T00:29:29+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AMQP定义了普遍适用的消息通信框架，只规定了最底层的协议，有关协议的细节可以有多种实现，因此，Spring AMQP提供了<code>AmqpTemplate</code>作为收发消息的模板，定义了一些常用的收发消息的接口，<code>AmqpTemplate</code>是一个底层的模板，它的上层实现可以根据具体的协议细节定义其他的接口。</p>
<p>目前，Spring AMQP只有一个实现——<code>RabbitTemplate</code>。</p>
<p><code>RabbitTemplate</code>可以用来收发消息，但是一般的，<code>RabbitTemplate</code>只用来发送消息，接收消息使用<code>@RabbitListener</code>与容器工厂。这是生产者和消费者特性导致的：生产者采用阻塞的方式，与MQ服务器之间是短连接，消费者采用非阻塞，一个线程接收线程，另外的线程处理消息，与MQ服务器之间是长连接。本章介绍<code>RabbitTemplate</code>的一些属性的配置，以及如何使用<code>RabbitTemplate</code>发送消息。</p>
<h1 id="RabbitTemplate配置"><a href="#RabbitTemplate配置" class="headerlink" title="RabbitTemplate配置"></a>RabbitTemplate配置</h1><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>在MQ客户端与MQ服务器之间连接出现异常时，消息收发可能会抛出异常，为了避免频繁抛出异常，可以加入一些重试机制，在抛出异常前，重试几次，通过设置<code>RetryTemplate</code>实现消息的重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(<span class="number">500</span>);</span><br><span class="line">    backOffPolicy.setMultiplier(<span class="number">10.0</span>);</span><br><span class="line">    backOffPolicy.setMaxInterval(<span class="number">10000</span>);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者可靠投递"><a href="#生产者可靠投递" class="headerlink" title="生产者可靠投递"></a>生产者可靠投递</h2><p>生产者是异步的，无法通过返回值知道消息是否成功发送，默认的，无法路由至MQ服务器的消息会直接被丢弃，无任何异常抛出。</p>
<h3 id="ConfirmCallback"><a href="#ConfirmCallback" class="headerlink" title="ConfirmCallback"></a>ConfirmCallback</h3><p>消息发送到<code>RabbitMQ exchange</code>（消息发送至MQ服务器）后接收ack回调。消息只要被Rabbit服务器接收到就会发调用该回调。但是不能保证消息一定会投递至目标队列，为了确保投递至目标队列，需要设置<code>ReturnCallback</code></p>
<p>注意：必需把<code>CachingConnectionFactory</code>的<code>PublierConfirms</code>设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">factory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line">rabbitTemplate.setConnectionFactory(factory);</span><br><span class="line">rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">			logger.info(<span class="string">"successed send msg to MQ server &#123;&#125;"</span>, correlationDate)</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	logger.info(<span class="string">"failed send msg to MQ server caused by &#123;&#125;"</span>, cause)</span><br><span class="line">    	&#125;</span><br><span class="line">                                                                                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="ReturnCallback"><a href="#ReturnCallback" class="headerlink" title="ReturnCallback"></a>ReturnCallback</h3><p>消息发送至MQ服务器的exchange，但是无相应队列与该交换器绑定时的回调。发送失败的消息重新返回给生产者，在<code>returnedMessage</code>方法中处理失败的消息。</p>
<p>注意：必需把<code>CachingConnectionFactory</code>的<code>PublierReturns</code>设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line"></span><br><span class="line">factory.setPublisherReturns(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">rabbitTemplate.setConnectionFactory(factory);</span><br><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> i, String s, String s1, String s2)</span> </span>&#123; </span><br><span class="line">    	<span class="comment">// process message</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：为确保接收到<code>ReturnCallback</code>、<code>ConfirmCallback</code>，channel必须处于alive的状态，当<code>channelCacheSize</code>满时，spring框架默认等待5秒然后关闭channel。所以，使用<code>ReturnCallback</code>、<code>ConfirmCallback</code>时要确保<code>channelCacheSize</code>足够大，尽可能的确保channel处于alive状态。</p>
<p>(3) 消息发送的目的得是一个不存在的exchange，底层会抛出异常并关闭连接，通过addConnectionListener，实现onShutDown方法处理该异常。见2.9节。</p>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>在2.6节中，了解到为了避免connection释放出现死锁，也避免消费者因生产者阻塞而阻塞，生产者和消费者应使用独立的连接池，springboot2.0.2版本后，<code>CachingConnectionFactory</code>内部有两个连接池，一个是生产者的一个是消费者，但是要显示设置<code>usePublisherConnection</code>为ture，默认是false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>注意：如果是事务性的，此设置无效，生产者和消费者还是会共用同一个连接池。</p>
<h1 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h1><h1 id="构建消息"><a href="#构建消息" class="headerlink" title="构建消息"></a>构建消息</h1><p>可以直接发送字节数组，<code>SimpleMessageConverter</code>默认地封装消息的<code>ContenType、Hearder、MessageId</code>等，但有时，想要控制这些属性的生成规则，需要通过<code>MessageBuiler</code>和<code>MessagePropertiesBuilder</code>构建Spring AMQP <code>Message</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">    .setHeader(<span class="string">"bar"</span>, <span class="string">"baz"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(<span class="string">"foo"</span>.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h2 id="构建CorrelationData"><a href="#构建CorrelationData" class="headerlink" title="构建CorrelationData"></a>构建CorrelationData</h2><p><code>CorrelationData</code>是与消息关联的数据，比如，通过设置分布式的唯一id作为<code>CorrelationData</code>的id，即消息ID。可以实现消费端的去重的功能。它的定义如下，只有一个属性：id。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorrelationData</span> <span class="keyword">implements</span> <span class="title">Correlation</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String id;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorrelationData</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorrelationData</span><span class="params">(String id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.id = id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.id = id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CorrelationData [id="</span> + <span class="keyword">this</span>.id + <span class="string">"]"</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者设置CorrelationData</strong>：<code>RabbitTemplate</code>的<code>send()</code>方法或为<code>rabbitTemplate</code>配置<code>setCorrelationDataPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message, CorrelationData correlationData)</span> <span class="keyword">throws</span> AmqpException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者获取CorrelationData</strong>：</p>
<p>在Spring AMQP <code>Message</code>中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String id = message.getMessageProperties().getCorrelationId();</span><br></pre></td></tr></table></figure>

<h2 id="统一修改消息和CorrelationData"><a href="#统一修改消息和CorrelationData" class="headerlink" title="统一修改消息和CorrelationData"></a>统一修改消息和CorrelationData</h2><p>在消息Id自定义、消息属性统一修改、消息内容统一修改的场景下，统一的定义修改方法有利于编码和debug。<code>RabbitTemplate</code>比<code>AmqpTemplate</code>在所有send方法底层实现上都新增了关联数据<code>correlationDate</code>信息，<code>correlationDate</code>也是3.1.2中提到的消息可靠投递的支撑。</p>
<p><code>correlationDate</code>和<code>Message</code>的统一修改示例如下。可以用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">rabbitTemplate.setCorrelationDataPostProcessor(<span class="keyword">new</span> CorrelationDataPostProcessor() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorrelationData <span class="title">postProcess</span><span class="params">(Message message, CorrelationData correlationData)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="comment">// modify correlationDate   </span></span><br><span class="line">    	correlationData.setId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rabbitTemplate.setBeforePublishPostProcessors(<span class="keyword">new</span> MessagePostProcessor() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;        </span><br><span class="line">        <span class="comment">// modify message    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h1><p>消息的发送很简答，<code>RabbitTemplate</code>提供了众多接口供发送消息。主要有两大类：<code>send()、convertAndSend()</code>。如果使用是字节数组等非Message类型的参数作为消息，考虑采用<code>convertAndSend()</code>。如果使用的是构建好的Message，使用两者皆可。<code>send()</code>接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<p>如果多除调用<code>send()</code>，可以统一为<code>rabbitTemplate</code>配置<code>routingKey、exchange</code>，这样直接调用第一个方法就可以直接实现消息的发送，这种应用场景更多的在<code>rabbitTemplate</code>只对应一个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.setExchange(<span class="string">"marketData.topic"</span>);</span><br><span class="line">amqpTemplate.setRoutingKey(<span class="string">"quotes.nasdaq.FOO"</span>);</span><br><span class="line">amqpTemplate.send(<span class="keyword">new</span> Message(<span class="string">"12.34"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>

<p>使用默认的exchange(简单模式，routingKey==queuename)，发送至固定队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.send(<span class="string">"queue.helloWorld"</span>, <span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>

<p>与上面效果一样。使用默认的exchange，发送至固定队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.setRoutingKey(<span class="string">"queue.helloWorld"</span>); <span class="comment">// but we'll always send to this Queue</span></span><br><span class="line">template.send(<span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列(一)数据库连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列(一)数据库连接/" itemprop="url">springboot+RabbitMQ系列（一）数据库连接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-01T00:29:29+08:00">
                2019-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文参考了 <a href="https://docs.spring.io/spring-amqp/docs/2.0.3.RELEASE/reference/html/" target="_blank" rel="noopener">springboot官方文档</a>，主要介绍依赖springboot-amqp模块实现与RabbitMQ服务端的连接。</p>
<h1 id="ConnectionFactory"><a href="#ConnectionFactory" class="headerlink" title="ConnectionFactory"></a>ConnectionFactory</h1><p>spring AMQP默认使用<code>CachingConnectionFactory</code>创建一个应用程序共享的连接工厂，也是用途最广泛的<code>ConnectionFactory</code>构建方法，也为Junit提供了<code>SingleConnectionFactory</code>，<code>SingleConncetionFactory</code>不常用，不再赘述。</p>
<p>与AMQP通信的工作单元实际上是Channel，TCP连接可以共享。connectionFactory分为两种模式，一种是缓存channel，一种是缓存connection（同时也缓存该connection的channel）。默认是缓存channel的模式，<strong>高可用集群场景下（镜像队列）</strong>，通过负载均衡器连接至集群中不同的实例时，可以通过setCacheMode设置为缓存connection的模式。代码示例中给出了缓存connection的模式，同时也设置了<code>channelCacheSize</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CachingConnectionFactory <span class="title">buildConnFactory</span><span class="params">(String addresses, String username, String password, String vhost)</span> </span>&#123;    </span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    connectionFactory.setAddresses(addresses);    </span><br><span class="line">    connectionFactory.setUsername(username);    </span><br><span class="line">    connectionFactory.setPassword(password);    </span><br><span class="line">    connectionFactory.setVirtualHost(vhost);    </span><br><span class="line">    connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CONNECTION);      </span><br><span class="line">    connectionFactory.setConnectionCacheSize(<span class="number">10</span>);</span><br><span class="line">    connectionFactory.setChannelCacheSize(<span class="number">200</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要采用缓存Channel的模式，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CachingConnectionFactory <span class="title">buildConnFactory</span><span class="params">(String addresses, String username, String password, String vhost)</span> </span>&#123;    </span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    connectionFactory.setAddresses(addresses);    </span><br><span class="line">    connectionFactory.setUsername(username);    </span><br><span class="line">    connectionFactory.setPassword(password);    </span><br><span class="line">    connectionFactory.setVirtualHost(vhost);    </span><br><span class="line">    connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);    </span><br><span class="line">    connectionFactory.setChannelCacheSize(channelCacheSize);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在缓存connection模式下，不支持自动声明队列、exchange、binding等，rabbitmq-client默认只提供了5个线程处理connection，因此，当connection较多时，应该自定义线程池，并配置到<code>CachingConnectionFactory</code>中。自定义的线程池将会被所有connection共享，建议线程池的最大线程数设置的与预期connection数相等，因为可能存在对于大部分connection都有多个channel的情况。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = <span class="keyword">new</span> </span><br><span class="line">    ThreadPoolExecutor(corePoolSize,                            </span><br><span class="line">                       maxPoolSize, keepAliveSeconds,TimeUnit.SECONDS,        </span><br><span class="line">                       <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize),   </span><br><span class="line">                       <span class="keyword">new</span> ThreadFactory() &#123;            </span><br><span class="line">                           <span class="meta">@Override</span>            </span><br><span class="line">                           <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span></span><br><span class="line"><span class="function">                           </span>&#123;                </span><br><span class="line">                               Thread thread = <span class="keyword">new</span> Thread(r);                 </span><br><span class="line">                               thread.setName(<span class="string">"myThread"</span> + autoInt.getAndIncrement());   </span><br><span class="line">                               thread.setDaemon(<span class="keyword">false</span>);                </span><br><span class="line">                               <span class="keyword">return</span> thread;            </span><br><span class="line">                           &#125;        </span><br><span class="line">                       &#125;,        </span><br><span class="line">                       <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">connectionFactory.setExecutor(executor);</span><br></pre></td></tr></table></figure>

<h1 id="channelCacheSize"><a href="#channelCacheSize" class="headerlink" title="channelCacheSize"></a>channelCacheSize</h1><p>前面了解到，Spring AMQP通过缓存channel或connection提高吞吐量。<code>connectionFactory</code>分为两种模式，一种是缓存channel，一种是缓存connection（同时也缓存该connection的channel）。本节主要介绍<code>channelCacheSize</code>。<code>ConnectionCacheSize</code>也是类似的，不赘述。</p>
<h2 id="默认仅限制缓存的channelSize"><a href="#默认仅限制缓存的channelSize" class="headerlink" title="默认仅限制缓存的channelSize"></a>默认仅限制缓存的channelSize</h2><p>默认地，最大channelSize是没有限制的，限制的仅仅是缓存的channelSize（connection也一样），默认值是25，缓存channel的目的是减小高并发多线程环境中频繁创建销毁channel的开销，比如：在某一时刻有100个channel处于工作状态，当channel空闲后，只会缓存channelSize个channel，剩下的都会被销毁。</p>
<p>通过RabbitMQ的Web管理插件观察到channel在频繁的被创建和销毁时，应及时的提高<code>channelCacheSize</code>。建议最少要保证线程数&lt;<code>channelCacheSize</code>。可以通过压力测试，观察高峰期channel动态平衡的数量，从而决定<code>channelCacheSize</code>的大小。</p>
<h2 id="channelSize限制"><a href="#channelSize限制" class="headerlink" title="channelSize限制"></a>channelSize限制</h2><p>也可以通过<code>channelCheckoutTimeout</code>参数设置<code>connectionFactory</code>的<code>channelSize</code>限制，当该参数大于0时，表示最大的<code>channel数目</code>=<code>channelCacheSize</code>，达到<code>channelCacheSize</code>的上限后，调用<code>createChannel</code>的线程会阻塞，直至有空闲<code>channel</code>出现或阻塞时间超过<code>chanelCheckoutTimeout</code>，在超时的情况下，抛出<code>AmqpTimeoutException</code>，可以设置一些Retry的策略来处理这些异常。</p>
<h1 id="连接命名"><a href="#连接命名" class="headerlink" title="连接命名"></a>连接命名</h1><p>通过<code>ConnectionNameStrategy</code>属性设置<code>connection</code>名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setConnectionNameStrategy(<span class="keyword">new</span> ConnectionNameStrategy() &#123;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">obtainNewConnectionName</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> connectionFactory.getHost() + atomicInteger.getAndIncrement();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connectionFactory;</span><br></pre></td></tr></table></figure>

<h1 id="使用RabbitMQ-Java-API提供的connectionFactory"><a href="#使用RabbitMQ-Java-API提供的connectionFactory" class="headerlink" title="使用RabbitMQ Java API提供的connectionFactory"></a>使用RabbitMQ Java API提供的connectionFactory</h1><p>Spring AMQP也支持使用RabbitMQ Java API提供的<code>connectionFactory</code>，即Rabbit Client的<code>connectionFactory</code>，位于包<code>com.rabbitmq.client.ConnectionFactory</code>中，通过构造器参数设置在<code>CachingConnectionFactory</code>中，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<h2 id="自定义RabbitClient的属性"><a href="#自定义RabbitClient的属性" class="headerlink" title="自定义RabbitClient的属性"></a>自定义RabbitClient的属性</h2><p>上述示例为RabbitClient的<code>connectionFactory</code> —–&gt; Spring AMQP的<code>connectionFactiory</code>的转换，Spring也提供了Spring AMQP的<code>connectionFactiory</code> —–&gt; RabbitClient的<code>connectionFactory</code>的转换。</p>
<p>比如可以通过CachingConnectionFactory设置RabbitClient <code>connectionFactory</code>的属性。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="连接恢复"><a href="#连接恢复" class="headerlink" title="连接恢复"></a>连接恢复</h1><p>Rabbit Client4.0后的<code>connectionFactory</code>和Spring AMQP的·<code>connectionFactory</code>均默认提供了自动恢复连接的机制；虽然两者的自动恢复机制是兼容的，但使用构造注入<code>conncetionFactory</code>时建议关闭其中一个。</p>
<p>否则，在MQ服务器节点可用但连接尚未恢复时，出现<code>AutoRecoverConnectionNotCurrentlyOpenException</code> 异常。比如：如果在<code>RabbitTemplate</code>中配置<code>RetryTemplate</code>（Spring AMQP的手动恢复），甚至在故障转移到集群中的另一个代理时，可能抛出上述异常。</p>
<h2 id="关闭Rabbit-Client的自动恢复"><a href="#关闭Rabbit-Client的自动恢复" class="headerlink" title="关闭Rabbit Client的自动恢复"></a>关闭Rabbit Client的自动恢复</h2><p>由于Spring AMQP的自动恢复连接在计时器上恢复，因此可以使用SpringAMQP的恢复机制更快地恢复连接。</p>
<p>springboot-amqp1.7版本以后，默认关闭RabbitClient的<code>connectionFactory</code>的自动重连，<strong>但是，在通过构造参数注入RabbitClient的<code>connectionFactory</code>时，是没有办法默认关闭的，需要手动设置</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>); <span class="comment">// 显示关闭RabbitClient的自动重连</span></span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<p>一般地，关闭掉Rabbit Client的自动恢复，使用Spring AMQP可以满足绝大多数使用场景，而且框架提供的自动恢复机制已经很完善。</p>
<h1 id="SSL连接"><a href="#SSL连接" class="headerlink" title="SSL连接"></a>SSL连接</h1><p>建议通过注入RabbitMQ client <code>connectionFactory</code>的方式配置SSL连接，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">factory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">File keyFile = <span class="keyword">new</span> File(keyPath);</span><br><span class="line">File certFile = <span class="keyword">new</span> File(cerPath);</span><br><span class="line">SSLContexts sslCtx = SslContextBuilder.forServer(certFile, keyFile).build();</span><br><span class="line">factory.useSslProtocol(sslCtx);</span><br><span class="line"></span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<h1 id="避免Connection死锁"><a href="#避免Connection死锁" class="headerlink" title="避免Connection死锁"></a>避免Connection死锁</h1><p>在内存不足或MQ服务端出现异常时，可能会出现连接阻塞，对于默认的CachingConnectionFactory，MQ服务端导致连接阻塞时，客户端会主动地关闭。</p>
<p>因此，如果生产者消费者共用同一个connectionFactory，MQ服务端导致生产者客户端与消费者客户端关闭，可能死锁的情况：生产者与消费者持有相同的连接资源时，MQ服务器异常触发生产者和消费者中断与服务端的连接，可能会出现死锁。</p>
<p>为避免死锁的产生，<strong>建议对于生产者和消费者分别配置不同的connectionFactory</strong>。需要注意的是：如果生产者消费者处于同一个事物时，不建议生产者消费者配置相同的connectionFactory，因为消费者（或生产者）需要复用对方的channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"myRabbitTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">basicCloudRabbitTemplate</span><span class="params">(CachingConnectionFactory f)</span> </span>&#123;    </span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(f);   </span><br><span class="line">    rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Routing-ConnectionFactory实现多数据源收发消息"><a href="#Routing-ConnectionFactory实现多数据源收发消息" class="headerlink" title="Routing ConnectionFactory实现多数据源收发消息"></a>Routing ConnectionFactory实现多数据源收发消息</h1><p>spring AMQP提供<code>SimpleRoutingConnectionFactory负责在运行时根据查找键动态选择connectionFactory，通常，以线程的上下文作为查找键，比如地址、vHost</code>等，<code>SimpleRoutingConnectionFactory</code>继承了<code>AbstractRoutingConnectionFactory</code>，通过SimpleResourceHolder获取当前线程的查找键。示例如下：</p>
<p>首先，为RabbitTemplate配置一个以vHost作为查找键的<code>SimpleRoutingConnectionFactory</code>。key分别为<code>factory1</code>的<code>virtualHost</code>和<code>factory2</code>的<code>virtualHost</code>，当然，也可以使用addresses作为查找键。使用方式为<code>factoryMap.put(&quot;#{factory1.addresses}&quot;, factory1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SimpleRoutingConnectionFactory <span class="title">myFactory</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRoutingConnectionFactory routingFactory = <span class="keyword">new</span> SimpleRoutingConnectionFactory();    </span><br><span class="line">    CachingConnectionFactory factory1 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory1.setAddresses(<span class="string">"localhost:5672"</span>);    </span><br><span class="line">    factory1.setUsername(<span class="string">"username1"</span>);    </span><br><span class="line">    factory1.setPassword(<span class="string">"password1"</span>);    </span><br><span class="line">    factory1.setVirtualHost(<span class="string">"v1"</span>);    </span><br><span class="line">    </span><br><span class="line">    CachingConnectionFactory factory2 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory2.setAddresses(<span class="string">"202.130.1.1:5672"</span>);    </span><br><span class="line">    factory2.setUsername(<span class="string">"username2"</span>);    </span><br><span class="line">    factory2.setPassword(<span class="string">"password2"</span>);    </span><br><span class="line">    factory2.setVirtualHost(<span class="string">"v2"</span>);    </span><br><span class="line">    </span><br><span class="line">    Map&lt;Object, ConnectionFactory&gt; factoryMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);    </span><br><span class="line">  	factoryMap.put(<span class="string">"#&#123;factory1.virtualHost&#125;"</span>, factory1);    </span><br><span class="line">    factoryMap.put(<span class="string">"#&#123;factory2.virtualHost&#125;"</span>, factory2);    </span><br><span class="line">    </span><br><span class="line">    routingFactory.setTargetConnectionFactories(factoryMap);     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> routingFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"myRabbitTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">myRabbitTemplate</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();    </span><br><span class="line">    rabbitTemplate.setConnectionFactory(myFactory());        </span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法如下，SimpleResourceHolder的bind和unbind都是必须的，分别指获取当前线程查找键，释放查找键。bind有两个参数，第一个为待获取的connectFactory，第二个为key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myRabbitTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String vHost, String payload)</span> </span>&#123;</span><br><span class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</span><br><span class="line">        rabbitTemplate.convertAndSend(payload);</span><br><span class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者使用多数据源的方式略有不同</strong>，首先，配置两个不同的containerFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"myContainerFactory1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">containerFactory1</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRabbitListenerContainerFactory containerFactory1 = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();        </span><br><span class="line">    </span><br><span class="line">    CachingConnectionFactory factory1 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory1.setAddresses(<span class="string">"localhost:5672"</span>);    </span><br><span class="line">    factory1.setUsername(<span class="string">"username1"</span>);    </span><br><span class="line">    factory1.setPassword(<span class="string">"password1"</span>);    </span><br><span class="line">    factory1.setVirtualHost(<span class="string">"v1"</span>);        </span><br><span class="line">    </span><br><span class="line">    containerFactory1.setConnectionFactory(factory1);        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> containerFactory1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"myContainerFactory2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">containerFactory2</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRabbitListenerContainerFactory containerFactory2 = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();    </span><br><span class="line">   	</span><br><span class="line">    CachingConnectionFactory factory2 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory2.setAddresses(<span class="string">"host2:5672"</span>);    </span><br><span class="line">    factory2.setUsername(<span class="string">"username2"</span>);    </span><br><span class="line">    factory2.setPassword(<span class="string">"password2"</span>);    </span><br><span class="line">    factory2.setVirtualHost(<span class="string">"v2"</span>);    </span><br><span class="line">    </span><br><span class="line">    containerFactory2.setConnectionFactory(factory2);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> containerFactory2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@RabbitListener接收消息时指定containerFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"queue.test"</span>, containerFactory = <span class="string">"myContainerFactory1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg1</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"> 	String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line"> 	logger.debug(<span class="string">"rcv msg &#123;&#125;"</span>, msg);</span><br><span class="line"> 	channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"queue.test"</span>, containerFactory = <span class="string">"myContainerFactory2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg2</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"> 	String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line"> 	logger.debug(<span class="string">"rcv msg &#123;&#125;"</span>, msg);</span><br><span class="line"> 	channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集群中的连接管理"><a href="#集群中的连接管理" class="headerlink" title="集群中的连接管理"></a>集群中的连接管理</h1><p>MQ的集群根据集群中各节点队列信息区分为镜像队列和普通队列。只有队列所在节点知道该队列的所有信息，默认情况下，MQ是普通队列，队列只存活于集群中的一个节点上，称为主队列。镜像队列与普通队列的相同点是：队列的主拷贝仅存在于一个节点上（主队列，master节点）。不同点是，镜像节点在集群中的其他节点上拥有从队列的拷贝。一旦队列主节点不可用，最老的从队列自动被选举为新的主队列。</p>
<p>镜像队列的原理：在非镜像队列的集群中，信道负责将消息路由至合适的队列。当加入镜像队列后，信道除了负责将消息路按照路由绑定规则路由至合适的队列外，它也要将消息投递到镜像队列的从拷贝，在某种程度上，可以将镜像队列视为拥有一个隐藏的fanout交换器，它指示着信道将消息分发到队列的从拷贝上。</p>
<p>无论对于普通队列还是镜像队列，所要面临的问题是：主节点崩溃时，消费者该与哪个节点建立连接。</p>
<h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><p>对于普通队列，使用<code>CachingConnectionFactory</code>就足够了，它支持配置多个连接地址，当一个连接失败时，会按顺序尝试与其他地址建立连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">factory.setAddresses(<span class="string">"host1:5672, host2:5672"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="高可用队列（镜像队列）"><a href="#高可用队列（镜像队列）" class="headerlink" title="高可用队列（镜像队列）"></a>高可用队列（镜像队列）</h2><ul>
<li>消费者</li>
</ul>
<p><code>LocalizedQueueConnectionFactory</code>是Spring AMQP为<strong>消费者</strong>提供的用于高可用集群的连接工厂，使用它时，MQ服务端必须设置enable management plugin。</p>
<p>它通过MQ服务器management 插件提供的REST API 获取哪个节点是主节点，创建<code>CachingConnectionFactory</code>连接至该节点，如果连接失败，将再次调用MQ服务器management 插件提供的REST API 获取新选举的主节点。当无法获取新选举的主节点是，将通过<code>CachingConnectionFactory</code>像普通队列一样按顺序连接至MQ服务器。</p>
<p><code>LocalizedQueueConnectionFactory</code><strong>本质上是一个RoutingConnectionFactory，它的查找键是队列名。</strong></p>
<p>正是由于查找键是对列名，必需保证查找键的唯一性，消费者的<code>ContainerFactory</code>只能配置在一个队列上。</p>
<p>注意：</p>
<p>由于每次创建连接时，都要通过REST API获取连接节点，开销很大，只适用于长连接的场景（消费者），不适用短连接的场景（生产者）。</p>
<p><code>LocalizedQueueConnectionFactory</code>只适用于消费者，比如配置在<code>SimpleMessageListenerContainer</code>中，不适用于生产者（比如将<code>LocalizedQueueConnectionFactory</code>配置在<code>RabbitTemplate</code>中）。</p>
<p>示例如下：<code>LocalizedQueueConnectionFactory</code>构造方法的前三个参数 <code>addresses</code>, <code>adminUris</code> 和<code>nodes</code>都是字符串数组，<code>LocalizedQueueConnectionFactory</code>使用数组下标相同的参数构建连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitProperties props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] adminUris = &#123; <span class="string">"http://host1:15672"</span>, <span class="string">"http://host2:15672"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] nodes = &#123; <span class="string">"rabbit@host1"</span>, <span class="string">"rabbit@host2"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">defaultConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory cf = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    cf.setAddresses(<span class="keyword">this</span>.props.getAddresses());</span><br><span class="line">    cf.setUsername(<span class="keyword">this</span>.props.getUsername());</span><br><span class="line">    cf.setPassword(<span class="keyword">this</span>.props.getPassword());</span><br><span class="line">    cf.setVirtualHost(<span class="keyword">this</span>.props.getVirtualHost());</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">queueAffinityCF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Qualifier(<span class="string">"defaultConnectionFactory"</span>)</span> ConnectionFactory defaultCF) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalizedQueueConnectionFactory(defaultCF,</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(<span class="keyword">this</span>.props.getAddresses()),</span><br><span class="line">            <span class="keyword">this</span>.adminUris, <span class="keyword">this</span>.nodes,</span><br><span class="line">            <span class="keyword">this</span>.props.getVirtualHost(), <span class="keyword">this</span>.props.getUsername(), <span class="keyword">this</span>.props.getPassword(),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生产者</li>
</ul>
<p>生产者本身也不需要考虑哪个节点是主节点，对于生产者来说，队列是未知的，消息会发送至集群中所有的节点。节点会判断该消息对应的主队列是否在自己的节点上。</p>
<h1 id="连接和信道监听"><a href="#连接和信道监听" class="headerlink" title="连接和信道监听"></a>连接和信道监听</h1><p>Spring AMQP提供了connection和channel的监听器接口，通过回调实现自定义的创建和销毁监听逻辑。</p>
<h2 id="ConnectionListener"><a href="#ConnectionListener" class="headerlink" title="ConnectionListener"></a>ConnectionListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">      List&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">ConnectionListener connectionListener = <span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      connectionListeners.add(connectionListener);</span><br><span class="line"></span><br><span class="line">      factory.setConnectionListeners(connectionListeners);</span><br></pre></td></tr></table></figure>

<h2 id="ChannelListener"><a href="#ChannelListener" class="headerlink" title="ChannelListener"></a>ChannelListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">List&lt;ChannelListener&gt; channelListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ChannelListener channelListener = <span class="keyword">new</span> ChannelListener() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// do something    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// do something    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channelListeners.add(channelListener);</span><br><span class="line">List&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">factory.setChannelListeners(channelListeners);</span><br></pre></td></tr></table></figure>

<h1 id="channel关闭的日志级别控制"><a href="#channel关闭的日志级别控制" class="headerlink" title="channel关闭的日志级别控制"></a>channel关闭的日志级别控制</h1><p>当channel关闭时，<code>CachingConnectionFactory</code>的默认日志规则如下：</p>
<ul>
<li>正常的channel销毁，无log</li>
<li>队列声明失败导致的channel关闭，debug级别</li>
<li>在exclusive（独占）队列上，basic.consume因为独占使用条件而关闭channel，info级别</li>
<li>其他的channel关闭情况输出error级别log</li>
</ul>
<p>自定义log级别：为CachingConnectionFactory配置自定义的ConditionalExceptionLogger。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shipengyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shipengyang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
