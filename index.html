<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="google-site-verification" content="OLomwgvPJUusE2fSmaSFCe7mLON5KNDocZQjKQDZdp0">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="okspy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="okspy">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="okspy">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>okspy</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5c2fc5dbac76adc09ece072c66e802cd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">okspy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/java并发编程（一）线程安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java并发编程（一）线程安全/" itemprop="url">JAVA并发（一）线程安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-01T00:00:00+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>线程安全的定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者线程如何交替执行，主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类为线程安全的。</p>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性指的是一个操作可以作为一个不可分割的操作来执行。也指：对于一个线程正在使用的对象，使用过程中不会被其他线程修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">autoIncrease</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>++i或i++看上去是一个操作，但并非是原子操作，它包含了三个操作：</p>
<ul>
<li>读取i的值</li>
<li>将值加1</li>
<li>将计算结果写入i</li>
</ul>
<p>这是一个操作序列：读取 - 修改 - 写入，其结果状态依赖于之前的状态。</p>
<p>两个线程同时执行该操作会导致线程不安全，因为两个线程可能会交替的执行上述三个操作，某一个线程读取到的值可能是无效的、过时的。</p>
<p>为了保证线程安全，需要确保两个线程按照顺序依次执行上述三个操作，即线程1执行完了三个操作后，线程2才能开始执行这三个操作。</p>
<p><strong>在并发编程中，这种由于“不恰当”执行顺序而出现的不正确的结果称为：竞态条件。</strong></p>
<p>“不恰当”的执行顺序是CPU优化导致的，是客观存在、有利于提高处理速度的，这种执行顺序总是存在的。程序员能掌控的是编写线程安全的代码，使其在竞态条件下也能满足线程安全。</p>
<h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>最常见的竞态条件是：先检查后执行</p>
<p>下面的例子是一个懒加载单例类，它不是线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoadSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> LazyLoadSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> LazyLoadSingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">			singleton = <span class="keyword">new</span> LazyLoadSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程A和线程B同时执行getSingleton。A看到singleton为空，因此创建一个新的LazyLoadSingleton实例；线程B同样要判断singleton是否为空，而B判断时singleton是否为空，取决于A执行到哪一步，即不可预测的执行顺序，可能会导致线程不安全。</p>
<h2 id="避免竞态条件—复合操作"><a href="#避免竞态条件—复合操作" class="headerlink" title="避免竞态条件—复合操作"></a>避免竞态条件—复合操作</h2><p>复合操作指将前文中的<strong>自增、先检查后执行的操作分别组合成原子操作</strong>，这样就能保证线程安全。</p>
<p>在java.util.concurrent.automic包中包含了一些原子变量类，用于实现在数值和对象引用的原子状态转换。比如自增的复合操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncrease</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count.incrementAndGet();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicLong.incrementAndGet底层通过CAS实现了复合操作。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS相当于乐观锁，CAS对应了硬件指令CMPXCHG，该指令对应着”比较并交换的操作，如果一个值原来是A（预期值），修改为B，在CPU回写至内存时，会检查当前值是否为A（比较），如果为A，则将值更新为B（交换）。</p>
<p>CPU循环进行CAS操作直到成功为止。CAS虽然很高效的实现了原子性，但是CAS仍然存在三大问题：</p>
<ul>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作。</li>
</ul>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p>
<h3 id="自旋时间长开销大"><a href="#自旋时间长开销大" class="headerlink" title="自旋时间长开销大"></a>自旋时间长开销大</h3><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用：</p>
<ul>
<li>延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源。</li>
<li>避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。</li>
</ul>
<h3 id="只能保证一个共享变量原子操作"><a href="#只能保证一个共享变量原子操作" class="headerlink" title="只能保证一个共享变量原子操作"></a>只能保证一个共享变量原子操作</h3><p>对多个共享变量操作时，循环CAS就无法保证操作的原子性，有两种办法解决：</p>
<ul>
<li>用锁（下一节重点介绍）</li>
<li>把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了类AtomicReference、AtomicStampedReference（解决ABA）来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
<h1 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h1><p>加锁可以保证原子性，将多个操作复合为一组同步的操作，避免竞态条件。</p>
<p>将上述代码进行如下改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改动1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncrease</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count1 = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count2 = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> num1 = count1.incrementAndGet();</span><br><span class="line">        <span class="keyword">long</span> num2 = num1 + count2.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改动2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoIncrease</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count.incrementAndGet() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count.get() + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改动1中，方法increase中包含两个原子操作，但是increase方法的返回值num2，涉及到了多个变量：count1和count2，这两个变量之间不是独立的，而是某个变量的值会对其他变量的值进行约束。这就导致了increase整体成为了一个非原子的方法，不是线程安全的。</p>
<p><strong>总结1：多个变量彼此不是相互独立时，不是原子操作</strong>。</p>
<p>改动2中，先检查count自增后是否为为偶数，为偶数则直接返回，为奇数则加1再返回，这是典型的先检查后执行操作，increase整体是一个非原子方法，不是线程安全的。</p>
<p>一个操作是否是原子的，要看它包含的所有操作是否是</p>
<p><strong>总结2：对于先检查后执行的操作，不是原子操作</strong></p>
<p>对于改动1和改动2出现的非原子操作，JAVA提供了加锁机制，用来保证在一个原子操作中更新所有相关的状态变量，即将上述操作合并为一个整体，这种合并为一个整体是语言逻辑层面的，通过对象锁实现的，不是系统指令集层面的（CAS），锁的粒度是可以在写代码时掌控的。</p>
<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>对象锁又称内置锁、Monitor锁，每一个Java对象自带了一把看不见的锁，通过synchronized关键字使用该锁。它可以保证原子性、有序性、可见性。正是因为如此强大，容易导致滥用。</p>
<h3 id="synchronized的原理"><a href="#synchronized的原理" class="headerlink" title="synchronized的原理"></a>synchronized的原理</h3><p>synchronized的实现离不开Monitor。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。<strong>每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址）</strong>，Monitor包含了下列信息：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>owner</td>
<td>占有该Monitor的线程的唯一标识，为Null时表示没有线程占用</td>
</tr>
<tr>
<td>EntryQ</td>
<td>关联一个系统互斥量（semaphore），阻塞所有试图锁住monitor record失败的线程</td>
</tr>
<tr>
<td>RcThis</td>
<td>被阻止的线程的个数</td>
</tr>
<tr>
<td>Nest</td>
<td>计数器，用来实现重入锁，没有线程持有monitor时该值为0</td>
</tr>
<tr>
<td>HashCode</td>
<td>与monitor关联的对象的hashcode</td>
</tr>
<tr>
<td>Candidate</td>
<td>只有两个值，0表示没有需要唤醒的线程，1表示要唤醒一个继任线程来竞争锁</td>
</tr>
</tbody></table>
<p>以下面的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// do smothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码反编译后：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line">...</span><br><span class="line">monitorexit</span><br></pre></td></tr></table></figure>

<p>synchronized对应了两个指令：monitorenter、monitorexit</p>
<p>以JVM中对monitorenter的解释为例：</p>
<p>monitorenter ：</p>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:<br>• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.<br>• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.<br>• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</p>
<p>翻译一下：每个对象都关联着一个monitor，当monitor被某一个且只能被一个线程占用后，monitor就会处于锁定状态。线程执行到monitorenter后，尝试去获取与monitor关联的对象的所有权，此时，会有两种结果：</p>
<ul>
<li>如果monitor的Nest值为0，则线程会占有monitor。</li>
<li>如果monitor被占有了，通过owner进行判断是否为当前线程占有的，如果是，那么该线程重入一次，计数器Nest的值加1</li>
<li>如果monitor被其他线程占有了，当前线程阻塞，直到Nest值为0</li>
</ul>
<p><strong>总结一下：每个对象的对象头中都有一个Mark Word用于存储运行时数据，Mark Word中包含了Lock Word，Lock Word记录了Monitor的指针，Monitor中的owner字段记录了持有该Monitor的线程唯一标识，Nest字段是一个计数器，用来表示该Monitor是被持有了几次，当线程执行到montorenter指令时，会判断计数器，计数器为0时，直接持有该锁，不为0时，进一步判断owner是否为当前线程，为当前线程则将计数器加1，继续持有该锁，不为当前线程则阻塞等待至计数器为0。</strong></p>
<h3 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h3><p>下面给出synchronized的几种常用应用场景：</p>
<ul>
<li>普通方法上，锁当前实例对象</li>
<li>静态方法上，锁当前类的class对象</li>
<li>代码块，锁括号里的对象</li>
<li>继承的方法上，锁子类的实例对象，锁两次</li>
</ul>
<p>这里比较容易令人困惑的是应用在继承方法上：首先，继承的本质是让子类拥有父类对象的引用，<code>super</code>关键字就是告知JVM，子类对象需要通过父类的引用调用父类的方法，因此，调用者是子类对象，锁的也是子类对象。在下面代码示例中，进入子类的<code>paraentMethod()</code>方法时，获取一次子类对象锁，调用<code>super.paraentMethod()</code>时，又一次获取了子类的对象锁，共在子类实例对象上加了两次锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynParent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">paraentMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method paraent start..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="title">extend</span> <span class="title">SynParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">volatile</span> Object objLock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用在继承的方法上，锁子类的当前实例对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">paraentMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.paraentMethod();</span><br><span class="line">        System.out.println(<span class="string">"method paraent end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized应用在普通方法上，锁当前实例对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"method 1 start..."</span>);</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"method 1 end..."</span>);</span><br><span class="line">	&#125; </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// synchronized应用在静态方法上，锁当前类的class对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"method 2 start..."</span>);</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"method 2 end..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// synchronized应用在代码块，锁当前实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method 3 start..."</span>);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"method 3 end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// synchronized应用在代码块，锁自定义实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(objLock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method 4 start..."</span>);</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"method 4 end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM的锁优化"><a href="#JVM的锁优化" class="headerlink" title="JVM的锁优化"></a>JVM的锁优化</h3><p>以64位JVM为例，它的对象头中的Mark Word如下，分别对应了对象的四种状态，无锁、偏向锁、轻量级锁、重量级锁，此外，虚拟机还有自旋锁、锁消除、自旋自适应锁等机制，本节将会逐个介绍。</p>
<p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/concurrence/JMM%E9%94%81%E4%BC%98%E5%8C%96.png" alt="1568963278276"></p>
<p>重量级锁就是前面我们详细分析过的synchronized锁，线程需要持有与对象相关联的monitor，montior中包含了线程唯一表示、系统互斥量、计数器等信息。系统互斥量导致该锁是重量级。重量级锁不属于锁优化，所以不再单独列为一节。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>synchronized原理中已提到过，线程栈帧中有一个名为Lock Record（锁记录，又叫Lock Word）的空间，用于存储对象的Mark Word的拷贝。</p>
<p>线程尝试获取轻量级锁时，虚拟机使用CAS将对象的Mark Word更新为指向Lock Record的指针，如果此次更新成功，那么这个线程就拥有了该对象的锁。锁标志位更新为00，<strong>之所以称之为轻量级，是去除了同步使用的互斥量</strong>。</p>
<p>如果CAS操作失败，虚拟机首先检查对象的Mrak Word是否指向当前线程，如果是，那就可以直接进入同步块执行，如果对象的Mark Word没有指向当前线程，说明<strong>锁已经被其他线程抢占了</strong>，轻量级锁不再有效，膨胀为重量级锁，锁标志位变为10。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>如果说轻量级锁是在无竞争的状态下使用CAS操作去除同步使用的互斥量，那偏向锁就是在无竞争的状态下把整个同步都消除掉，连CAS操作也省去。</strong></p>
<p>对象头使用54bit存储偏好的线程ID，再使用2bit存储epoch（偏向锁获取的时间戳），当锁对象第一次被线程获取时，进入偏向模式，同时会进行一次CAS（只进行一次），把获取到该锁的线程ID记录在Mark Word中，该线程以后再进入与锁相关的同步块时，虚拟机不再执行任何同步操作，<strong>直至另外一个线程尝试获取该锁</strong>。偏向锁可以提高带有同步（如synchronized关键字）但实际运行中无线程竞争的代码的效率，即只有一个线程获取该锁，那么使用偏向锁模式。</p>
<p>偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。<code>-XX：+UseBiasedLocking</code>开启偏向锁。</p>
<p><strong>轻量级锁与偏向锁的区别：</strong></p>
<ul>
<li>偏向锁只执行一次CAS，后续同一个线程获取锁时完全没有同步操作，偏向锁每次都要执行CAS</li>
<li>偏向锁在有其他线程<strong>尝试</strong>获取锁时就失效，轻量级锁在其他线程<strong>获取锁成功后</strong>才会失效</li>
</ul>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>如果有两个以上的处理器，处理器A的线程获取了锁，线程B请求获取同一个对象的锁时会阻塞，在大多数情况下，线程A占有锁的时间不会太久，为了这段很短的时间去挂起和恢复线程B并不值得。</p>
<p>因此，JVM让后面请求锁的那个线程B执行一个忙循环（自旋），不放弃处理器的执行时间，看看处理器A的线程是否很快是否锁。这种情况适用于处理器A的线程只需要很短的时间就释放锁，省去了B线程挂起去等待A释放锁和B线程恢复的时间。自旋锁默认开启，默认次数10次，使用<code>-XX：PreBlockSpin</code>设置次数 。</p>
<h4 id="自旋自适应锁"><a href="#自旋自适应锁" class="headerlink" title="自旋自适应锁"></a>自旋自适应锁</h4><p>如果对于某个锁，自旋很少成功过，以后获取该锁可能省去自旋过程。如果对于某个锁，经常很短时间就成功，虚拟机认为这次自旋很有可能再次成功，会允许自旋等待更长的时间。有效的解决了自旋等待时间过长时白白耗费CPU资源的问题。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。</p>
<p>比如编写了一段看起来没有同步的代码，但是经javac编译后，发现包含了三个sb.append()操作，每个sb.appen()方法都包含一个同步块，锁就是sb对象，虚拟机观察sb，发现它的动态作用于被限制在concatString()方法内部，也就是说，其他线程访问不到当前线程的sb对象，因此，这里虽然有锁，但是可以消除。JVM就会消除该锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一段看起来没有同步的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// javac 转化后，可以看出包含了三个sb.append()操作,这些操作都是同步的，耗费性能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，在编写代码时，锁的粒度越小越好，但是如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁出现在循环体中，即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如下面的例子中，第一个while循环对当前实例对象加锁1次，第二个while循环对当前实例对象加锁99次，虚拟机优化后，只加锁了1次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TooMuchLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        	<span class="keyword">while</span>(i&lt; <span class="number">100</span>) &#123;</span><br><span class="line">            	i++;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	System.out.println(<span class="string">"suming..."</span>);</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">while</span>(j &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            	j++;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	sum = i + j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机锁粗化后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">         System.out.println(<span class="string">"suming..."</span>);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="性能提升原则"><a href="#性能提升原则" class="headerlink" title="性能提升原则"></a>性能提升原则</h3><p>开发过程中，尽量遵循以下原则：</p>
<ul>
<li>尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，比如尽量不要对I/O操作加锁。</li>
<li>不要频繁的对同一个对象加锁，即使虚拟机有锁粗化机制</li>
<li>不要盲目的为了提高性能而细化锁的粒度，细化锁的粒度时，要时刻警惕线程安全性。</li>
</ul>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>通常处理器和内存之间都有几级缓存来提高处理速度，处理器先将内存中的数据读取到内部缓存后再进行操作，但是对于缓存写会内存的时机则无法得知，因此在一个处理器里修改的变量值，不一定能及时写会缓存，这种变量修改对其他处理器变得“不可见”了。</p>
<p>因此，可见性指的是内存可见性，当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。与原子性对比如下:</p>
<ul>
<li><p>原子性：一个线程使用对象期间，对象不被其他线程修改。</p>
</li>
<li><p>可见性：一个线程A使用对象期间，对象可以被其他线程修改，但是线程A能够看到发生的变化。</p>
</li>
</ul>
<p>通过加锁实现的原子性可以保证可见性：线程A执行某个同步代码块时，线程B随后进入同一个锁保护的同步代码块，在这种情况下，可以保证线程B获取锁后可以看到线程A之前在同一个同步代码块中的所有操作。因此，<strong>加锁的含义不仅仅局限于互斥行为，还包括内存可见性</strong>。</p>
<p>但在不要求互斥、只要求内存可见性的情况下，再使用锁就显得有些重了，此时可以使用volatile变量，它可以保证内存可见性，变量的修改通知到其他线程。</p>
<h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>Java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> TestInstance instance = <span class="keyword">new</span> TestInstance();</span><br></pre></td></tr></table></figure>

<p>上述代码的汇编代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de1d</span>: movb $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi);</span><br><span class="line"><span class="number">0x01a3de24</span>: lock  addl $<span class="number">0x0</span>,(%esp);</span><br></pre></td></tr></table></figure>

<p>有Violatile修饰的变量在汇编阶段，会多出一条lock前缀指令，它在多核处理器下引发两件事情：</p>
<ul>
<li>将当前处理器缓存行的数据写回内存</li>
<li>写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效（缓存一致性协议）</li>
</ul>
<h3 id="回写内存"><a href="#回写内存" class="headerlink" title="回写内存"></a>回写内存</h3><p>处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时回写内存，<strong>如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存</strong></p>
<h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>使用Volatile修饰的变量，在写操作的时候，会强制将这个变量所在缓存行的数据写回到内存中，但即使写回到内存，其他处理器也有可能使用内部的缓存数据，从而导致变量不一致；所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，如果处理器发现自己缓存行对应的内存地址被修改，就会将该缓存行设置成无效状态，下次要使用就会重新从内存中读取。</strong></p>
<h3 id="lock信号"><a href="#lock信号" class="headerlink" title="lock信号"></a>lock信号</h3><p>volatile的核心是lock前缀指令，它负责通知cpu将当前操作立即回写内存，正是因为回写内存的存在，指令重排无法跨过lock信号对应的指令。<strong>因此，lock前缀实际上是一种内存屏障，cpu不会跨过该屏障进行重排序，volatie不仅可以保证可见性，也保证有序性。</strong></p>
<h2 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h2><p>当且仅当满足以下所有条件时，才应该使用volatile变量：</p>
<ul>
<li><p>对该变量的写入操作不依赖变量的当前值，或者能确保只有一个线程更新变量的值</p>
</li>
<li><p>该变量不与其他变量一起纳入不变性条件中（因为volatile变量不能确保原子性）</p>
</li>
</ul>
<p>举例一些应用场景：标识一些事件的发生，如初始化、销毁、判断是否处于某个状态，状态的变化只有一个线程能够触发。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇主要讨论了以下内容：</p>
<ul>
<li>通过CAS、对象锁保证原子性；</li>
<li>通过volatile、对象锁保证可见性、有序性。</li>
<li>CAS存在的三个问题</li>
<li>缓存一致性协议的定义</li>
<li>JVM的锁优化方法。</li>
</ul>
<p>下一篇主要介绍对象的安全发布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/java并发编程（二）对象安全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/java并发编程（二）对象安全/" itemprop="url">JAVA并发（二）对象安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-01T00:00:00+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="this逸出"><a href="#this逸出" class="headerlink" title="this逸出"></a>this逸出</h1><p>this逸出就是：在对象还未实例化完成时，就能被其他对象锁获取（发布）。</p>
<h2 id="什么是this逸出"><a href="#什么是this逸出" class="headerlink" title="什么是this逸出"></a>什么是this逸出</h2><p>对于一个类C来说，“外部方法”指的是行为不完全由类C规定的方法，包括其他类定义的方法，以及类C中可以被改写的方法。当把类C的对象传递给某个外部方法时，相当于发布了该对象，此时如果C的实例未完成实例化，就称为类C的实例的this逸出。<strong>最常见的“外部方法”使用场景是在构造器中生成内部类实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="comment">// 定义一个事件监听的接口</span></span><br><span class="line"><span class="number">2</span>  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>      <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">4</span>  &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="comment">// 定义一个管理事件监听器类</span></span><br><span class="line"><span class="number">7</span>  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventSource</span> </span>&#123;</span><br><span class="line"><span class="number">8</span>      <span class="keyword">private</span> List&lt;EventListener&gt; source = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="number">9</span> </span><br><span class="line"><span class="number">10</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener listener)</span> </span>&#123;</span><br><span class="line"><span class="number">11</span>         <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">12</span>              Thread.sleep(<span class="number">500L</span>);</span><br><span class="line"><span class="number">13</span>         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="number">14</span>              e.printStackTrace();</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>         listener.onEvent(); <span class="comment">//假设listener注册500ms就被调用了</span></span><br><span class="line"><span class="number">17</span>         source.add(listener);</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>  <span class="comment">// this逸出类</span></span><br><span class="line"><span class="number">22</span>  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"><span class="number">23</span>    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="number">24</span>    <span class="keyword">private</span> Thread t;</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span>    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source, String initName)</span> </span>&#123;</span><br><span class="line"><span class="number">27</span>        name = initName;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>        <span class="comment">// 在构造器中启动线程</span></span><br><span class="line"><span class="number">30</span>        t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="number">31</span>            <span class="meta">@Override</span></span><br><span class="line"><span class="number">32</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">33</span>                name = <span class="string">"threadName"</span>; <span class="comment">// this可能逸出至其他线程</span></span><br><span class="line"><span class="number">34</span>            &#125;</span><br><span class="line"><span class="number">35</span>        &#125;);</span><br><span class="line"><span class="number">36</span>        t.start(); <span class="comment">// 一旦启动该线程，this就逸出了，name随时有可能被修改为threadName</span></span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span>        source.registerListener(<span class="keyword">new</span> EventListener() &#123;</span><br><span class="line"><span class="number">39</span>            <span class="meta">@Override</span></span><br><span class="line"><span class="number">40</span>            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">41</span>                name = <span class="string">"eventName"</span>; <span class="comment">// this隐式逸出</span></span><br><span class="line"><span class="number">42</span>            &#125;</span><br><span class="line"><span class="number">43</span>        &#125;);</span><br><span class="line"><span class="number">44</span>        <span class="comment">// 构造函数中需要耗时才能完成this构建，这里为了明显的看到this逸出的效果，设为1s</span></span><br><span class="line"><span class="number">45</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">46</span>            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"><span class="number">47</span>        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="number">48</span>            e.printStackTrace();</span><br><span class="line"><span class="number">49</span>        &#125;</span><br><span class="line"><span class="number">50</span>    &#125;</span><br><span class="line"><span class="number">51</span></span><br><span class="line"><span class="number">52</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">53</span>        ThisEscape thisEscape = <span class="keyword">new</span> ThisEscape(<span class="keyword">new</span> EventSource(), <span class="string">"initName"</span>);</span><br><span class="line"><span class="number">54</span>        System.out.println(<span class="string">"name = "</span> + thisEscape.name);</span><br><span class="line"><span class="number">55</span>    &#125;</span><br><span class="line"><span class="number">56</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中存在两处this逸出，一个是33行、另一个是在41行，最后name的值取决于11<del>15行、30</del>36行、45~49行这三处，它们分别是：</p>
<ul>
<li>11~15行：listener注册完成后多久才会调用到onEvent？</li>
<li>30~36行：线程t何时启动？</li>
<li>45~49行：thisEscape对象需要多久才能构造完成？</li>
</ul>
<p>前两处在实际应用的过程中都有可能不是构造器能够控制的，无论是Runable还是EventListener，它们的本质是相同的：<strong>在构造器中初始化一个内部类的实例，导致this隐式的泄露</strong>。</p>
<h2 id="避免this逸出"><a href="#避免this逸出" class="headerlink" title="避免this逸出"></a>避免this逸出</h2><p>为了避免this逸出，有如下策略：</p>
<ul>
<li>可以在构造器中创建线程，但不要直接启动该线程，应该确保在对象初始化完成后再启动该线程</li>
<li>只要将构造器设置为private，然后使用工厂方法发布对象，就一定不存在this逸出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于工厂方法防止this引用逸出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">(String initName)</span> </span>&#123;</span><br><span class="line">		name = initName;</span><br><span class="line">		listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                name = <span class="string">"eventName"</span>; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source, String initName)</span> </span>&#123;</span><br><span class="line">		SafeListener listener = <span class="keyword">new</span> SafeListener(initName);</span><br><span class="line">		source.registerListener(listener); <span class="comment">// listener已构造完成，不存在this泄露</span></span><br><span class="line">		<span class="keyword">return</span> listener;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>共享的对象在堆中可以被所有线程访问到，所以会存在线程不安全的问题，但如果某个对象只能被单线程访问，就不存在线程安全问题。这种仅在单线程内访问对象、将某个对象封闭起来的技术称为线程封闭。</p>
<h2 id="单线程写入volatile变量"><a href="#单线程写入volatile变量" class="headerlink" title="单线程写入volatile变量"></a>单线程写入volatile变量</h2><p>在volatile变量上存在一种特殊的线程封闭，只要能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享volatile变量上执行“读取-修改-写入”操作，这种情况相当于将修改操作封闭在单个线程中，避免了竞态条件，并且volatile变量的可见性可以保证其他线程能够看到最新的修改。</p>
<h2 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h2><p>栈封闭是线程封闭的一种特例，在栈封闭中，只有通过局部变量才能访问对象，局部变量都存在于栈中，因此，它是线程安全的。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculte</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; localList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	localList.addAll(list);</span><br><span class="line">	<span class="comment">// 后续对localList进行操作，线程安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>维持线程封闭另一种做法是使用ThreadLocal，这个类能够使线程与对象关联起来，在线程的上下文都可以获取某一个对象，常用在服务器会话上下文变量的传递等场景下。详见<a href="https://okspy.github.io/threadLocal/" target="_blank" rel="noopener">ThreadLocal原理</a>。</p>
<h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>不可变的对象一定是线程安全的。不可变对象指的是：只有一种状态，且该状态在构造函数内完成，一旦对象构造完成，不再改变。</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final关键字用于构造不可变对象，final类型的域是不能修改的。与c/c++的constant常量有些相似；但JMM中，final关键字被增强了，还有另外一层语义：初始化过程是安全的，final域禁止处理器把final域的写重排序到构造函数之外，一个对象的final域的初始化一定在该对象初始化完成之前完成。</p>
<h3 id="finnal域的写"><a href="#finnal域的写" class="headerlink" title="finnal域的写"></a>finnal域的写</h3><p>原理图如下，在写final域b=2操作后，添加了一个storestore屏障，然后才是构造函数执行结束，而普通域a，则有可能重排序到构造函数执行后。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/concurrence/final%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F.png" alt="final禁止重排序"></p>
<h3 id="final域的读"><a href="#final域的读" class="headerlink" title="final域的读"></a>final域的读</h3><p>同样的，还有一个loadload屏障用于读final域，初次读对象与读对象的final域之间有一个loadload屏障，一个对象的final域的初始化一定在该对象初始化完成之前完成。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/concurrence/final%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F2.png" alt="img"></p>
<h3 id="final与this逸出"><a href="#final与this逸出" class="headerlink" title="final与this逸出"></a>final与this逸出</h3><p>如果出现了this逸出（this逸出：对象在构造函数执行结束前就能被其他对象或线程获取），上述storestore屏障相当于失效了，因此，final的安全性建立在没有this逸出的前提下。</p>
<h3 id="final域的安全性"><a href="#final域的安全性" class="headerlink" title="final域的安全性"></a>final域的安全性</h3><p>在storestore、loadload屏障、没有this逸出的保证下，final关键字声明的域是可以安全发布的，一旦构造完成就不可变，且无法读取到未构造完的final域，对象为null时读取不到final域。</p>
<p>综上，final保证对象只能被初始化一次，且初始化过程是安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List newList)</span> </span>&#123;</span><br><span class="line">	list = newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，若final域引用的对象是可变的，这些被引用的对象可以被修改，还是存在线程不安全。比如下面的例子，虽然list不能被初始化两次，仍然可以修改list的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    list.add(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/hashMap/" itemprop="url">hashMap源码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-14T00:29:29+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA集合/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA集合</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JDK1.8的hashMap采用数组+链表+红黑树的结构，jdk1.7的hashMap采用数组+链表的结构，红黑树的目的是为了解决过长链表效率低的问题。JDK1.8修改了扩容机制，扩容时不需要计算hash，这个在后文会详细说明。</p>
<p>HashMap有几个重要的成员变量，见下表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>initialCapacity</td>
<td>HashMap容量</td>
</tr>
<tr>
<td>loadFactory</td>
<td>负载因子</td>
</tr>
<tr>
<td>threadshold</td>
<td>扩容阈值，capacity*loadFactory</td>
</tr>
<tr>
<td>modCount</td>
<td>修改次数，用于并发时判断数据是否过期（CAS）</td>
</tr>
</tbody></table>
<p>通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现。</p>
<ul>
<li>调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键的键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</li>
<li>增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。一般情况下，用默认值就可以了</li>
</ul>
<h1 id="计算哈希"><a href="#计算哈希" class="headerlink" title="计算哈希"></a>计算哈希</h1><p>hashMap的所有操作都离不开hash值的计算，因此，有必要将hash值的计算写在前面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，hash值的计算是由key的hashCode进行位运算后得到的，在Java中，hash是int型，32位，前16位为高位，后16位为低位，先取hash的低位，和高位进行异或运算，得到hash值，位运算如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/hash%E5%80%BC%E8%AE%A1%E7%AE%97.png" alt="1567838656869"></p>
<p>这么做的好处就是最大限度的发挥高位和低位的作用，提高hash值的复杂度（当我们覆写hashCode方法时，有可能会写出分布性不佳的hashCode方法）。</p>
<p>计算一个键值对在数组中的下标时，采用了公式：<code>(n-1) &amp; hash</code>，n为数组容量，n-1与hash值进行与运算，等价于hash%n，往往只有低位参与了计算，因此，hashMap在计算key的hash值进行的位运算，有利于hash值的高位与低位均可以参与到计算数组下标中去，这就是为什么不直接使用key.hashCode()的原因。</p>
<p><strong>为什么说N-1 &amp; hash 等价于 hash%N</strong></p>
<p>N总是2的n次幂，即只有一位为1，N-1的后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位全部为1（此处不明白的可以查看2.4.3节的表2.1《数组容量与二进制值》），N-1 &amp; hash 即hash的后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位为1的位组成的值，它正是hash%N的余数，如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/n-1&hash.png" alt="1567840630947"></p>
<h1 id="put"><a href="#put" class="headerlink" title="put"></a>put</h1><p>先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对放置于链表最后一个位置或插入红黑树中，或者覆盖键完全相同的值。最后，以put后的容量对比threadshold决定是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="number">3</span> &#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"><span class="number">7</span>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 初次使用时，初始化table</span></span><br><span class="line"><span class="number">8</span>    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">9</span>        n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">// 数组中tab[(n-1)&amp;hash]尚未使用，不存在哈希碰撞，直接将键值对存入tab[(n-1)&amp;hash]</span></span><br><span class="line"><span class="number">10</span>   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">11</span>       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">12</span>   <span class="keyword">else</span> &#123; <span class="comment">// 待存入的键key与已存在的键值对p有哈希冲突，解决冲突</span></span><br><span class="line"><span class="number">13</span>       Node&lt;K,V&gt; e; K k; </span><br><span class="line">    	 <span class="comment">//　若键已存在于桶中第一个节点，将e指向该节点，目的是省去稍后树查找或遍历链表</span></span><br><span class="line"><span class="number">14</span>       <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">15</span>           e = p;</span><br><span class="line">    	 <span class="comment">// 若p为TreeNode，说明该数组下标处（该桶中）已经有8个以上的哈希冲突了，调用红黑树插入方法</span></span><br><span class="line"><span class="number">16</span>       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">17</span>           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    	 <span class="comment">// 当前桶中使用的是链表 </span></span><br><span class="line"><span class="number">18</span>       <span class="keyword">else</span> &#123;</span><br><span class="line">    		  <span class="comment">// 遍历链表，插入尾部</span></span><br><span class="line"><span class="number">19</span>            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    			  <span class="comment">// 判断是否为尾节点，若是，将键值对插入至尾节点后面</span></span><br><span class="line"><span class="number">20</span>                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">21</span>                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">22</span>                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line"><span class="number">23</span>                            treeifyBin(tab, hash);</span><br><span class="line"><span class="number">24</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">25</span>                &#125;</span><br><span class="line">    			  <span class="comment">// 若链表存在该键，跳出循环，此时e=p.next</span></span><br><span class="line"><span class="number">26</span>                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">27</span>                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">28</span>                      <span class="keyword">break</span>;</span><br><span class="line"><span class="number">29</span>                p = e;</span><br><span class="line"><span class="number">30</span>            &#125; <span class="comment">// end for loop</span></span><br><span class="line"><span class="number">31</span>       &#125;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">// 上面的if、elseif、else用于确定待插入节点e的位置，现在确定key相同时，是否覆盖value</span></span><br><span class="line"><span class="number">32</span>    	<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">33</span>            V oldValue = e.value;</span><br><span class="line"><span class="number">34</span>            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">35</span>                 e.value = value;</span><br><span class="line"><span class="number">36</span>            afterNodeAccess(e);</span><br><span class="line"><span class="number">37</span>            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">38</span>      &#125;</span><br><span class="line"><span class="number">39</span>   &#125; <span class="comment">// 结束哈希冲突的解决，已完成键值对的插入</span></span><br><span class="line"><span class="number">40</span>   ++modCount; <span class="comment">// 更新hashMap的修改次数</span></span><br><span class="line">     <span class="comment">// 键值对数量+1 超过threadshold时，提前扩容，便于下一次put</span></span><br><span class="line"><span class="number">41</span>   <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">42</span>       resize();</span><br><span class="line"><span class="number">43</span>       afterNodeInsertion(evict);</span><br><span class="line"><span class="number">44</span>       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">45</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码块的核心逻辑是：</p>
<ul>
<li>1）数组table是否为空？为空则通过扩容的方式初始化</li>
<li>2）要插入的键是否与桶中第一个节点的键是同一个（equals）？若是，则标记该节点并进行第4步，若不是，则遍历树或链表。</li>
<li>3 )  遍历树或链表，待插入的键是否已存在？若存在，则标记该节点进行第4步，若不存在，则插入链表的尾节点或红黑树对应节点。</li>
<li>4）上述3步已完成了带插入节点e的定位，根据onlyIfAbsent判断是否用新值覆盖旧值</li>
<li>5）最后，根据键值对数量与threadshold的比较，判断是否需要进行扩容</li>
</ul>
<h1 id="get"><a href="#get" class="headerlink" title="get"></a>get</h1><p>hashMap查找操作比插入操作更简单，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 定位键值在数组中的下标位置，记为first</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断first是否为要查找的值，目的是省去后面遍历链表或树</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// fisrt不是要查找的值，遍历链表或树，找到就跳出循环，找不到返回Null</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h1><p>在调用put方法将元素插入后，会判断是否超出负载因子*容量，超出后便调用resize()方法进行扩容。</p>
<p>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过（数组大小*loadFactor）时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作</p>
<h2 id="JDK1-7的扩容"><a href="#JDK1-7的扩容" class="headerlink" title="JDK1.7的扩容"></a>JDK1.7的扩容</h2><p>JDK1.7版本的HashMap是数组+链表的结构</p>
<p>扩容机制：新生成一个数组，然后拷贝旧数组里面的每一个数组元素表示的链表（Entry）到新数组里面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; <span class="comment">//当当前数据长度已经达到最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity]; <span class="comment">// 创建新的数组</span></span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing; <span class="comment">// 是否需要重新计算hash值</span></span><br><span class="line">        transfer(newTable, rehash);  <span class="comment">// 将table的数据转移到新的table中</span></span><br><span class="line">        table = newTable; <span class="comment">// 数组重新赋值</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">//重新计算阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// transfer()方法负责创建将旧数组移动至新数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">         <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class="line"> </span><br><span class="line">             <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next; <span class="comment">// 先把next存下来，最后再处理</span></span><br><span class="line">                 <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                     e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">// 计算每个元素在新数组中的位置</span></span><br><span class="line">                 <span class="comment">// 将元素插入新数组，使用头部插入法</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">// e.next 指向 newTable[i]</span></span><br><span class="line">                 newTable[i] = e; <span class="comment">// newTable[i]赋值为e,完成了e插入newTable[i]对应链表的头部</span></span><br><span class="line">                 e = next; <span class="comment">// 处理next节点</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有下面的数组大小为2，loadFactory为默认值0.75的HashMap，在插入第二个元素后（key = 5）会进行扩容，扩容的新数组大小为4（假设hash的计算方法是key%数组大小）</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize01.png" alt="1567598584397"></p>
<p>创建新数组，假设hash的计算方法是key%数组大小，那么key为3和7的Entry均应落在新数组下标为3的位置，即<code>newTable[i]</code>的i为3。此时进入<code>while(null != e)</code>开始遍历旧数组下标为1的Entry</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize02.png" alt="1567599032354"></p>
<center>resize初始阶段</center>
执行`e.next = newTable[i]`，经计算，i的值为3，新的e.next 指向了新数组`newTable[3]`，`newTable[3]`是空的，所以新的e.next指向了null；

<p>执行<code>newTable[i] = e</code>，将e插入<code>newTable[3]</code>对应的链表的头部</p>
<p>执行<code>e=next</code>，此处的next存放的是旧的e.next，即上图中e.next（key=7）， 将e置为key的7的元素。</p>
<p>经过上述三步，HashMap处于下图的状态，记为resize第二阶段完成：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize03.png" alt="1567599724514"></p>
<center>resize第二阶段结束</center>
然后，再进行一次while循环，将key的7的元素移动至`newTable[3]`的头部，next指向了key=3的元素，这样就完成了整个Resize的过程。

<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7Resize04.png" alt="1567599830776"></p>
<center>resize完成</center>
## JDK1.7扩容的线程不安全问题

<p>为了便于理解，将transfer简化，只留下关键步骤：假设两个线程同时执行put操作，进入了transfer环节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"><span class="number">1</span>	  Entry&lt;K, V&gt; next = e.next; <span class="comment">// 线程1开始，此时e.next指向key为7的Entry</span></span><br><span class="line"><span class="number">2</span>	  e.next = newTable[i];<span class="comment">//线程1继续，e.next指向newTable[3],newTable[3]为空，e.next指向null</span></span><br><span class="line"><span class="number">3</span>     newTable[i] = e; <span class="comment">//线程1继续，将newtTable[3]赋值为key为3的Entry</span></span><br><span class="line">      <span class="comment">// 线程2在此刻开始执行第1步 Entry&lt;K, V&gt; next = e.next = null</span></span><br><span class="line">      <span class="comment">// 线程2执行第2步，e.next = newTable[3] = e</span></span><br><span class="line"><span class="number">4</span>	  e = next;</span><br><span class="line"><span class="number">5</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>代码块的注释是按照时间顺序的，在第3行线程1将<code>newTable[3]</code>的赋值为key为3的Entry后（未执行<code>e=next</code>），线程1的状态如下;<br><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7resizeUnsafe01.png" alt="1567645309918"></p>
<center>线程1执行完1~3步</center>
线程2开始执行第1步，` Entry<k, v> next = e.next`，`e.next`此时被线程1修改为了null，所以对于线程2，`next = e.next = null`，然后线程2执行第二步，`e.next = newTable[3]`，`newTable[3]`已被线程1插入了e，所以对于线程2`e.next = e`，然后，线程2执行第3步，将key为3的Entry赋给`newTable[3]`，这个与线程1的操作重复了，不会有影响。此时，线程2的状态如下图。

<p><img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/jdk1.7ResizeUnsafe02.png" alt="1567647285939"></p>
<p>然后，线程2执行最后一步，<code>e = next</code>，发现<code>e = null</code>不满足<code>while</code>条件，跳出循环，此时，并没有出现死循环的问题，<strong>现在的问题仅仅是链表出现了闭环</strong>。</p>
<p><strong>待下一次扩容时，才会出现死循环的问题</strong>，<code>e.next</code>永远为<code>e</code>，再也无法跳出循环。</p>
<p>上述只是链表闭环的一种情况，而且是简化版，实际情况过多，逐个赘述没有意义，不再赘述，重点是需要了解到<strong>多线程put时出现resize，可能会导致链表闭环，从而CPU占用率达到100%。</strong></p>
<h2 id="JDK1-8的扩容"><a href="#JDK1-8的扩容" class="headerlink" title="JDK1.8的扩容"></a>JDK1.8的扩容</h2><p>在JAVA 8版本，HashMap改进了扩容的方式，不再使用JDK 1.7的头部插入法。</p>
<p>为了便于理解，只摘取源码中扩容相关的核心代码：一个for循环用于将旧的数组每个元素e迁移至新数组中。</p>
<ul>
<li>如果<code>e.next == null</code>，表示旧数组中该位置没有哈希碰撞，直接计算e在新数组中的位置并赋值</li>
<li>如果e是TreeNode的实例，计算在新数组的下标，并添加到新数组对应位置的红黑树中，先不赘述</li>
<li>e是链表，按照链表的逻辑插入，本节主要介绍链表情况下的插入，用以比较与JDK1.7的不同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line"><span class="number">2</span>     Node&lt;K,V&gt; e;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">4</span>          oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">5</span>          <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">6</span>              newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">//如果e后面没有元素，说明没有哈希碰撞，直接赋值</span></span><br><span class="line"><span class="number">7</span>          <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">8</span>              ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);<span class="comment">//如果e是红黑树，添加到红黑树</span></span><br><span class="line"><span class="number">9</span>          <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="number">10</span>                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">11</span>                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">12</span>                Node&lt;K,V&gt; next;</span><br><span class="line"><span class="number">13</span>                <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="number">14</span>                    next = e.next;</span><br><span class="line"><span class="number">15</span>                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 此处是重点，后文有分析</span></span><br><span class="line"><span class="number">16</span>                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">// 判断链表尾节点是否为null，即链表是否为空（不为空17    的链表尾节点不可能为null，只包含一个节点的链表头节点与尾节点是同一个节点）</span></span><br><span class="line"><span class="number">18</span>                             loHead = e; <span class="comment">// 如果为null，表示链表为空，loHead = e </span></span><br><span class="line"><span class="number">19</span>                         <span class="keyword">else</span></span><br><span class="line"><span class="number">20</span>                             loTail.next = e; <span class="comment">// 不为null，说明链表已有元素，将尾部指向e</span></span><br><span class="line"><span class="number">21</span>                         </span><br><span class="line"><span class="number">22</span>                        loTail = e; <span class="comment">// 将e插入链表尾部</span></span><br><span class="line"><span class="number">23</span>                     &#125;</span><br><span class="line"><span class="number">24</span>                     <span class="keyword">else</span> &#123; <span class="comment">// 与e.hash &amp; oldCap) == 0原理一样，只不过是插入至另一个链表</span></span><br><span class="line"><span class="number">25</span>                         <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">26</span>                              hiHead = e;</span><br><span class="line"><span class="number">27</span>                         <span class="keyword">else</span></span><br><span class="line"><span class="number">28</span>                              hiTail.next = e;</span><br><span class="line"><span class="number">29</span>                              </span><br><span class="line"><span class="number">30</span>                         hiTail = e;</span><br><span class="line"><span class="number">31</span>                     &#125;</span><br><span class="line"><span class="number">32</span>                 &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">33</span>                 </span><br><span class="line"><span class="number">34</span>                 <span class="comment">// 链表尾节点指向null、数组放置链表头节点</span></span><br><span class="line"><span class="number">35</span>                 <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="number">36</span>                      loTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">37</span>                      newTab[j] = loHead;</span><br><span class="line"><span class="number">38</span>                 &#125;</span><br><span class="line"><span class="number">39</span>                 <span class="comment">// 与loTail相同       </span></span><br><span class="line"><span class="number">40</span>                 <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">41</span>                      hiTail.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>                      newTab[j + oldCap] = hiHead;</span><br><span class="line"><span class="number">43</span>                 &#125;</span><br><span class="line"><span class="number">44</span>          &#125; <span class="comment">// else end</span></span><br><span class="line"><span class="number">45</span> &#125; <span class="comment">// for (int j = 0; j &lt; oldCap; ++j) end</span></span><br></pre></td></tr></table></figure>

<p>e是链表的情况下，声明了loHead、loTail、hiHead、hiTail，他们分别是lo和hi链表的头结点与尾节点。lo链表会插入与旧数组相同的下标处<code>newTab[j] = loHead</code>，hi链表插入旧下标偏移旧容量处<code>newTab[j+oldCap] = hiHead</code>。</p>
<p>上述代码块都很好理解，建立了两个链表，依次在末端插入新的元素，在多线程环境下，JDK 1.7由于头部插入法导致了链表闭环，<strong>JDK 1.8采用尾部插入法，有效的避免了JDK1.7链表闭环的问题</strong>。但是</p>
<ul>
<li>没有解决JDK1.7中的数据丢失的问题，比如多个线程同时put的时候，当index相同而又同时达到链表的末尾时，另一个线程put的数据会把之前线程put的数据覆盖掉，就会产生数据丢失。</li>
<li>多线程下操作同一对象时，对象内部属性的不一致性还会导致死循环</li>
</ul>
<p>不过，HashMap本来就不是为多线程环境设计的，多线程应该使用ConcurrentHashMap。</p>
<p>现在把目光放在上述代码块第15行的<code>if ((e.hash &amp; oldCap) == 0)</code>，它用来判断元素放置在lo链表还是hi链表，这两个链表分别插入在数组下标为旧下标<code>newTab[j]</code>和旧下标+旧容量处<code>newTab[j+oldCap]</code>。上述代码块的第一个注释为<code>如果e后面没有元素，说明没有哈希碰撞，直接赋值</code>，此处将e放置在了<code>newTab[e.hash &amp; (newCap - 1)]</code>处。而在前面介绍的put方法中，也出现了<code>tab[(n - 1) &amp; hash]</code>，我们发现总是将<code>n-1、hash</code>进行与操作<code>(&amp;)</code>，n表示数组容量，它总是2的n次幂，n的二进制如下：</p>
<center>表2.1 数组容量与二进制值</center>
| 数组容量N的十进制值 | 数组容量N的二进制值 | N-1的二进制值 |
| ------------------- | ------------------- | ------------- |
| 2                   | 0000 0010           | 0000 0001     |
| 4                   | 0000 0100           | 0000 0011     |
| 8                   | 0000 1000           | 0000 0111     |
| 16                  | 0001 0000           | 0000 1111     |
| ....                | 000100000..         | 0001111...    |

<p>数组容量N的二进制值总是只有1位为1，其他位全是0，<strong>对于N-1的二进制，后<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位全部为1，将<img src="https://raw.githubusercontent.com/okspy/image/master/hashmap/clip_image002.png" alt="img">位记为标记位M，那么对于2N-1的二进制，它的标记位为M+1</strong>。<code>(n-1)&amp;hash</code>实际上就是<code>hash%(n-1)</code>，只不过JDK1.8采用了速度更快的位运算。<br>根据HashMap的数据散落原理，是取hash值然后对数组的大小取余，且每次扩容后，容量为扩容前的二倍，那么将旧数组容量oldCap记为N：</p>
<p>​        e.hash &amp;（N-1） = oldPos  // 标记位为M</p>
<p>​        e.hash &amp;  (2N-1) = newPos // 标记位为M+1</p>
<p>它们等价于：</p>
<p>​        e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>​        e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>上述两个式子分别用来计算e在新旧数组中的位置newPos、oldPos，它们实际上是e.hash对一个低位全部为1，高位全部为0的二进制的与运算，所以在计算Position时，e.hash比标记位更高的位是无意义的，这个标记位取决于数组的容量大小：</p>
<ul>
<li>对于旧的数组，容量N、标记位M，只考虑e.hash的低M位。</li>
<li>对于新的数组，容量2N、标记位M+1，只考虑e.hash的低M+1位。</li>
</ul>
<p>现在来看<code>if ((e.hash &amp; oldCap) == 0)</code>的意义：</p>
<p>​    e.hash &amp; N = 0  ==&gt;  e.hash &amp; 0000…01000  = 0 </p>
<p>N的二进制中唯一的1出现在标记位M+1处，即oldCap的唯一的1出现在此处，所以这个if语句用来判断e的hash值的倒数M+1位是否为0：</p>
<ul>
<li><p>如果e.hash倒数第M+1位为0，有下面三个式子：</p>
<p>e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>e.hash &amp; 0000 1000…..= 0  </p>
<p>因此，newPos = e.hash &amp; 0000 1111… = e.hash &amp; 0000 0111…. =oldPos</p>
<p>只考虑e.hash的低M位，与旧数组中位置计算方式一样，得到的结果也必然相同，所以e在新旧数组中位置相同。</p>
</li>
<li><p>如果 e.hash倒数第M+1位不为0（为1），则有下面的三个式子：</p>
<p>e.hash &amp; 0000 0111…. = oldPos                // M个1</p>
<p>e.hash &amp; 0000 1111…. = newPos              // M+1 个1</p>
<p>e.hash &amp; 0000 1000…..= 000..10000       //   倒数第M+1位为1</p>
<p>因此，newPos = e.hash &amp; 0000 1111… = （e.hash &amp; 0000 0111….）+ （e.hash &amp; 0000 1000…..） = oldPos + oldCap</p>
</li>
</ul>
<p><strong>通过以上的位运算，不需要再重新计算hash值，即可完成旧数组向新数组的迁移，大大地提高了效率</strong></p>
<h1 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h1><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>Object的equals比较的是对象的内存地址。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj); <span class="comment">// 如果对象内存地址相同，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在实际的业务中，往往判断两个对象是否equals时，是根据对象所对应的“值”去判断的，这时，就需要重写equals方法。比如JDK的String类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123; <span class="comment">// 如果对象内存地址相同，返回true        </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;        </span><br><span class="line">        String anotherString = (String)anObject;        </span><br><span class="line">        <span class="keyword">int</span> n = value.length;        </span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;   <span class="comment">// 比较两个字符串长度是否相等         </span></span><br><span class="line">            <span class="keyword">char</span> v1[] = value;            </span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;            </span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;            </span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123; <span class="comment">// 逐个字符比较，全部相等时返回true                </span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;                </span><br><span class="line">                i++;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><p>java.lang.Object中对hashCode的约定：如果两个对象根据equals方法比较是相等的，那么调用这两个对象的任意一个hashcode方法都必须产生相同的结果。比如String类，因为重写了equals，那么必须重写hashcode。</p>
<p>首先看Object的hashcode的计算方式（<a href="https://www.jianshu.com/p/be943b4958f4" target="_blank" rel="noopener">参考博客</a>），下面的代码为openjdk1.8的Native源码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> intptr_t <span class="title">get_next_hash</span><span class="params">(Thread * Self, oop obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">     <span class="comment">// so it's possible for two threads to race and generate the same RNG.</span></span><br><span class="line">     <span class="comment">// On MP system we'll have lots of RW access to a global, so the</span></span><br><span class="line">     <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">     value = os::random() ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">     <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">     <span class="comment">// synchronization schemes.</span></span><br><span class="line">     <span class="keyword">intptr_t</span> addrBits = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">     value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">     value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">     value = ++GVars.hcSequence ;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">     value = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Marsaglia's xor-shift scheme with thread-specific state</span></span><br><span class="line">     <span class="comment">// This is probably the best overall implementation -- we'll</span></span><br><span class="line">     <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">     <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">     t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">     <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">     v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">     Self-&gt;_hashStateW = v ;</span><br><span class="line">     value = v ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  value &amp;= markOopDesc::hash_mask;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="number">0</span>) value = <span class="number">0xBAD</span> ;</span><br><span class="line">  assert (value != markOopDesc::no_hash, <span class="string">"invariant"</span>) ;</span><br><span class="line">  TEVENT (hashCode: GENERATE) ;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8默认采用的是最后一个else语句中的计算方式<code>xor-shift算法</code>，该算法根据四个初始值可以生成一系列随机数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xor-shift 伪随机数生成算法</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">xor128</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> x=<span class="number">123456789</span>,y=<span class="number">362436069</span>,z=<span class="number">521288629</span>,w=<span class="number">88675123</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> t;</span><br><span class="line">t=(xˆ(x&lt;&lt;<span class="number">11</span>));x=y;y=z;z=w; <span class="keyword">return</span>( w=(wˆ(w&gt;&gt;<span class="number">19</span>))ˆ(tˆ(t&gt;&gt;<span class="number">8</span>)) );</span><br></pre></td></tr></table></figure>

<p>其中，hashStateX计算方式为<code>hashStateX=Slef-&gt;os::random()</code>，hashStateY、hashStateZ、hashStateW都是固定初始值，最终的Value由这四个值计算得出。</p>
<p>在第一个if语句<code>if(hashCode==0)</code>中有一行注释： so it’s possible for two threads to race and generate the same RNG，说明了两个线程竞争调用os::random()时有可能产生相同的随机数，这个是我们不想看到的，因此，JDK采用了<code>xor-shift算法</code>，即便初始值相同，产生的随机数也不同，有效的规避了这种情况，最终产生的随机数是线程相关的，支持多线程并发，有可能是目前最好的hashCode算法。（最后一个else语句中的注释：Marsaglia’s xor-shift scheme with thread-specific state This is probably the best overall implementation ）</p>
<p>总之，<strong>默认地，Object.hashCode()产生一个线程安全的唯一随机值，可以通过在JVM启动参数中添加-XX:hashCode=2，改变默认的hashCode计算方式，JVM参数里的hashCode为0时hashCode的计算方式是os随机值，多线程竞争时可能会出现重复，为1时是对象的内存地址做位移运算后与一个随机数进行异或得到的结果，为2时是固定值、为3时是自增值</strong></p>
<p>再看String类的hashcode方法，String对象的hash值与每个字符都有关，所以该hash值更看重的是业务层面的“值”的比较。这也对应了<strong>重写了equals，那么必须重写hashcode</strong>的约定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;         </span><br><span class="line">        <span class="keyword">char</span> val[] = value;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123; <span class="comment">// 逐个字符修改原始hash值           </span></span><br><span class="line">            h = <span class="number">31</span> * h + val[i];        </span><br><span class="line">        &#125;        </span><br><span class="line">        hash = h;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">//返回的hash值与每个字符相关。满足equals的两个不同的new String对象，对应完全相同的hash值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用重写过equals-和hashcode-的对象作为Map的键"><a href="#使用重写过equals-和hashcode-的对象作为Map的键" class="headerlink" title="使用重写过equals()和hashcode()的对象作为Map的键"></a>使用重写过equals()和hashcode()的对象作为Map的键</h2><p>在使用hashMap时，判断是不是同一个键的条件如下，为true时表示同一个键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>

<p>对于第一个条件：比较的是Node的hash值，它通过构造方法设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node的hash值通过构造方法设置</span></span><br><span class="line">Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以put为例，调用过程如下，可以看出，<strong>Node的hash值等于key的hash值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// 调用putVal</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>); <span class="comment">// 调用newNode()</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        	... <span class="comment">// 省略，与此处逻辑无关</span></span><br><span class="line">&#125;        	</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，满足下面任一个条件即视为同一个键：</p>
<ul>
<li>key的hash值相同且key为同一个（==表示指向同一个堆地址，是同一个对象）</li>
<li>两个键满足equals</li>
</ul>
<p>对于第一个条件，与key的hash值完全相关，前面介绍了JDK1.8hash值默认是一个线程相关的随机数，而在业务层面上，往往键都是有实际意义的，因此，尽量不要使用JDK的随机数作为对象的hash值。如果不注意，将没有重写hashCode()的对象作为了Map的Key，在调用get、put、remove方法时，可能会出现一些意外的错误，比如，你不想让两个键相同（这里的相同指的是值相同，业务意义相同，比如人名、身份证ID）的对象同时出现在Map中，那么，有必要重写hashCode，否则会出现冲突，例子如下：。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Person tom = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>)</span><br><span class="line">Person tom2 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>)</span><br><span class="line"></span><br><span class="line">Map&lt;Person, Blog&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(tom);</span><br><span class="line">map.put(tom2);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，你本来不想让姓名重复的用户插入到Map中，但是因为没有重写Person的hashCode，导致这两个对象tom、tom2的hashCode不同，都成功插入Map。</p>
<p>对于第二个条件，Object.equals()比较的是键的内存地址，这也与业务无关。示例可参考上面的示例。</p>
<p><strong>因此，尽量使用那些已经覆写了equals和hashCode的类，比如String、Integer等，如果要使用自定义的类作为hashMap的key，要覆写equals和hashCode方法，将它改为值的判断，避免使用时出现意外的错误。</strong></p>
<h1 id="细节疑问"><a href="#细节疑问" class="headerlink" title="细节疑问"></a>细节疑问</h1><ol>
<li><p>为什么HashMap实现了Serializable接口，却将table声明为transient？（声明为transient，不会被序列化）</p>
<p>答：参考<a href="https://stackoverflow.com/questions/9144472/why-is-the-hash-table-of-hashmap-marked-as-transient-although-the-class-is-seria" target="_blank" rel="noopener">StackOverfolw回答</a>，HashMap使用wirteObject、readObject实现自定义的序列化和反序列化，序列化时记录了的table的size、键值对的size、以及所有的key-value映射，没有序列化table（Node数组），Node包含了hash值、key、value、以及下一个Node指针，Node的作用是便于遍历键值对，<strong>table不序列化的目的只是为了节省空间</strong>，当反序列化的时候，通过readObject重新构建table。</p>
</li>
<li><p>为什么链表长度为8时进行树化，怎么不是2、4、16、32？</p>
<p>红黑树占据的空间是链表的两倍，删除和新增数据都需要调整树，所以会尽量避免使用红黑树，在hashMap源码196行的有一段注释提到：当选择计算hash值的算法足够好时，数据均匀分布，呈现泊松状，同一个桶中的节点数等于8的概率为亿分之6，因此，为8时链表转换为红黑树的概率已经极低了。</p>
<ul>
<li>一个桶中链表长度达到4的概率为1.5%，此时链表查询复杂度为4，红黑树为2，差距不大</li>
<li>一个桶中链表长度为8的概率为亿分之6，此时链表复杂度为8，红黑树为3，差距开始明显，有必要树化</li>
<li>一个桶中长度为16的概率更低，除非你重写的hashCode方法真的很烂，此时链表复杂度为16，红黑树为4，差距较大，树化已经晚了</li>
</ul>
</li>
<li><p>为什么是树的节点数是6的时候，退化成链表，怎么不是8？</p>
<p>如果是8,或者7，假如有大量的操作在长度7和8之间来回切换，这种结构的变换导致耗时更多，所以用6进行一个过渡。</p>
</li>
</ol>
</k,>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/threadLocal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/threadLocal/" itemprop="url">threadLocal原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T00:29:29+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h1><p>在了解threadLocal之前，有必要了解JAVA中的四种引用：</p>
<ul>
<li>强引用：正常new出来对象就是强引用，<strong>当内存不够的时候</strong>，JVM宁可抛出异常，也不会回收强引用对象。</li>
<li>软引用(<code>SoftReference</code>)：软引用生命周期比强引用低，<strong>在内存不够的时候</strong>，会进行回收软引用对象。软引用对象经常和引用队列<code>ReferenceQueue</code>一起使用，在软引用所引用的对象被GC回收后，会把该引用加入到引用队列中。</li>
<li>弱引用(<code>WeakReference</code>)：弱引用生命周期比软引用要短，<strong>在下一次GC的时候</strong>，扫描到它所管辖的区域存在这样的对象： <code>一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向,</code>，不管当前内存是否够，该对象都会被回收。弱引用和软引用一样，也会经常和引用队列<code>ReferenceQuene</code>一起使用，在弱引用所引用的对象被GC回收后，会把该引用加入到引用队列中。</li>
<li>虚引用（<code>PhantomReference</code>)：又叫幻象引用，与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象将被回收时，自己被加入到引用队列，用作记录该引用指向的对象即将被销毁。</li>
</ul>
<p>finallized方法： 当对象变成(GC Roots)不可达时（第一次回收），GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达（第二次回收），若不可达，则进行回收，否则，对象“复活”。因此，对于重写了finallized方法的对象，会出现两个垃圾回收周期，这两个周期之间可能相隔了很久（取决于finalized方法执行是否及时），所以可能会出现大部分堆被标记为垃圾却还没有被回收，出现内存溢出的错误。</p>
<p>使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>通常情况下，线程中对全局变量赋值后，可以被任何一个线程访问并修改的。</p>
<p>而创建全局变量<code>ThreadLocal</code>，通过<code>ThreadLocal</code>全局变量传递局部变量，该局部变量只能被当前线程访问，而且可以<strong>在线程的上下文传递</strong>，其他线程则无法访问和修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; mystr = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mystr.set(<span class="string">"test_str_1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上通过<code>ThreadLocal</code>设置的值是放入了当前线程的一个<code>ThreadLocalMap</code>实例中，所以只能在本线程中访问，其他线程无法访问。</p>
<h2 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h2><p><strong>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例，value是真正需要存储的Object。</strong></p>
<p><em>从set()方法的实现，理解ThreadLocal实现</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8 source code </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用set方法时</p>
<ul>
<li>首先获取当前线程  <code>Thread.currentThread()</code></li>
<li>利用当前线程获取一个<code>ThreadLocalMap</code>对象</li>
<li>判断map是否为空，若为空，创建这个<code>ThreadLocalMap</code>对象并设置值，不为空，则设置值。</li>
</ul>
<p><code>getMap()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Thread</code>类中，定义了两个属性，<code>threadLocals</code>的初始化是在调用<code>ThreadLocal</code>类中的<code>getMap()</code>方法时完成的，当线程退出时，会将<code>threadLocals</code>和<code>inheritableThreadLocals</code>置为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>; <span class="comment">// ThreadLocalMap对象</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>; <span class="comment">// 子类可继承的ThreadLocalMap对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程退出后，将threadLocals和inheritableThreadLocals置为null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">        group = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">   target = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">   threadLocals = <span class="keyword">null</span>; </span><br><span class="line">   inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">   inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">   blocker = <span class="keyword">null</span>;</span><br><span class="line">   uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，完成了前两步，获取当前线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，是基于Entry数组的map。<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>弱引用，目的是当线程退出时把<code>threadLocal</code>实例置为null时，不再有强引用指向<code>threadLocal</code>实例，不影响<code>threadLocal</code>实例的垃圾回收。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>threadlocal</code>的生命周期中,存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用.</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/threadlocal/ThreadLocal%E5%BC%95%E7%94%A8.png" alt="img"></p>
<p>与上面的分析一致，Entry的key为弱引用，它的引用链是<code>ThreadLocalRef -&gt; ThreadLocal ---&gt; key</code>，当栈中的<code>ThreadLocalRef</code>与堆中的<code>ThreadLocal</code>断开时，<code>ThreadLocal</code>实例就会被垃圾回收。</p>
<p>value为强引用，它的引用链是<code>CurrentThreadRef -&gt; CurrentThread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</code>，只要当前线程没有关闭，<code>CurrentThreadRef -&gt; CurrentThread</code>的引用就不会断开，value就不会被垃圾回收。只有当前thread结束以后, <code>CurrentThread</code>就不会存在栈中,强引用断开, CurrentThread, Map, value将全部被GC回收.</p>
<h2 id="是否存在内存泄露？"><a href="#是否存在内存泄露？" class="headerlink" title="是否存在内存泄露？"></a>是否存在内存泄露？</h2><p>上节提到当前线程没有退出，将会一直存在CurrentThread至value的引用链，即便将threadLocal手动设置为null也依然存在CurrentThread至value的引用链。这会给开发者产生一种<strong>内存泄露的错觉</strong>（错觉：value是通过threadLocal设置的，我明明将threadLocal设置为了null，为什么value还会占用内存？），尤其在使用线程池时更容易出现这样的错觉，因为线程池的线程结束后，会放回线程池中不销毁。</p>
<p>可以理解为：threadLocal没有内存泄露，泄露的是Entry。</p>
<p><strong>JDK的优化</strong></p>
<p>为了减缓这种错觉的产生，Java会在调用threadLocal实例的get、set方法且key为null时，清除Entry。以get方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// threadlocal.get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">//此处调用threadlocalMap.getEntry（）</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threadlocalMap.getEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key) </span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">return</span> getEntryAfterMiss(key, i, e); <span class="comment">// 没找到该key(threadlocal)时，调用该方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash未命中时调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// ThreadRef这条链还没断，thread未被销毁，entry不为Null</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">             <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)   <span class="comment">// threadLocalRef这条链已断开，threadLocal实例为Null</span></span><br><span class="line">             expungeStaleEntry(i); <span class="comment">// 删除所有key为null的Entry</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             i = nextIndex(i, len);</span><br><span class="line">             e = tab[i];</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅在调用get方法，在调用set、remove方法时，threadLocal为null时，也会最终调用到<code>expungeStaleEntry()</code>方法 ，清除所有threadLocal为null时entry的强引用，这里不赘述了。</p>
<p>因此，正确的使用方式是，首先判断是否存在场景：threadLocal置为null？</p>
<p>如果存在，在调用完set、get后，记得调用remove方法显示的清除Entry的强引用。如果不存在，threadLocal一直在使用，没有被回收的必要，也不care脏读的情况，那更没必要去回收threadLocalMap中的Entry了。</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>示例如下，创建一个大小为8的线程池，向该线程池提交100次任务，因为使用的是线程池，线程不会被销毁，所以假设某一个线程写入了值，然后该线程处于空闲态，然后该线程再次读取时，读取到的是上次该线程运行时设置的值。</p>
<p>可能下面的例子很明显就看的出问题所在，但是当项目复杂时，在多处调用get，就比较容易出现这种问题。</p>
<p>不过这种情况也很容易避免，有两种方法：</p>
<ul>
<li>set、get成对出现，set在前、get在后</li>
<li>使用remove</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; mystr = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	ExecutorService executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        String s = mystr.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                	mystr.set(<span class="string">"test"</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Hash碰撞"><a href="#Hash碰撞" class="headerlink" title="Hash碰撞"></a>Hash碰撞</h2><p>在某个线程中，每new一个ThreadLocal实例，该线程的<code>ThreadLocalMap</code>中就会新增的一个key，当ThreadLocal实例过多时，自然会出现hash碰撞。</p>
<p>和<code>HashMap</code>的最大的不同在于，<code>ThreadLocal.ThreadLocalMap</code>结构非常简单，没有next引用，也就是说<code>ThreadLocalMap</code>中解决Hash冲突的方式并非链表/红黑树的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p>
<p>线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。所以在开发的过程中，要避免这一点，提高运行效率。</p>
<h2 id="与synchronized的区别"><a href="#与synchronized的区别" class="headerlink" title="与synchronized的区别"></a>与synchronized的区别</h2><ul>
<li><code>ThreadLocal</code>用于处理线程内部上下文变量的传递，变量不会被其他线程访问，而<code>synchronized</code>修饰的变量，只要其他线程获取了锁，就能访问、修改</li>
<li><code>ThreadLocal</code>没有锁的机制，没有锁的开销</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（四）MongoDB副本集与分片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（四）MongoDB副本集与分片/" itemprop="url">MongoDB系列（四）MongoDB副本集与分片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T00:00:00+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="副本集"><a href="#副本集" class="headerlink" title="副本集"></a>副本集</h1><p>副本集是一组服务器，其中有一个主服务器(primary)，用于处理客户端请求，还有多个备用服务器(secondary)，用于保存主服务器的数据副本，如果主服务器崩溃了，备份服务器会自动选举出一个新的主服务器。</p>
<p>一般的，只有主服务器才会用作写操作，备用服务器最多支持读操作，甚至读写均不支持，只用来做备份。</p>
<h2 id="大多数"><a href="#大多数" class="headerlink" title="大多数"></a>大多数</h2><p>副本集中有一个很重要的概念是”大多数“，选择主节点时由”大多数“决定，主节点只有在得到”大多数“支持时才能继续作为主节点，这里的”大多数“被定义为副本集中一半以上的成员。它是动态变化的，如果某一个节点挂了，那么”大多数“就有可能发送变化，举个例子：</p>
<table>
<thead>
<tr>
<th align="center">副本集的成员总数</th>
<th align="center">”大多数“</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>$$<br>“大多数” &gt;= （总数+1）/2<br>$$</p>
<p>下图是一个包含5个节点的副本集，其中3个位于数据中心A，另外2个位于数据中心B，如果节点1、2、3全挂了，节点4、5不能选举出主节点。这种规定是有目的的：</p>
<p>对于节点4、5而言，节点1、2、3全挂掉与下图情况（数据中心A与B之间的链路中断了）完全相同，此时，数据中心A中还有3个可用节点，满足”大多数“，会选举出一个主节点，数据中心B只有两个可用节点，如果允许数据中心B选举出主节点，那么会出现两个主节点，这就是为什么一定要保证”大多数“的原因，时刻保证只有一个主节点可用，避免多个主节点写入出现冲突所导致的开发的复杂性。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%89%AF%E6%9C%AC%E9%9B%86-%E5%A4%A7%E5%A4%9A%E6%95%B0.png" alt="1566905821363"></p>
<p>还有另外一种情况，同样是两个数据中心，A与B的节点数完全相等，A与B链路断开时，任何一边都无法满足”大多数“。为避免这种情况，有两种做法：</p>
<ul>
<li>将大多数放在同一个数据中心，如节点1、2、3放置在中心A，节点4放在中心B，这样做很简单，但是还会遇到上面的问题，节点1、2全部挂掉了，节点3、4无法提供服务</li>
<li>添加一个仲裁节点，只用来做仲裁，不用来做备份，放置在数据中心C，这样任何一个数据中心的服务器都可以满足”大多数“的条件，这样做的缺点是：将服务器分布到三个地方。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%89%AF%E6%9C%AC%E9%9B%86-%E4%BB%B2%E8%A3%81.png" alt="1566906750134"></p>
<h2 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h2><p>当一个备份节点A无法与主节点连通时，它就会请求其他的副本集成员将自己选举为主节点。其他副本集成员会进行以下检查：</p>
<ul>
<li>自身能否与主节点连通</li>
<li>通过比较A的oplog与自身的oplog，确定A节点的数据是否最新</li>
<li>是否有其他优先级更高的节点请求被选举为主节点</li>
</ul>
<p>赞成票的权重为1，反对票的权重为-10000，所以即使”大多数“成员中只有一个否决了本次选举，选举就会取消。选举的过程一般只需要几毫秒，实际情况可能会遇到网络问题、服务器过载导致响应慢、选举打成平局，平局后每个成员需要等待30s才能进行下一轮选举，所以，如果有太多错误发生的话，选举可能需要几分钟。</p>
<p>首先关注第二点，确定被选举人的数据是否是最新的。如下图所示，一共有3个节点，主节点网络故障，备用节点1发现主节点无法连通，向备用节点2请求选举自身为主节点，备用节点2首先检查到主节点无法连通，然后将对比备用节点1的<code>local.oplog.rs</code>与自身的<code>local.oplog.rs</code>数据，发现备用节点1的oplog中没有记录自身的最新写操作5，投出反对票。此时，备用节点1获悉自身数据不是最新的，会向备用节点2请求最新的oplog，然后再次请求选举为主节点，新一轮的选举中，之前投否决票的的可以重新投票；同时，备用节点2也可以向备用节点1发起请求，请求被选举为主节点。最终，只要备用节点1与备用节点2之间保持连通的状态，一定能选举出新的主节点。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E9%80%89%E4%B8%BE.png" alt="1566982864577"></p>
<p>上面描述的是备用节点1和备用节点2相等时的情况，假如备用节点1和备用节点2已经选举出新的主节点—备用节点1。运行一段时间后，使用下面的命令新添加一个节点，称之为节点3，节点3此时没有任何数据，会从新的主节点（之前的备用节点1）获取最新的<code>oplog</code>，数据更新到最新后，新的主节点（之前的备用节点1）检测到节点3为高优先级节点，新的主节点（之前的备用节点1）主动退位，重新进行选举，直到选举节点3为主节点为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&#123;<span class="string">"_id"</span>:<span class="number">4</span>, <span class="string">"host"</span>:<span class="string">"172.28.70.1:27017"</span>, <span class="string">"priority"</span>:<span class="number">1.5</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>让主节点永远保持最新的oplog是非常重要的，因此，所有的写操作都在主节点进行，在对读取数据一致性要求不高或希望主节点挂掉仍能读数据的场景下，备用节点可以分担主节点读操作的压力。</strong></p>
<p>通过设置<code>readPreference=secondaryPreferred</code>将读请求设置路由至备用节点，建立索引会消耗内存和硬盘空间、降低写操作性能，为进一步缓解主节点压力，</p>
<ul>
<li>可以设置一个与主节拥有不同索引的备份节点</li>
<li>也可以使驱动程序创建一个直接连接到目标备用节点用作读操作（而不是连接到整个副本集）</li>
<li>甚至部分数据从主节点读另一部分从备用节点读。</li>
</ul>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>每个节点都需要知道其他成员的状态，用来确定下列信息：</p>
<ul>
<li>哪个是主节点</li>
<li>哪个挂掉了</li>
<li>是否满足”大多数”</li>
<li>是否有比主节点优先级更高的节点</li>
</ul>
<p>为了维护集合的最新视图，每个成员每隔2s就会向其他成员发送一次心跳，心跳请求的信息量非常小，用来检查每个成员的状态，获取简要信息。</p>
<h3 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h3><ul>
<li>STARTUP                       节点刚刚启动，还未加载副本集配置</li>
<li>STARTUP2                     节点加载副本集配置，进行初始化同步</li>
<li>RECOVERING                初始化完成，进行检查以确保自身处于有效状态，当节点与其他节点脱节时，也会进入该状态，这时，这个成员处于无效状态，需要重更新同步（不是初始化同步，不过于初始化同步动作是一样的，都是同步oplog），同步完成后，回到正常状态（主节点状态、备份节点状态）</li>
<li>PRIMARY                       主节点正常运行的状态</li>
<li>SECONDARY                 备份节点正常运行的状态</li>
<li>ARBITER                        在正常操作中，仲裁节点始终处于该状态，仲裁节点没有oplog，没有数据</li>
<li>DOWN                           节点无法连通</li>
<li>UNKNOW                      所有的节点都无法连通该节点</li>
<li>REMOVED                     节点被踢出副本集</li>
<li>ROLLBACK                     回滚，主节点执行一个写操作后挂掉了，备份节点没有复制该操作，新的主节点也会漏掉该操作，旧的主节点重新上线后，会回滚该操作，然后重新同步。</li>
<li>FATAL                             节点发生不可挽回的错误，也不再尝试恢复正常，这是应该重启该节点、重新同步。</li>
</ul>
<h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p>分片（sharding）是指将数据拆分，将其分散在不同的机器上的过程。分片可以分为：</p>
<ul>
<li>手动分片（manual sharding）</li>
<li>自动分片（autosharing）</li>
</ul>
<p>几乎所有的数据库都支持手动分片，应用维护与各个服务器之间的连接，每个连接是完全独立的，由应用管理数据的路由规则，这种方式的缺点是：难以维护、向集群新增节点或删除节点都很麻烦、调整分布以及负载模式也不轻松，因此，MongoDB提供了自动分片机制。</p>
<h2 id="基于Mongos的自动分片"><a href="#基于Mongos的自动分片" class="headerlink" title="基于Mongos的自动分片"></a>基于Mongos的自动分片</h2><p>MongoDB支持自动分片，使得数据库架构对应用不可见，对于应用而言，好像始终在使用一台单机的MongoDB服务器一样，同时，MongoDB自动处理数据在分片上的分布，也更加容易新增或删除节点。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%88%86%E7%89%87.png" alt="img"></p>
<p>Mongos作为分片集群的访问入口，所有的请求都由mongos来路由、分发、合并，这些动作对客户端驱动透明，用户连接mongos就像连接mongod一样使用，mongos可以是一个或多个，一般部署两个做高可用即可。</p>
<p>Mongos会根据请求类型及片键将请求路由到对应的分片</p>
<h3 id="查询请求"><a href="#查询请求" class="headerlink" title="查询请求"></a>查询请求</h3><ul>
<li>查询请求不包含片键，则必须将查询分发到所有的分片，然后合并查询结果返回给客户端</li>
<li>查询请求包含片键，则直接根据片键计算出需要查询的块（chunk），向对应的分片发送查询请求</li>
</ul>
<h3 id="插入请求"><a href="#插入请求" class="headerlink" title="插入请求"></a>插入请求</h3><p>写操作必须包含片键，mongos根据片键算出文档应该存储到哪个chunk，然后将写请求发送到chunk所在的分片。</p>
<h3 id="更新-删除请求"><a href="#更新-删除请求" class="headerlink" title="更新/删除请求"></a>更新/删除请求</h3><p>更新、删除请求的查询条件必须包含片键或者<code>_id</code>，如果是包含片键，则直接路由到指定的chunk，如果只包含<code>_id</code>，则需将请求发送至所有的分片。</p>
<h3 id="其他命令请求"><a href="#其他命令请求" class="headerlink" title="其他命令请求"></a>其他命令请求</h3><p>除增删改查外的其他命令请求处理方式都不尽相同，有各自的处理逻辑，比如listDatabases命令，会向每个分片转发listDatabases请求，然后将结果进行合并。</p>
<h2 id="何时分片"><a href="#何时分片" class="headerlink" title="何时分片"></a>何时分片</h2><p>通常，不必太早分片，因为分片不仅会增加部署的复杂度、还要求做出设计决策，而且该决策在以后很难再改。</p>
<p>另外，不能太晚分片，因为在一个过载的系统上不停机进行分片是非常困难的。</p>
<p>分片的目的：</p>
<ul>
<li>增加可用内存空间</li>
<li>增加可用磁盘空间</li>
<li>减轻单台服务器的负载</li>
<li>处理单个MongoDB服务器无法承受的吞吐量</li>
</ul>
<p>随着不断增加分片的数量，系统性能大致会呈线性增长，但是，如果从一个未分片的系统转换为只有几个分片的系统，性能通常会有所下降。由于迁移数据、维护元数据、路由等开销，少量分片的系统与未分片的系统相比，通常延迟更大，吞吐量甚至更小。<strong>一般的，至少应该创建3个或以上的分片</strong>。</p>
<h2 id="选择片键"><a href="#选择片键" class="headerlink" title="选择片键"></a>选择片键</h2><p>使用分片时，最重要、最困难的任务时选择数据的分发方式。对集合分片时，要选择一个或两个字段用于拆分数据。这个键（或这些键）称为片键。一旦拥有多个分片，再修改片键几乎是不可能的，所以必需在一开始就确定好片键。</p>
<p>最常见的片键有三种：</p>
<ul>
<li>升序片键（ascending key）</li>
<li>随机分发的片键（random key）</li>
<li>基于位置的片键（location-based key）</li>
</ul>
<h3 id="升序片键"><a href="#升序片键" class="headerlink" title="升序片键"></a>升序片键</h3><p>升序片键有点类似于<code>“data“</code>字段或<code>_id</code>字段，是一种会随着时间稳定增长的字段。</p>
<p>假设已存在一个集合，有5百万条数据，以简化的<code>_id</code>（实际<code>_id</code>是24个16进制字符组成，这里简化便于理解）建立三个分片0001-0003，集合根据<code>_id</code>拆分为多个范围的块，<code>$maxKey</code>指正无穷，<code>5000000-&gt;$maxKey</code>是一个最大块。之后插入的数据都会在最大块中，最大块不是无限大的，它会继续拆分成多个小块，不过还是有以下缺点：</p>
<ul>
<li>会导致之后所有的写操作均被路由至分片0003中</li>
<li>MongoDB必须不断地将一些块从分片0003移动至其他分片。</li>
</ul>
<p>优点是：很好的满足范围查询的请求，比如想查询范围在2500000~2500010的文档，mongos直接路由至分片0002就能查询出所有符合条件的文档。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%8D%87%E5%BA%8F%E5%88%86%E7%89%87.png" alt="1566993777773"></p>
<h3 id="随机分发的片键"><a href="#随机分发的片键" class="headerlink" title="随机分发的片键"></a>随机分发的片键</h3><p>随机分发的片键可以是用户名、邮件地址、设备id、md5散列值等没有规律的键。</p>
<p>假设片键是0-1之间的随机数，数据的随机性意味着新插入的数据会比较均衡的分发至不同的块中，因此，各分片的增长速度大致相同，这就减少了需要进行迁移的次数。</p>
<p>随机分发片键的缺点：范围查询要分发到后端所有的分片才能找出满足条件的文档</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%8F%91%E7%9A%84%E7%89%87%E9%94%AE.png" alt="1566995020969"></p>
<h3 id="基于位置的片键"><a href="#基于位置的片键" class="headerlink" title="基于位置的片键"></a>基于位置的片键</h3><p>片键是用户IP、经纬度、地址等，数据会依据这个位置进行分组，与该位置接近的文档会保存在同一个范围的块中，优点是可以将数据与相关联的用户、相关联的数据保存在一起。</p>
<h2 id="片键策略"><a href="#片键策略" class="headerlink" title="片键策略"></a>片键策略</h2><p>好的片键策略应该拥有如下特性：</p>
<ul>
<li>key 分布足够离散 </li>
<li>写请求均匀分布</li>
<li>读请求均匀分布，尽量避免 scatter-gather 查询 （所有读请求皆在一个分片上，targeted read）</li>
</ul>
<p>目前主要支持2种数据分布的策略，范围分片（Range based sharding）或hash分片（Hash based sharding） </p>
<ul>
<li>范围分片的策略的一种实现是升序片键，能很好的满足『范围查询』的需求，缺点在于，如果片键有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个块，无法扩展写的能力。</li>
<li>Hash分片是根据用户的片键计算hash值（64bit整型），根据hash值按照『范围分片』的策略将文档分布到不同的块。Hash分片与范围分片互补，能将文档随机的分散到各个chunk，充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要分发到后端所有的分片才能找出满足条件的文档。</li>
</ul>
<p>举个例子，某IOT应用使用 MongoDB分片集群存储海量设备（假设100W台）的工作日志，设备每10s向 MongoDB汇报一次日志数据（这个量级，无论从写入还是数据量上看，都应该使用 分片，以便能水平扩张），日志包含<code>deviceId</code>，<code>timestamp</code>信息，应用最常见的查询请求是：查询某个设备某个时间内的日志信息</p>
<ul>
<li><p>方案1：使用时间戳作为片键，采用范围分片策略</p>
<p>时间戳是递增的，支持范围分片策略，新的写入都是连续的时间戳，写入请求会集中到同一个分片上，写请求分布不均匀，但是<code>deviceId</code>不是片键，根据<code>deviceId</code>查询会分散到所有的分片上，效率低下。</p>
</li>
<li><p>方案2：使用时间戳作为片键，采用hash分片策略</p>
<p>由于采用了hash分片策略，保证了写请求均匀分布，与方案1一样，<code>deviceId</code>不是片键，根据<code>deviceId</code>查询会分散到所有的分片上，效率低下。</p>
</li>
<li><p>方案3：使用<code>deviceId</code>作为片键，采用范围分片策略</p>
<p>如果deviceId是没有明显规则的，写请求会均匀分布，根据<code>deviceId</code>的查询均会路由至该分片，查询的要求是某个设备的某个时间段，所以，路由至该分片后，还需要全表扫描并排序，才能找出该设备某时间段内的日志信息。</p>
</li>
<li><p>方案4：使用<code>deviceId</code>作为片键，采用hash分片</p>
<p>与方案3<code>deviceId</code>无规则时基本一致。</p>
</li>
<li><p>方案5：使用<code>deviceId</code>+时间戳作为片键，建立复合索引，采用范围分片策略</p>
<p>同一个设备的数据能够根据时间戳进一步分散到多个chunk，根据deviceId查询时间范围的数据，能够利用复合索引来完成，性能是最优的，不过前提是<code>deviceId</code>无明显规则。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（三）MongoDB索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（三）MongoDB索引/" itemprop="url">MongoDB系列（三）MongoDB索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T00:00:00+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>索引是特殊的数据结构，它以易于遍历的形式存储部分集合数据集。索引存储特定字段或字段集的值，按字段值排序。</p>
<p>MongoDB的索引几乎与传统的关系型数据库索引一模一样，第二章提到的<code>_id</code>实际上也是一个索引，MongoDB的数据按照<code>_id</code>的顺序存储在内存页与磁盘块上。但是，<code>_id</code>与业务毫无关联，在业务相关的条件查询时，还是需要进行全表扫描才能找到对应页，效率并不高。</p>
<ul>
<li>为了避免性能瓶颈，可以根据常用的查询建立索引</li>
<li>索引的值是按照一定的顺序排列的，因此，使用索引键对文档进行排序效率非常高。</li>
</ul>
<p>不过，使用索引也是有代价的，不仅会增加磁盘与内存的消耗，对于添加的每一个索引，每次写操作（插入、更新、删除）都会耗费更多时间，这是因为，数据发生变动时，还需要额外的开销更新索引。</p>
<h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><p>在介绍索引之前，先了解下聚簇索引与非聚簇索引。<br>磁盘上的数据某一时刻只能有一种排序方式，而聚簇索引的特点是：索引顺序与数据存储顺序一致，所以聚簇索引只能有一个。</p>
<p>《数据库原理》中对聚簇索引的定义：聚簇索引的叶子节点是数据节点，非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p>
<p>所以Mysql的InnoDB引擎的主键索引是聚簇索引、MyIsam引擎使用的是非聚簇索引。</p>
<p>MongoDB不会将<code>_id</code>索引与文档内容放在一起，所以MongoDB的<code>_id</code>索引不是聚簇索引，mogoDB将数据与索引分开存放，通过RecordId间接引用。假设为字段<code>”name“</code>创建了索引，主键<code>id</code>为主键索引，那么该集合就通过索引查找RecordId，再查找数据。</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566960990983.png" alt="1566960990983"></p>
<h1 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h1><p>前面提到的<code>_id</code>索引是默认的主键索引，与业务相关联的项不适合用作主键（难以保障全局唯一、非null），建议使用<code>_id</code>作为主键。</p>
<h1 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h1><p>即对单个filed建立索引，也是常说的“普通索引”；建立索引时可以指定索引数据的order：正序还是倒序。MongoDB 3.0后的版本，使用<code>createIndex</code>、<code>ensureIndex</code>是一样的，均是创建索引的命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;) <span class="comment">//对score字段建立索引、1表示正序、-1表示倒序</span></span><br><span class="line">db.mycollection.createIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;) <span class="comment">// MongoDB 3.0后的版本，可以使用createIndex</span></span><br></pre></td></tr></table></figure>

<h1 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h1><p>两个或两个以上的键建立索引，可以减小检索的范围。复合索引与Mysql一样，也是按照左侧匹配规则，这里不赘述，主要介绍下复合索引与排序共用的情况。</p>
<p>首先，在集合<code>”myc“</code>上创建一个复合索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.ensureIndex(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;); <span class="comment">// 索引1</span></span><br></pre></td></tr></table></figure>

<p>再创建一个:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;); <span class="comment">// 索引2</span></span><br></pre></td></tr></table></figure>

<p>这两个复合索引的唯一区别就是键顺序不同，排序规则都是正序（1表示正序、-1表示倒序）。</p>
<p>由于存在了多个索引，使用<code>hint</code>命令指明使用哪个索引。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询1使用索引1</span></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询2使用索引2</span></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对于查询1，先根据索引<code>age</code>查找复合条件的结果集，然后在内存中排序（<code>age</code>索引是有序的，但是排序规则用不到）</li>
<li>对于查询2，遍历整个索引树，找出所有匹配的文档，不需要排序（<code>name</code>索引本身就是有序的），按正序遍历即可。</li>
</ul>
<p>查询1和查询2究竟哪个性能更强，取决于结果集的大小，一般的，结果集越大，在内存中排序耗时越久，超过一定大小（32MB）后，MongoDB会抛出异常，拒绝对如此多的数据排序。一般的：</p>
<ul>
<li>结果集只有几条、十几条，使用查询1，排序的开销跟遍历树的开销相比并不大</li>
<li>结果集有几百条、甚至几千条，使用查询2，排序的开销显得过大。</li>
<li>结果集有几万条，使用查询1或查询2建议具体比较一下</li>
</ul>
<p>结果集的大小可以使用<code>limit</code>关键字人为限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).limit(<span class="number">1000</span>).hint(&#123;<span class="string">"name"</span>:<span class="number">1</span>,<span class="string">"age"</span>:<span class="number">1</span>&#125;); \\使用查询<span class="number">2</span>，并限制结果集</span><br></pre></td></tr></table></figure>

<p>最后，具体使用哪种查询，使用<code>explain</code>关键字在shell中比较一下再做选择。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;).explain()[<span class="string">`millis`</span>]; \\获取查询<span class="number">1</span>耗时</span><br><span class="line"></span><br><span class="line">db.myc.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$gte"</span>:<span class="number">21</span>, <span class="string">"$lte"</span>:<span class="number">30</span>&#125;&#125;).sort(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;).hint(&#123;<span class="string">"age"</span>:<span class="number">1</span>,<span class="string">"name"</span>:<span class="number">1</span>&#125;).explain()[<span class="string">`millis`</span>]; \\获取查询<span class="number">2</span>耗时</span><br></pre></td></tr></table></figure>

<h1 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h1><p>唯一索引用来确保集合的每一个文档的指定键都有唯一值，允许null值。例如：在集合mycollection中，给”name“键建立唯一索引，试图插入重复name的值时，会抛出异常，也会影响效率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"name"</span>:<span class="number">1</span>&#125;, &#123;<span class="string">"unique"</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>使用场景：应对<strong>偶尔</strong>可能会出现重复的键重复问题，而不是在运行时对重复键进行过滤。比如：为避免消息重复消费，可以为”消息id“键创建唯一索引。</p>
<h2 id="复合唯一索引"><a href="#复合唯一索引" class="headerlink" title="复合唯一索引"></a>复合唯一索引</h2><p>复合的唯一索引，单个键的值可以相同，<strong>但所有键的组合值必须是唯一的</strong>。</p>
<p>例如，如果有一个{”username”:1, “age”:100}上的唯一索引，下面的插入是合法的，不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>&#125;);</span><br><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125;);</span><br><span class="line">db.mycollection.insert(&#123;<span class="string">"username"</span>:<span class="string">"fred"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="去除重复"><a href="#去除重复" class="headerlink" title="去除重复"></a>去除重复</h2><p>在已有的集合上创建唯一索引时，可能会失败，因为集合中可能已经存在重复的值了。此时，有三种办法：</p>
<ul>
<li><p>找出重复数据，想办法去除</p>
</li>
<li><p>直接删除重复的值，创建索引时使用<code>”dropDups“</code>选项，如果遇到重复的值，只会保留第一个值。正是由于这种不确定性（不确定哪条记录被删除），MongoDB 3.0以后移除了该选项。</p>
</li>
<li><p>新建一个集合，建立索引，然后把旧集合的数据拷贝至新集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"username"</span>:<span class="string">"bob"</span>&#125;,&#123;<span class="string">"unique"</span>:<span class="literal">true</span>,<span class="string">"dropDups"</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h1><p>唯一索引会把null看做值，假如集合中有以下两个文档，假设对键<code>”age“</code>建立唯一索引，则文档2中的<code>&quot;age&quot;</code>就是<code>null</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125; <span class="comment">// 文档1</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>&#125; <span class="comment">// 文档2</span></span><br></pre></td></tr></table></figure>

<p>现在想新增文档3，是无法添加的，因为文档3中<code>”age“</code>也是<code>null</code>，与文档2冲突了，违反了唯一性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"addresss"</span>:<span class="string">"sz"</span>&#125; <span class="comment">// 文档3</span></span><br></pre></td></tr></table></figure>

<p>此时，应该使用稀疏索引（sparse index），就可以插入文档3，同时也能保证文档4无法插入，满足唯一性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建稀疏索引</span></span><br><span class="line">db.ensureIndex(&#123;<span class="string">"age"</span>:<span class="number">1</span>&#125;, &#123;<span class="string">"unique"</span>: <span class="literal">true</span>, <span class="string">"sparse"</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"dod"</span>, <span class="string">"age"</span>:<span class="number">23</span>&#125; <span class="comment">// 文档4</span></span><br></pre></td></tr></table></figure>

<p>稀疏索引定义如下：如果集合中的文档存在索引键，则必须是唯一的，如果文档不存在索引键，则不要求该文档的唯一性。</p>
<p><strong>注意事项：</strong></p>
<p>根据是否使用稀疏索引，查询结果可能有所不同。例如：对于下面的查询，查询1和查询2是完全相同的语句，不同的是，查询1对应未创建稀疏索引的情况，查询2对应创建稀疏索引的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$ne"</span>:<span class="number">23</span>&#125;&#125;) <span class="comment">// 查询1，未创建稀疏索引</span></span><br><span class="line">db.mycollection.find(&#123;<span class="string">"age"</span>:&#123;<span class="string">"$ne"</span>:<span class="number">23</span>&#125;&#125;) <span class="comment">// 查询2</span></span><br></pre></td></tr></table></figure>

<p>查询结果如下，查询2没有查询到文档，这是因为<strong>建立了稀疏索引后，查询只根据索引查询，不再全表扫描，因此，会遗漏那些没有索引键的文档。</strong>如果一定要获取与查询1相同的结果，通过<code>hint</code>命令指明不使用索引，执行全表扫描。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询1的查询结果</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>&#125;</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"bob"</span>, <span class="string">"addresss"</span>:<span class="string">"sz"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询2的查询结果</span></span><br><span class="line"><span class="comment">// nothing...</span></span><br></pre></td></tr></table></figure>

<h1 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h1><p>TTL（Time-to-live index）索引指具有生命周期的索引，这种索引会为文档设置一个超时时间，一旦文档存活时间超过该时间就会被删除。这种类型的索引可以用在：消息日志、服务器会话等具有时效性的场景。</p>
<p>在<code>&quot;createdTime&quot;</code>字段上创建TTL索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.createIndex(&#123;<span class="string">"createdTime"</span>:<span class="number">1</span>&#125;, <span class="string">"expireAfterSecs"</span>: <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>)</span><br></pre></td></tr></table></figure>

<p><code>&quot;createdTime&quot;</code>字段必需是日期类型，一般设置为当前时间，</p>
<p>​        记录被删除的时间点=<code>&quot;createdTime&quot;</code>字段对应的时间点+<code>&quot;expireAfterSecs&quot;</code>对应的单位为秒的时间段</p>
<p>为了避免活跃的会话被删除，可以在会话上有活动发生时，更新<code>&quot;createdTime&quot;</code>为当前时间。</p>
<p>一个集合上可以创建多个TTL索引。</p>
<h1 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h1><p>与Mysql一样，MongoDB也支持全文检索。创建全文索引的开销较大，MongoDB本身就很耗内存，在一个操作频繁的集合上创建全文索引更容易导致内存不足，全文本索引的集合写入性能更差、分片时迁移速度更慢，一般的，如果不是特别强烈的业务需要，不建议使用全文索引。</p>
<p>在<code>&quot;mytext&quot;</code>字段上创建全文索引：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"mytext"</span>:<span class="string">"text"</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>使用全文索引检索关键字<code>&quot;keyword&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">"keyword"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h1><p>MongoDB支持几种类型的索引，最常见的是2dsphere索引（用于球面图）和2d索引（用于平面图）。这里只简单介绍下这两种索引的创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"myloc"</span>:<span class="string">"2dsphere"</span>&#125;)</span><br><span class="line">db.mycollection.ensureIndex(&#123;<span class="string">"myloc"</span>:<span class="string">"2d"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>如果数据库中已有大量数据，此时建立索引将会导致大量的IO操作（内存，磁盘读写），耗时较长。MongoDB提供了2种方式：foreground和background。</p>
<ul>
<li>foreground即前台操作，它会阻塞用户对数据的读写操作直到index构建完毕，即任何需要获取read、write锁的操作都会阻塞，默认情况下为foreground；</li>
<li>background即后台模式，不阻塞数据读写操作，独立的后台线程异步构建索引，此时仍然允许对数据的读写操作；<strong>其中background比foreground更加耗时。</strong></li>
</ul>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul>
<li><p>对频繁访问的查询，尽量使用覆盖索引，如果一个索引包含（或者说覆盖）所有需要查询的数据，就称为“覆盖索引”，使用覆盖索引时，需要强制不显示objectId字段。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mycollection.createIndex(&#123;<span class="string">"name"</span>, <span class="number">1</span>&#125;)</span><br><span class="line">db.mycollection.find(&#123;<span class="string">"name"</span>:bob, <span class="string">"_id"</span>:<span class="number">0</span>&#125;) <span class="comment">// 0表示不显示该字段</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选用差异性较强的字段作为索引，不要选用类似于性别、国家这种字段作为索引键。</p>
</li>
<li><p>需要哪些字段查询哪些字段，尽量不要查询整个文档</p>
</li>
<li><p>使用hint强制使用特定的索引</p>
</li>
<li><p>使用explain对比分析多种查询方式的性能</p>
</li>
</ul>
<h2 id="写操作优化"><a href="#写操作优化" class="headerlink" title="写操作优化"></a>写操作优化</h2><ul>
<li>尽量不要创建过多的索引，索引会增加该集合写入、更新、删除的开销，因为要额外维护索引</li>
<li>合理设置journal相关参数，journal日志实现日志预写功能，开启journal保证了数据持久化，但也会存在一定的性能消耗，合理的设置commitIntercalMs控制journal写入磁盘的频率，该参数过大，影响MongoDB写操作的性能，该参数过小，MongoDB意外宕机期间预写日志未持久化的可能增大。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/ MongoDB系列（二）MongoDB存储引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ MongoDB系列（二）MongoDB存储引擎/" itemprop="url">MongoDB系列（二）MongoDB存储引擎</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T00:00:00+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MongoDB 2.6版本之前（包括2.6），只有一种存储引擎：MMAP（Memory mapping，内存映射引擎）。MongoDB 3.0以后，MMAP升级为MMAPv1， 同时提供了插件式引擎API，引入wiredTiger，mongoDB 3.2默认使用WiredTiger引擎，MongoDB 4.0版本删除了MMAP引擎。</p>
<h1 id="MMAPv1引擎"><a href="#MMAPv1引擎" class="headerlink" title="MMAPv1引擎"></a>MMAPv1引擎</h1><p>常规的文件系统操作（调用read等函数）为了提高读写效率和保护磁盘，采用的是页缓存机制，读文件时需要先将文件页从磁盘拷贝至页缓存中，页缓存处在内核空间，不能被用户进程直接寻址，还需要将页缓存中的数据再次拷贝到内存对应的用户空间中，所以需要通过两次数据拷贝的过程，才能完成进程对文件内容的获取。</p>
<p>在MMAP操作文件时，创建新的虚拟存储区域，建立文件磁盘地址与虚拟地址的映射关系，<strong>此时MMAP只是在虚拟内存分配了地址空间，所以32位的机器，最多支持2GB的文件映射</strong>。之后访问数据时，通过已建立好的映射关系,只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/MMAP%E6%98%A0%E5%B0%84.png" alt="img"></p>
<p>在MongoDB的MMAPv1引擎机制中，服务器启动时，其内存对所有数据文件进行映射，接下来<strong>完全由操作系统负责将数据刷新到磁盘，以及管理内存中数据页的交换</strong>。</p>
<h2 id="MMAPv1引擎的命名空间与区段"><a href="#MMAPv1引擎的命名空间与区段" class="headerlink" title="MMAPv1引擎的命名空间与区段"></a>MMAPv1引擎的命名空间与区段</h2><p>MMAPv1引擎中，每个数据库由一个.ns文件和若干数据文件组成，数据文件从0开始编号，mydb.0、mydb.1、mydb.2等，文件大小从64MB起，依次倍增，最大为2GB。这一特性使得较小的数据库不会浪费过多的空间，而较大的数据库可使用连续的磁盘空间。图中，mydb.1、mydb.2、mydb.3（为便于理解，此处省略了mydb.0）分别是数据库mydb的三个数据文件，mydb.ns的文件用于保存mydb数据库的命名空间元数据，图中未给出。</p>
<p>每个数据库包含多个命名空间（namespace），存放在.ns文件中，单个命名空间128字节，数据库按照命名空间进行组织，每个命名空间中存放特定集合的数据，<strong>集合中的文档、索引都拥有自己的命名空间</strong>。mydb.ns文件实际是一个hash表，用于快速定位某个namespace的起始位置。</p>
<p>如下图，数据库mydb包含了两个集合c1、c2，对应<strong>两个命名空间mydb.c1、mydb.c2</strong>，mydb.$freelist是一个特殊的命名空间，用于跟踪记录不再使用的区段（如被删除的集合或索引所在的区段），最后，还有一个预分配命名空间。</p>
<p>每个命名空间的数据可以在磁盘上分为几组数据，即区段。这几个区段在磁盘上未必是连续的（图例中不连续）。</p>
<p>MongoDB也会预分配数据文件，数据文件一旦被填满，就开始预分配，这意味着MongoDB服务器总会为每个数据库维护一个额外的空白数据文件（如图中的mydb.3），以提前避免文件分配失败。使用 <code>-- noprealloc</code>选项可以关闭预分配功能。</p>
<p>mydb.1、mydb.2，分成了分属于不同命名空间的区段，mydb.1有三个区段、mydb.2有四个区段、mydb.3只有一个区段，该区段属于预分配空间。在为命名空间分配一个新的区段时，会先搜索空闲列表mydb.$freelist，查看是否存在合适大小的区段。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8C%BA%E6%AE%B5.png" alt="1566543786631"></p>
<p>前面提到，mydb.ns是一个hash表，一个namespace对应一个集合或索引，该hash表中，一个节点元数据结构如下，每个节点628字节，16MB的.ns文件最多存储26715个namespace。哈希碰撞的概率也较低，采用的线性探针的方式解决哈希冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Namespace key;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line">    NamespcaeDetails value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>key为namespace的名字，固定分配128字节的空间</li>
<li>hash为namespace的hash值</li>
<li>value包含该namespace的所有元数据，定义如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamespaceDetails</span> &#123;</span></span><br><span class="line">    DiskLoc firstExtent; <span class="comment">// 第一个区段</span></span><br><span class="line">    DiskLoc lastExtent; <span class="comment">// 最后一个区段</span></span><br><span class="line">    <span class="comment">// 不同大小的删除列表</span></span><br><span class="line">    DiskLoc deletedListSmall[SmallBuckets];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskLoc</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _a; <span class="comment">// 数据文件编号，mydb.1编号为1，定位文件</span></span><br><span class="line">    <span class="keyword">int</span> ofs; <span class="comment">// 文件内部偏移量，定位文件内部的存储位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>firstExtent描述了第一个区段的位置</li>
<li>lastExtent描述了最后一个区段的位置</li>
<li>deletedList描述了各个被删除的元素</li>
</ul>
<p>通过这些信息，可以遍历一个namespace下的所有区段的有效数据，区段的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Extent</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> magic; <span class="comment">// 魔法数，校验合法性</span></span><br><span class="line">    DiskLoc myLocation; <span class="comment">// extent自身位置指针</span></span><br><span class="line">    DiskLoc next; <span class="comment">// 下一个extent位置指针</span></span><br><span class="line">    DiskLoc pre; <span class="comment">// 上一个extent位置指针</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">// extent长度</span></span><br><span class="line">    DiskLoc firstRecord; <span class="comment">// extent内第一个record位置指针</span></span><br><span class="line">    DiskLoc lastRecord; <span class="comment">// extent内最后一个record位置指针</span></span><br><span class="line">    <span class="keyword">char</span> _extentData[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> _len;</span><br><span class="line">    <span class="keyword">int</span> _extentOfs;</span><br><span class="line">    <span class="keyword">int</span> _nextOfs;</span><br><span class="line">    <span class="keyword">int</span> _preOfs;</span><br><span class="line">    <span class="keyword">char</span> _data[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record 被删除后，以deletedRecord存储</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeletedRecord</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> _len;  <span class="comment">// record长度</span></span><br><span class="line">   <span class="keyword">int</span> _extentOfs; <span class="comment">// record所在的extent位置指针</span></span><br><span class="line">   DiskLoc _nextDeleted; <span class="comment">// 下一个已删除记录的位置</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>一条record对应mongoDB的一个文档，即一条数据记录。同一个区段（extent）下的所有<strong>record以双向链表的形式组织</strong>，record 被删除后，以deletedRecord存储，<strong>deletedRecord以单向链表的形式组织</strong>。</p>
<h2 id="MMAPv1引擎CRUD"><a href="#MMAPv1引擎CRUD" class="headerlink" title="MMAPv1引擎CRUD"></a>MMAPv1引擎CRUD</h2><p><strong>写入</strong></p>
<p>1、检查namespaceDetail中的deletedList中是否有合适的deletedRecord可以利用，如果有，则删除该记录并复用删除空间。</p>
<p>2、检查数据文件的<strong>$freelist</strong>里是否有大小合适的不再使用的区段，如果有则复用该空间</p>
<p>3、第1、2步均不成功，创建新的区段，如果当前数据文件没有足够空间创建新区段，创建新数据文件。</p>
<p><strong>删除</strong></p>
<p>删除的记录会以DeleteRecord的形式插入到对应集合的删除链表里，删除的空间在下一次写入新的记录时可能会被利用上；但也有可能一直用不上而浪费。比如某个128Bytes大小的记录被删除后，接下来写入的记录一直大于128B，则这个128B的DeletedRecord不能有效的被利用。当删除很多时，可能产生很多不能重复利用的”存储碎片”，从而导致存储空间大量浪费；<strong>可通过compact命令整理碎片。</strong>该命令会持有数据库级别的锁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand ( &#123; <span class="attr">compact</span>: <span class="string">'&lt;collection&gt;'</span> &#125; )</span><br></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<p>更新跟删除类似，也有可能产生很多存储碎片</p>
<ul>
<li>更新的Record比原来小，可以直接复用现有的空间（原地更新）；多余的空间如果足够多，会将剩余空间插入到DeletedRecord链表；</li>
<li>更新的Record比原来大，更新相当于删除 + 新写入，原来的空间会插入到DeletedRecord链表里。文档需要移动到文件中的其他位置，这种因更新导致的文档位置移动会严重降低写入性能，因为一旦文档移动，集合中的所有索引都要同步修改文档新的存储位置，<strong>可通过设置填充因子（paddingFactor）进行优化</strong>，比如：如果填充因子为2，一个大小为200字节的文档插入是，会自动在文档后填充100个字节的空间，这样在更新时，会使用第一种方式（更新的record比原来小）。</li>
</ul>
<p><strong>查询</strong></p>
<p>没有索引的情况下，查询某个Record需要遍历整个集合，读取出符合条件的Record；如果经常需要根据每个纬度查询Record，则需要给集合建立索引以提供查询效率。</p>
<h2 id="MMAPv1引擎锁粒度"><a href="#MMAPv1引擎锁粒度" class="headerlink" title="MMAPv1引擎锁粒度"></a>MMAPv1引擎锁粒度</h2><p>MMAPv1 3.0版本之前锁粒度是库，3.0版本后所粒度是集合，即表级锁，不支持事务，原子操作是文档的保存、修改、删除。</p>
<h1 id="WiredTiger引擎"><a href="#WiredTiger引擎" class="headerlink" title="WiredTiger引擎"></a>WiredTiger引擎</h1><p>mongoDB 3.2设置wiredTiger为默认的存储引擎（之前版本默认MMAPv1），WiredTiger存储引擎负责将写操作写入cache（<strong>B树结构</strong>），满足条件后持久化（默认条件每隔60s或达到2GB）</p>
<p>与MMAPv1一样，journal日志（<strong>预写式日志，write ahead log，WAL</strong>）用于数据恢复。对于write操作，首先被持久写入journal，然后在内存中保存变更数据，<strong>条件满足后提交一个新的检测点checkpoint</strong>，即检测点之前的数据只是在journal中持久存储，但并没有在mongodb的数据文件中持久化，延迟持久化可以提升磁盘效率，如果在提交checkpoint之前，mongodb异常退出，此后再次启动可以根据journal日志恢复数据。，如果60s内机器宕机，且未开启journal日志，会丢失这60s的数据。journal日志默认每100毫秒同步磁盘一次，每100M数据生成一个新的journal文件，journal默认使用了snappy压缩，检测点创建后，此前的journal日志即可清除。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="1566802633253"></p>
<h2 id="WiredTiger引擎文件空间分配"><a href="#WiredTiger引擎文件空间分配" class="headerlink" title="WiredTiger引擎文件空间分配"></a>WiredTiger引擎文件空间分配</h2><p>MMAPv1引擎中，集合和索引都以命名空间的方式混合存储在数据库文件中mydb.1、mydb.2等，同一个数据库文件存在多个集合的数据，例如mydb.1保存了集合c1、c2，即便删除了某个集合或索引，其占用的磁盘空间也会产生碎片难易清除。文件的存储级别是<strong>数据库级别</strong></p>
<p>WiredTiger引擎中，文件的存储级别是<strong>集合和索引级别</strong>。将每个数据库中的所有集合和索引分别存储在单独的文件中，删除了集合或索引后，对应的文件自动清除，磁盘回收效率更高。</p>
<p>data/db目录下的文件如下：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E6%96%87%E4%BB%B6%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D1.png" alt="1566795516284"></p>
<p>整体的目录结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="1566796884855"></p>
<ul>
<li>collection.wt存储集合信息，以编号不同区分，collection1.wt、collection2.wt</li>
<li>index.wt存储索引信息，编号区分</li>
<li>WiredTiger.lock定义锁操作</li>
<li>WiredTiger.wt 存储collection.wt与index.wt的元数据</li>
<li>WiredTiger.turtle 存储WiredTiger.wt 元数据</li>
<li>journal 目录 存储journal日志</li>
</ul>
<h2 id="WiredTiger引擎存储模型"><a href="#WiredTiger引擎存储模型" class="headerlink" title="WiredTiger引擎存储模型"></a>WiredTiger引擎存储模型</h2><p>WiredTiger在执行写入任务时，不是直接写入到磁盘，首先写入的是cache，然后批量持久化，这也是MongoDB吃内存的主要原因，cache中使用B树保存数据，每个B树对应磁盘上的一个物理文件，树节点对应一个内存页、硬盘块，<strong>所以根节点与内部节点均会用于存储数据</strong>，目的是尽可能减少磁盘IO从而提高性能。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="1566801831809"></p>
<p>cache中的一个Page对应磁盘上的一个Extent（Mysql Innodb是1对4的关系），Extent大小为4K，存储了一系列键值对。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger-Page.png" alt="1566869294605"></p>
<h3 id="WiredTiger引擎更新、插入、删除"><a href="#WiredTiger引擎更新、插入、删除" class="headerlink" title="WiredTiger引擎更新、插入、删除"></a>WiredTiger引擎更新、插入、删除</h3><ul>
<li>遍历B树，找到待更新的页（如果cahce中没有热数据，从磁盘中获取，生成一个WT_ROW）</li>
<li>如果有必要，生成预写日志</li>
<li>在待更新的页执行更新、插入、删除操作</li>
</ul>
<p>当对某个键的值进行更新、删除时，将创建一个用于更新的结构，包含了事务id、已更改数据、指向后续更新的指针，之后的更新会将自己添加到前一个结构的末尾，随着时间的推移创建一个不同版本值的链式结构，N次更新组成长度为N的linkedlist。</p>
<p>当进行插入时，生成一个skip linkedlist用于保存插入的信息，N次插入生成长度为N的保存了各skip linkedlist头信息的linkedlist—WT_INSERT_HEAD。</p>
<h3 id="Copy-on-write"><a href="#Copy-on-write" class="headerlink" title="Copy on write"></a>Copy on write</h3><p>WiredTiger引擎采用Copy on write的方式管理修改操作（insert、update、delete），修改操作会先缓存在cache里，持久化时，<strong>修改操作不会在原来的leaf page上进行，而是写入新分配的page，每次checkpoint都会产生一个新的Root Page</strong>。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WireTiger%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0.png" alt="1566804600903"></p>
<p>与MMAPv1引擎类似，当一个文档被删除时，WiredTiger不会立即归还该空间，会在后续的删除、更新、插入操作中优先复用该空间，可能会存在碎片，但影响不大，如果要整理碎片，可以调用compact命令。</p>
<h2 id="为什么WiredTiger引擎使用B树而不是B-树"><a href="#为什么WiredTiger引擎使用B树而不是B-树" class="headerlink" title="为什么WiredTiger引擎使用B树而不是B+树"></a>为什么WiredTiger引擎使用B树而不是B+树</h2><p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/B%E6%A0%91.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/B+%E6%A0%91.png" alt="img"></p>
<p>B树与B+树的简要图如上，二者最大的区别就是B树所有节点都用来存储key+data，而B+树只有叶子节点存储key+data，根节点与中间节点保存的是key的副本，相应的页存储的是key+指针，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</p>
<p><strong>无论是MongoDB选择B树，还是Mysql的InnoDB、MyIsam引擎选择B+树，目的都是尽可能减少磁盘IO。</strong></p>
<p>MongoDB是一种聚合型数据库，它组织数据的特点就是将经常访问的数据放在一块（同一个JSON下包含所有信息），对于单个查询能够在与数据库的一次交互中将所有数据全部取出来，对于上图中key为37的数据，无论是B树还是B+树，都是3次IO，而对于key为50的数据，使用B树只需要1次IO，使用B+树需要3次IO。</p>
<p>而Mysql是关系型数据库，使用B+树提高根节点和内部节点存放的信息量（由于内节点无 data 域，每个节点能索引的范围更大更精确），从而减少查询次数，达到减小磁盘IO的目的。最重要的是，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历，然而，MongoDB很少有区间访问的需求，也就没有这种磁盘预读机制的需求。</p>
<h2 id="WiredTiger引擎锁粒度"><a href="#WiredTiger引擎锁粒度" class="headerlink" title="WiredTiger引擎锁粒度"></a>WiredTiger引擎锁粒度</h2><p>WiredTiger的锁粒度为文档，对应Mysql的行级锁。</p>
<h2 id="WiredTiger引擎4-0——事务"><a href="#WiredTiger引擎4-0——事务" class="headerlink" title="WiredTiger引擎4.0——事务"></a>WiredTiger引擎4.0——事务</h2><p>mongoDB对一个文档的写操作，会产生三个动作：</p>
<ul>
<li>对存储数据的Btree执行写操作</li>
<li>对存储索引的Btree执行写操作</li>
<li>对oplog（option log，与预写日志不是一回事，一个是已发生的，一个是将要发生的）执行写操作</li>
</ul>
<p>MongoDB的单文档事务指：上述三个动作的更新是原子的，处于同一个事务中。不存在<strong>索引段中的某个RecordId，在数据段中找不到</strong>，也不存在<strong>一条记录的更改被应用，但是没有记录到oplog中</strong>, 反之亦然。</p>
<p>MongoDB  4.0提供了事务API，开始支持事务操作。它的事务是基于快照SANPSHOT、MVCC（Multi-Version Concurrency Control，多版本并发控制）实现的。</p>
<h3 id="sanpshot"><a href="#sanpshot" class="headerlink" title="sanpshot"></a>sanpshot</h3><p>snapshot即快照。事务开始时，对整个WiredTiger内部正在执行或将要执行的所有事务进行一次截屏，保存当时整个引擎所有事务的状态。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/WiredTiger%E4%BA%8B%E5%8A%A1.png" alt="1566873597953"></p>
<p>snapshot_object保存了快照信息。</p>
<ul>
<li>snap_min 最小执行事务</li>
<li>snap_max 最大执行事务</li>
<li>snap_array 位于snap_min与snap_max之间正在执行的事务，是不可见的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snapshot_object = &#123;</span><br><span class="line">    snap_min=T1,</span><br><span class="line">    snap_max=T5,</span><br><span class="line">	snap_array=&#123;T1, T4, T5&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>凡是出现在snap_array中或事务ID&gt;snap_max的事务均是不可见的。</strong>即便建立snapshot之后T1、T4、T5提交了，T6也无法访问的T1、T4、T5的修改。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC基于事务ID和记录值实现一个链表，新的事务与相应的修改value，插入链表头部，链表中的节点定义抽象如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wt_mvcc&#123;</span><br><span class="line">	transaction_id:    本次修改事务的ID	</span><br><span class="line">	value:             本次修改后的值</span><br><span class="line">    next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取值时从链表头开始，根据snapshot来判断是否可读，如果不可读，向链表尾方向移动，直到找到第一个能够读的数据版本，下图中，读事务T5与读事务T3均会读到V1。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/MVCC.png" alt="1566880968502"></p>
<h3 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h3><p>传统的数据库事务隔离分为:Read-Uncommited(未提交读)、Read-Commited(提交读)、Repeatable-Read(可重复读)和Serializable(串行化)，WiredTigerT引擎并没有按照传统的事务隔离实现这四个等级，而是基于snapshot的特点实现了下列事务隔离方式：</p>
<ul>
<li>Read-Uncommited</li>
<li>Read-Commited</li>
<li>snapshot-Isolation(快照隔离)</li>
</ul>
<p><strong>Read-Uncommited</strong></p>
<p>又称为脏读，是最低的隔离级别，<strong>总是读取到系统中最新的修改（包括未提交）</strong>。WiredTiger的实现方式很简单，将snap_array置为空即可。在上图中，隔离级别设置为脏读后，事务T5读取到的值为V4。一般数据库不会设置成这种隔离方式，它违背了事务的ACID的特性。</p>
<p><strong>Read-Commited</strong></p>
<p>又称为幻读，<strong>总是读取到最新的、已提交的修改</strong>。这种隔离级别可能在一个长事务多次读取一个值的时候前后读到的值可能不一样。</p>
<p>假设上图中的T5包含了两次读操作，中间sleep了2s，在这2s内T4提交了，则事务T5中，第一次读到的值为V1，第二次读到的值为V4。</p>
<p><strong>snapshot-Isolation(快照隔离)</strong></p>
<p>只在事务开始时生成一次快照，无论事务持续的过程中其他事务修改了几次值，该快照都不改变，<strong>所以值在整个事务执行过程中只有一个版本</strong>。</p>
<p>事务T4的修改对T5不可见，如果T5也是一个写事务，在T5开始时，T4未提交，T5执行过程中，T4提交了，T5再去修改值，会产生失败回滚。这样做的目的是防止忽略不可见数据的修改。</p>
<h3 id="与Mysql事务的区别"><a href="#与Mysql事务的区别" class="headerlink" title="与Mysql事务的区别"></a>与Mysql事务的区别</h3><p>通过上面对三种事务隔离方式的分析，<strong>WiredTiger并没有使用传统的事务独占锁和共享访问锁来保证事务隔离</strong>，而是通过对系统中<strong>写事务的snapshot截屏来实现</strong>。这样做的目的是在<strong>保证事务隔离的情况下又能提高系统事务并发的能力</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/MongoDB系列（一）MongoDB简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/MongoDB系列（一）MongoDB简介/" itemprop="url">MongoDB系列（一）MongoDB简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T00:00:00+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MongoDB是一款强大、灵活、易于扩展的、由C++编写的聚合型、文档型、NoSQL数据库，支持二级索引、范围查询、排序、聚合、地理空间索引等功能。</p>
<p>MongoDB是面向文档的数据库，不是关系型数据库，不采用关系模型是为了更好的扩展性。与关系型数据库相比，有以下特点：</p>
<ul>
<li>没有“一行数据”的概念，取而代之的是“一条文档”</li>
<li>不再有预定义模式，文档的键和值不再是固定的类型和大小，可以随意扩展。</li>
<li>易于扩展，随着数据的增长，横向扩展（增加机器）变得更加方便，MongoDB能够自动处理跨集群的数据和负载，自动重新分配文档、自动将用户请求路由至正确的机器上。</li>
<li>功能丰富，支持索引、聚合、文件存储、以及特殊集合，如会过期的数据：日志、会话等。</li>
<li>性能更强，4.0版本前不支持事务，但提供了诸多原子操作：文档的保存、修改、删除。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/NoSQL.png" alt="img"></p>
<h1 id="文档与集合"><a href="#文档与集合" class="headerlink" title="文档与集合"></a>文档与集合</h1><p>文档是MongoDB中数据的基本单元，类似于关系型数据库管理系统中的行，但灵活性更高。例如：</p>
<p><code>{&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:20}</code></p>
<p>集合是一组文档，可以看做是一个拥有动态模式的表。因此，MongoDB中的文档没有预定义模，一个集合中可以保存多个完全不同的文档，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  &#123;<span class="string">"name"</span>:<span class="string">"xiaoming"</span>, <span class="string">"age"</span>:<span class="number">20</span>&#125;</span><br><span class="line"><span class="number">2</span>  &#123;<span class="string">"name"</span>:<span class="string">"xiaohei"</span>, <span class="string">"age"</span>:<span class="number">20</span>, <span class="string">"man"</span>:<span class="literal">true</span>, <span class="string">"address"</span>:<span class="string">"sz"</span>&#125; </span><br><span class="line"><span class="number">3</span>  &#123;<span class="string">"device"</span>:<span class="string">"rcu"</span>,<span class="string">"devId"</span>:<span class="string">"1234567890"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>备注：集合命名时，不能有空字符串、不能包含\0、不能包含$、不能以system.开头</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>多个集合组成一个数据库、一个MongoDB实例包含多个数据库，每个数据库拥有独立的权限，在磁盘上，不同的数据库放置在不同的文件夹中，一般的，一个应用程序使用一个数据库。</p>
<p>有三个数据库是默认保留的：admin（root库）、local（用于副本集模式）、config（用于分片模式）</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MongoDB的文档与JavaScript中对象相近，类似于JSON，MongoDB支持JSON包含的6种数据类型：null、布尔型、数值、字符串、数组、对象，MongoDB还添加了其他一些数据类型：日期、正则表达式、数组、内嵌文档、对象id、二进制数据、JavaScript代码。</p>
<p>下面只介绍：日期、数组、内嵌文档、对象id。</p>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>对应JAVA、JS中的Date类，存入数据库的是Date对象，不是日期字符串。数据库中存储的日期为新纪元以来的毫秒数，并未存储时区，Date对象与毫秒之间的转换，由MongoDB负责，客户端不需要关心。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与JAVA数组不同的是，数组可以包含不同类型的元素，数组可以嵌套数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"things"</span>:[<span class="string">"apple"</span>, <span class="number">3.1415926</span>]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h2><p>文档可以作为键的值，这样的文档就是内嵌文档。类似于JSON嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"things"</span>:&#123;</span><br><span class="line">    	<span class="string">"name"</span>:<span class="string">"apple"</span></span><br><span class="line">        <span class="string">"price"</span>:<span class="number">3.14</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="objectId"><a href="#objectId" class="headerlink" title="objectId"></a>objectId</h2><p>MongoDB存储的文档必需有一个”_id“键，这个键可以是任意类型，默认是个ObjectId对象。objectId作为文档的唯一标识符。如果插入文档时，没有设置objectId，MongoDB客户端驱动会自动创建一个。</p>
<p>object_id大小为12字节，是一个由24个十六进制数字组成的字符串。</p>
<p><img src="https://raw.githubusercontent.com/okspy/image/master/mongodb/OBJECT_ID.png" alt="1566887583799"></p>
<ul>
<li><p>时间戳：占用前4个字节，从标准纪元开始的时间戳，单位为秒，</p>
</li>
<li><p>机器标识位：占用3个字节，是所在主机名的唯一标识，通常是机器名的hash值。</p>
</li>
<li><p>PID：产生 objectId的进程的ID</p>
</li>
<li><p>计数器： 前9个字节保证了同一秒钟不同机器不同进程的ObjectId是唯一的，最后三个字节用来确保同一秒同机器同进程的objectId的唯一性。所以每个进程同一秒最多允许产生<br>$$<br>（2^8)^3=16777216<br>$$<br>个不同的objectId。对于服务器来说，1600W个足够用了。</p>
</li>
</ul>
<p>从objectId的设计可以看出，MongoDB的设计初衷就是用作分布式数据库，能够在副本集、分片环境下生成全局唯一id。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列(四)MessageConvert/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列(四)MessageConvert/" itemprop="url">springboot+RabbitMQ系列（四）MessageConvert</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-13T00:00:00+08:00">
                2019-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可以为<code>ListenerContainer</code>和<code>RabbitTemplate</code>设置<code>MessageConverter</code>。这样就不用每次都写重复的消息格式转换代码了。spring提供的Message Converter均是双向的，负责将入站消息转换为特定结构（如：字节数组、序列化java对象、字符串、自定义的消息domain对象），将特定格式转换为出站消息。</p>
<h1 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h1><p>springboot-amqp涉及到两种消息格式，定义如下：</p>
<ol>
<li><p>org.springframework.messaging.Message&lt;?&gt; message，spring框架中通用的Message。简称<code>spring-messaging Message</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">		<span class="function">T <span class="title">getPayload</span><span class="params">()</span></span>;    </span><br><span class="line">		<span class="function">MessageHeaders <span class="title">getHeaders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>spring AMQP Message</code>，spring为了适配AMQP协议，简化接口参数引入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>spring-messaging Message</code>中的<code>payload</code>对应了<code>spring AMQP Message</code>中的<code>byte[] body</code>，他们均是Rabbit Client 中的body，即消息内容。</p>
<p><code>spring-messaging Message</code>中的<code>MessageHeaders</code>对应了<code>spring AMQP Message</code>中的<code>MessageProperties</code>，他们均是Rabbit Client 中的<code>BasicProperties</code>，即消息头。</p>
<p>因此，后文的MessgeConverter如不加特殊说明，均指的消息内容的格式转换。消息头的格式转换见<code>2.3.7 MessagePropertiesConverter</code></p>
<h1 id="RabbitListener底层实现原理"><a href="#RabbitListener底层实现原理" class="headerlink" title="@RabbitListener底层实现原理"></a>@RabbitListener底层实现原理</h1><p>在了解MessageConveter之前，有必要清楚spring底层消息处理机制，此处以最常用的<code>@RabbitListener</code>为例。</p>
<p>通过注解<code>@RabbitListener</code>声明一个消费者时，底层由<code>MessagingMessageListenerAdapter</code>的<code>onMessage()</code>负责处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message amqpMessage, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    org.springframework.messaging.Message&lt;?&gt; message = </span><br><span class="line"><span class="number">4</span>        <span class="keyword">this</span>.toMessagingMessage(amqpMessage);    </span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">6</span>    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;        </span><br><span class="line"><span class="number">7</span>        <span class="keyword">this</span>.logger.debug(<span class="string">"Processing ["</span> + message + <span class="string">"]"</span>);    </span><br><span class="line"><span class="number">8</span>    &#125;</span><br><span class="line"><span class="number">9</span>    </span><br><span class="line"><span class="number">10</span>    <span class="keyword">try</span> &#123;        </span><br><span class="line"><span class="number">11</span>        Object result = <span class="keyword">this</span>.invokeHandler(amqpMessage, channel, message);        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">13</span>            <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);        </span><br><span class="line"><span class="number">14</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">15</span>            <span class="keyword">this</span>.logger.trace(<span class="string">"No result object given - no result to handle"</span>);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException var7) &#123;       </span><br><span class="line"><span class="number">18</span>        ListenerExecutionFailedException e = var7;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">try</span> &#123;               </span><br><span class="line"><span class="number">21</span>                Object result = <span class="keyword">this</span>.errorHandler.handleError(amqpMessage, message, e); <span class="number">22</span>               </span><br><span class="line"><span class="number">23</span>                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;                    </span><br><span class="line"><span class="number">24</span>                    <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);           <span class="number">25</span>  </span><br><span class="line"><span class="number">26</span>                &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line"><span class="number">27</span>                    <span class="keyword">this</span>.logger.trace(<span class="string">"Error handler returned no result"</span>);             <span class="number">28</span>  </span><br><span class="line"><span class="number">29</span>                &#125;            </span><br><span class="line"><span class="number">30</span>            &#125; <span class="keyword">catch</span> (Exception var6) &#123;                </span><br><span class="line"><span class="number">31</span>                <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var6, var6);         <span class="number">32</span>  </span><br><span class="line"><span class="number">33</span>            &#125;        </span><br><span class="line"><span class="number">34</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">35</span>            <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var7.getCause(), var7);   <span class="number">36</span>     </span><br><span class="line"><span class="number">37</span>        &#125;    </span><br><span class="line"><span class="number">38</span>    &#125;</span><br><span class="line"><span class="number">39</span> &#125;</span><br></pre></td></tr></table></figure>

<p>3~4行，通过<code>toMessagingMessage()</code>将spring AMQP的Message转换为spring-messaging的Message。<code>this.getMessagingMessageConverter</code>是一个内部类的实例，内部类继承了<code>MessagingMessageConverter</code>，最终调用的是<code>MessagingMessageConverter</code>的<code>fromMessage</code>。完成Spring AMQP Message至spring-messaging Message的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> org.springframework.messaging.Message&lt;?&gt; toMessagingMessage(Message amqpMessage) &#123;    </span><br><span class="line">    <span class="keyword">return</span> (org.springframework.messaging.Message)<span class="keyword">this</span></span><br><span class="line">        .getMessagingMessageConverter()</span><br><span class="line">        .fromMessage(amqpMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fromMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        Map&lt;String, Object&gt; mappedHeaders = </span><br><span class="line">            <span class="keyword">this</span>.headerMapper.toHeaders(message.getMessageProperties()); </span><br><span class="line">        </span><br><span class="line">        Object convertedObject = <span class="keyword">this</span>.extractPayload(message);  </span><br><span class="line">        </span><br><span class="line">        MessageBuilder&lt;Object&gt; builder = convertedObject <span class="keyword">instanceof</span> </span><br><span class="line">            org.springframework.messaging.Message ? </span><br><span class="line">       MessageBuilder.fromMessage((org.springframework.messaging.Message)convertedObject) </span><br><span class="line">            : MessageBuilder.withPayload(convertedObject);        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11行通过反射处理消息，调用的是<code>HandlerAdapter</code>中的<code>invoke()</code>，为了简便，把这些调用全部放在了同一个代码块中，一般地，使用<code>@RabbitListener</code>时不会自定义<code>invokHandler</code>，所以调用的是代理的反射方法：<code>delegatingHandler.invoke()</code></p>
<p>再继续关注下<code>getMethodArgumentValues</code>，包含了两部分，一部分是预设参数转换，如：<code>Message</code>、<code>Channel</code>，这个也是最开始传入Spring AMQP的<code>Message</code>的原因，它的作用就是作为预设参数，另一部分是Listener中消息处理的其他自定义参数，如@Payload注解、@Headers注解等声明的参数，<code>args[i] == null</code>时，抛出<code>MethodArgumentResolutionException</code>异常，这就是1.3中异常抛出的地方，参数为空。该异常会一直向上抛，直至17行被捕获，如果在Listener容器中注册了<code>errorHandler</code>，调用<code>errorHandler</code>处理异常。</p>
<p>还有一点值得注意的是：在整个过程中，真正作为消息载体的就是<code>spring-messaging.Message</code>而不是Spring AMQP的`Message。因此，<strong>消息处理的过程实际如下：</strong></p>
<p><strong>调用RabbitMQ JAVA API接收消息并封装为<code>Spring AMQP Message</code>，在消息处理onMessage中调用<code>toMessagingMessage(Message amqpMessage)</code>将消息转换至<code>spring-messaging.Message</code>,通过反射处理消息。</strong></p>
<p><strong>因此，消息转换实际上包含了两个过程，一个是消息的反序列化并封装为<code>Spring AMQP Message</code>，另一个是<code>Spring AMQP Message</code>与<code>spring-messaging.Message</code>之间的转换。</strong>后文中所指的消息转换如果不加特别说明，均指第一个转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeHandler</span><span class="params">(Message amqpMessage, Channel channel, org.springframework.messaging.Message&lt;?&gt; message)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMethod.invoke(message, <span class="keyword">new</span> Object[]&#123;amqpMessage, channel&#125;);   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException var5) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">            ListenerExecutionFailedException(<span class="keyword">this</span>.createMessagingErrorMessage(<span class="string">"Listener         	  method could not be invoked with the incoming message"</span>,                                   message.getPayload()),             </span><br><span class="line">            var5, amqpMessage);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception var6) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">"Listener method '"</span> +                  		  <span class="keyword">this</span>.handlerMethod.getMethodAsString(message.getPayload())                               + <span class="string">"' threw exception"</span>, var6, amqpMessage);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandlerAdapter中的invoke</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.invokerHandlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokerHandlerMethod.invoke(message, providedArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.delegatingHandler.hasDefaultHandler()) &#123;</span><br><span class="line">            Object[] args = <span class="keyword">new</span> Object[providedArgs.length + <span class="number">1</span>];</span><br><span class="line">            args[<span class="number">0</span>] = message.getPayload();</span><br><span class="line">            System.arraycopy(providedArgs, <span class="number">0</span>, args, <span class="number">1</span>, providedArgs.length);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, providedArgs);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegatingHandler.invoke()</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;? extends Object&gt; payloadClass = message.getPayload().getClass();</span><br><span class="line">        InvocableHandlerMethod handler = <span class="keyword">this</span>.getHandlerForPayload(payloadClass);</span><br><span class="line">        Object result = handler.invoke(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders().get(<span class="string">"amqp_replyTo"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Expression replyTo = (Expression)<span class="keyword">this</span>.handlerSendTo.get(handler);</span><br><span class="line">            <span class="keyword">if</span> (replyTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ResultHolder(result, replyTo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理完成的invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">this</span>.getMethodArgumentValues(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Invoking '"</span> + 	 	                                                 ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(), <span class="keyword">this</span>.getBeanType())</span><br><span class="line">                              + <span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = <span class="keyword">this</span>.doInvoke(args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Method ["</span> + 				    			                             ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(),<span class="keyword">this</span>.getBeanType()) </span><br><span class="line">            + <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注下getMethodArgumentValues</span></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(Message&lt;?&gt; message, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        MethodParameter[] parameters = <span class="keyword">this</span>.getMethodParameters();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            MethodParameter parameter = parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args[i] = <span class="keyword">this</span>.resolveProvidedArgument(parameter, providedArgs);<span class="comment">//预设参数的转换</span></span><br><span class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        args[i] = <span class="keyword">this</span>.argumentResolvers</span><br><span class="line">                            .resolveArgument(parameter, message);<span class="comment">// 自定义的参数的转换</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="keyword">this</span>.getArgumentResolutionErrorMessage(</span><br><span class="line">                                <span class="string">"Failed to resolve"</span>, i), var8);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> var8;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentResolutionException(</span><br><span class="line">                        message, parameter, <span class="keyword">this</span>.getArgumentResolutionErrorMessage( </span><br><span class="line">                                            <span class="string">"No suitable resolver for"</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    <span class="keyword">return</span> args;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="已有的MessageConverter"><a href="#已有的MessageConverter" class="headerlink" title="已有的MessageConverter"></a>已有的MessageConverter</h1><p>前面提到，消息格式转换有两次，第一次转换完成序列化与反序列化的工作，被称为<code>Message Converter</code>，spring AMQP提供了默认的转换器<code>SimpleMessageConverter</code>。以反序列化为例，将Spring AMQP Message转换为字符串、序列化对象、字节数组，这次转换也是文中所指的Message Convert。反序列化源码如下：</p>
<p>第二次转换，springboot默认使用的是GenericMessageConverter。它是属于org.springframework.messaging.包下的，继承了该包下的SimpleMessageConverter（第一次转换的SimpleMessageConverter在org.springframework.amqp包下），默认情况下，不需要特别的设置。</p>
<p>spring-messaging的<code>MessageConverter</code>是所有消息转换器（无论是<code>spring-messaging</code>还是spring AMQP`）最底层的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.messaging.converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;   </span><br><span class="line">    <span class="meta">@Nullable</span>    </span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message&lt;?&gt; var1, Class&lt;?&gt; var2)</span></span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span>    Message&lt;?&gt; toMessage(Object var1, <span class="meta">@Nullable</span> MessageHeaders var2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleMessageConverter"><a href="#SimpleMessageConverter" class="headerlink" title="SimpleMessageConverter"></a>SimpleMessageConverter</h2><p>spring AMQP的<code>SimpleMessageConverter</code>实现了<code>MessageConverter</code>接口（最底层），是默认的消息转换器。在未给<code>RabbitTemplate</code>配置message conveter时，将会调用<code>SimpleMessageConverter</code>的<code>fromMessage</code>和<code>createMessage</code>处理消息，从源码可以看出，支持三种类型：字符串、序列化java对象，字节数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.support.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamClass;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.utils.SerializationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.remoting.rmi.CodebaseAwareObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMessageConverter</span> <span class="keyword">extends</span> <span class="title">WhiteListDeserializingMessageConverter</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CHARSET = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String defaultCharset = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> String codebaseUrl;    </span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageConverter</span><span class="params">()</span> </span>&#123;    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader beanClassLoader)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.beanClassLoader = beanClassLoader;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCodebaseUrl</span><span class="params">(String codebaseUrl)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.codebaseUrl = codebaseUrl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultCharset</span><span class="params">(String defaultCharset)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.defaultCharset = defaultCharset != <span class="keyword">null</span> ? defaultCharset : <span class="string">"UTF-8"</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123; </span><br><span class="line">        Object content = <span class="keyword">null</span>;        </span><br><span class="line">        MessageProperties properties = message.getMessageProperties();        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            String contentType = properties.getContentType();            </span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentType.startsWith(<span class="string">"text"</span>)) &#123;                </span><br><span class="line">                String encoding = properties.getContentEncoding();                </span><br><span class="line">                <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    encoding = <span class="keyword">this</span>.defaultCharset;                </span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    content = <span class="keyword">new</span> String(message.getBody(), encoding);                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var8) &#123;                    </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert text-based                                                            Message content"</span>, var8);         </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType != <span class="keyword">null</span> </span><br><span class="line">                       &amp;&amp; contentType.equals(<span class="string">"application/x-java-serialized-object"</span>)) &#123;                </span><br><span class="line">              		<span class="keyword">try</span> &#123;                    </span><br><span class="line">                        content = SerializationUtils</span><br><span class="line">                            .deserialize(<span class="keyword">this</span>.createObjectInputStream(</span><br><span class="line">                       <span class="keyword">new</span> ByteArrayInputStream(message.getBody()),<span class="keyword">this</span>.codebaseUrl));                &#125; <span class="keyword">catch</span> (IllegalArgumentException                                                                 | IllegalStateException                                                                   | IOException var7) &#123;                    </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert                                                           serialized Message content"</span>, var7);       </span><br><span class="line">                    &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            content = message.getBody();        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> content;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Message <span class="title">createMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span> </span></span><br><span class="line"><span class="function">                                                    <span class="keyword">throws</span> MessageConversionException </span>&#123;        </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;            </span><br><span class="line">            bytes = (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])object);            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/octet-stream"</span>);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = ((String)object).getBytes(<span class="keyword">this</span>.defaultCharset);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var6) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to Message                                                             content"</span>, var6);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"text/plain"</span>);           </span><br><span class="line">            messageProperties.setContentEncoding(<span class="keyword">this</span>.defaultCharset);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Serializable) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = SerializationUtils.serialize(object);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to serialized                                                          Message content"</span>, var5);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/x-java-serialized-object"</span>);        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            messageProperties.setContentLength((<span class="keyword">long</span>)bytes.length);            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(bytes, messageProperties);        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" only                            supports String, byte[] and Serializable payloads, received: "</span> + </span><br><span class="line">                                               object.getClass().getName());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">createObjectInputStream</span><span class="params">(InputStream is, String </span></span></span><br><span class="line"><span class="function"><span class="params">                                                        codebaseUrl)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CodebaseAwareObjectInputStream(is, <span class="keyword">this</span>.beanClassLoader, codebaseUrl) </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass classDesc) <span class="keyword">throws</span> </span><br><span class="line">                IOException, ClassNotFoundException &#123;                </span><br><span class="line">                Class&lt;?&gt; clazz = <span class="keyword">super</span>.resolveClass(classDesc);                </span><br><span class="line">                SimpleMessageConverter.<span class="keyword">this</span>.checkWhiteList(clazz);                </span><br><span class="line">                <span class="keyword">return</span> clazz;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SerializerMessageConverter"><a href="#SerializerMessageConverter" class="headerlink" title="SerializerMessageConverter"></a>SerializerMessageConverter</h2><p>与<code>SimpleMessageConverter</code>类似，唯一不同的是，多了一个属性用来自定义序列化与反序列化规则。</p>
<h2 id="Jackson2JsonMessageConverter"><a href="#Jackson2JsonMessageConverter" class="headerlink" title="Jackson2JsonMessageConverter"></a>Jackson2JsonMessageConverter</h2><p>消息载体是网络字节序时，使用默认的<code>SimpleMessageConverter</code>就足够了，但是消息载体为java序列化对象<code>application/x-java-serialized-object</code>时，不利于跨语言和跨平台，更推荐使用JSON作为消息的载体，<code>Jackson2JsonMessageConverter</code>负责JSON和java bean之间转换。使用时将<code>jsonConverter</code>注入<code>rabbitTemplate</code>实例中,替换<code>SimpleMessageConverter</code>。在替换后，收发消息可以直接发送消息Object的实例，大大得简化了开发。</p>
<p><strong>注意事项：</strong></p>
<p>使用时，需要生产者额外在消息头中添加一个字段<code>”__ TypeId __ “</code>用于注明该消息映射的domain对象，在下方的示例中，头信息中的字段<code>&quot;__ TypeId __&quot;</code>分别<code>&quot;foo&quot;</code>和<code>”bar“</code>如果生产者未注明，可以为classMapper设置默认值映射domain对象，例如：<code>classMapper.setDefaultType(MyMessage.class)</code>。</p>
<p>需要生产者在消息头注明contentType为<code>application/json或text/x-json</code> 或者生产者也使用 <code>Jackson2JsonMessageConverter</code>，它会自动在消息头中声明contentType。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    <span class="keyword">return</span> jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultClassMapper <span class="title">classMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultClassMapper classMapper = <span class="keyword">new</span> DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(<span class="string">"foo"</span>, Foo.class);</span><br><span class="line">    idClassMapping.put(<span class="string">"bar"</span>, Bar.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    <span class="keyword">return</span> classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentTypeDelegatingMessageConverter"><a href="#ContentTypeDelegatingMessageConverter" class="headerlink" title="ContentTypeDelegatingMessageConverter"></a>ContentTypeDelegatingMessageConverter</h2><p>顾名思义，<code>ContentTypeDelegatingMessageConverter</code>是一个根据消息头中<code>content-Type</code>动态选择<code>MessageConverter</code>的Message Converter。当<code>content-Type</code>为空或根据<code>content-Type</code>匹配不到<code>MessageConverter</code>时，将Message Convert的任务委托给<code>SimpleMessageConverter</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"contentTypeConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ContentTypeDelegatingMessageConverter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"delegates"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/json"</span> value-ref=<span class="string">"jsonMessageConverter"</span> /&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/xml"</span> value-ref=<span class="string">"xmlMessageConverter"</span> /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MarshallingMessageConverter"><a href="#MarshallingMessageConverter" class="headerlink" title="MarshallingMessageConverter"></a>MarshallingMessageConverter</h2><p>负责Spring的Object与XML之间的转换。</p>
<h1 id="为默认的Message-Converter设置反序列化权限"><a href="#为默认的Message-Converter设置反序列化权限" class="headerlink" title="为默认的Message Converter设置反序列化权限"></a>为默认的Message Converter设置反序列化权限</h1><p>在处理 <code>content-type</code> 为<code>application/x-java-serialized-object</code>的java序列化对象时，默认会扫描所有的packages/classes，为了提高安全性，可以设置白名单，所有的Message Converter都有一个属性whiteListPatterns，示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleMessageConverter messageConverter = <span class="keyword">new</span> SimpleMessageConverter();List&lt;String&gt; </span><br><span class="line"></span><br><span class="line">myWhiteList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"safe.*"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"unstable.recent.SafeClass"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"*.MySafeClass"</span>);</span><br><span class="line"></span><br><span class="line">messageConverter.setWhiteListPatterns(myWhiteList);</span><br></pre></td></tr></table></figure>

<p>注意：该属性仅在<code>Message Converter</code>使用<code>DefaultDeserializer</code>有效，即不要主动去配置<code>DefaultDeserializer</code>。</p>
<h1 id="特殊的Conerter——MessagePropertiesConverter"><a href="#特殊的Conerter——MessagePropertiesConverter" class="headerlink" title="特殊的Conerter——MessagePropertiesConverter"></a>特殊的Conerter——MessagePropertiesConverter</h1><p>前面介绍的MessageConverter负责body的转换，MessagePropertiesConverter 负责Rabbit Client的<code>BasicProperties</code>与Spring AMQP <code>MessageProperties</code>之间的转换，它的默认实现是<code>DefaultMessagePropertiesConverter</code>，足以满足绝多数场景下的需求。部分源码如下，仅截取了构造器和属性声明，当<code>BasicProperties</code>中的某一元素长度小于等于<code>longStringLimit</code>时，转化为<code>MessageProperties</code>中的String属性，当<code>BasicProperties</code>中的某一元素长度超过<code>longStringLimit</code>时，根据<code>convertLongLongStrings</code>判断是否需要转换为LongString，如果不需要则转换为<code>DataInputStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessagePropertiesConverter</span> <span class="keyword">implements</span> <span class="title">MessagePropertiesConverter</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LONG_STRING_LIMIT = <span class="number">1024</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> longStringLimit;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> convertLongLongStrings;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1024</span>, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(longStringLimit, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> convertLongLongStrings)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.longStringLimit = longStringLimit;        </span><br><span class="line">        <span class="keyword">this</span>.convertLongLongStrings = convertLongLongStrings;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convertLongString</span><span class="params">(LongString longString, String charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (longString.length() &lt;= (<span class="keyword">long</span>)<span class="keyword">this</span>.longStringLimit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(longString.getBytes(), charset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.convertLongLongStrings ? longString.getStream() : longString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/springboot+RabbitMQ系列(三)消费者/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/springboot+RabbitMQ系列(三)消费者/" itemprop="url">springboot+RabbitMQ系列（三）消费者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T00:00:00+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>消息接收有两种模式，简单的模式是消费者不断地去轮询，轮询到一条就消费一条，复杂些的模式是注册一个异步Listener，由容器负责接收消息并选择对应的Listener处理消息。</em></p>
<h1 id="轮询模式消费者"><a href="#轮询模式消费者" class="headerlink" title="轮询模式消费者"></a>轮询模式消费者</h1><p>在<code>springboot-amqp</code>中，可使用<code>AmqpTemplate（rabbitTemplate）</code>实现轮询模式接收消息，默认是阻塞的，有消息时就拉去消息，没有消息时，立刻返回null。</p>
<p>从springboot1.5版本以后，可以设置单次轮8询的超时时间，即消费者接收消息的阻塞时间，超时时间设置为负值，意味着无限期阻塞。并发量高时，建议使用异步Listener或将超时时间设为0.</p>
<p>如果需要转换消息格式，需要预先为AmpqTemplate设置<code>MessageConverter</code>，然后调用<code>receiveAndConvert（）</code>方法接收消息。</p>
<p>如果需要Replay，可以在调用<code>amqpTemplate.receiveAndReply()</code>接口时传入<code>ReceiveAndReplyCallBack</code>。</p>
<h1 id="异步消费者"><a href="#异步消费者" class="headerlink" title="异步消费者"></a>异步消费者</h1><p> 异步消费者中有一个预取消息（prefetch）的概念，即一个消费者预取一定数目的消息，这可能会导致多消费者情况下其他消费者利用率不足。springboot 2.0之前，预取消息默认值是1，spring boot 2.0以后，默认值为250, 预取值的设置取决于你的业务，要尽可能保证所有消费者的高效运行从而提升吞吐量。比如：</p>
<ol>
<li>当单条消息体很大，消息处理的又比较慢时，预取值如果设置的过大，将导致客户端内存占用率飙升。</li>
<li>如果严格的要求执行顺序时，建议预取值设置为1 </li>
<li>在消息吞吐量不高、消费者又多时，预取值设置的过大会导致消费者利用率不足。</li>
<li>在手动确认的模式下，预取值应该设置为1，如果prefech不为1，basicAck是异步的操作，如果出现异常时，消费者会继续处理其他预取消息，但是不会ack（批量成功时才会ack），因此，其他的消息处于unack的状态，其他的消费者会重新获取该消息，消息会出现重复消费的情况。</li>
</ol>
<h2 id="Message-Consuming-callback"><a href="#Message-Consuming-callback" class="headerlink" title="Message Consuming callback"></a>Message Consuming callback</h2><p>异步消费是通过回调实现的，消息的消费逻辑在回调方法onMessage()中实现，springboot AMQP提供了两个回调接口，MessageListener、ChannelAwareMessageListener，究竟用哪个取决于你是否需要获取channel信息，比如手动ack时必须要有channel才可以。</p>
<h2 id="MessageListenerAdapter"><a href="#MessageListenerAdapter" class="headerlink" title="MessageListenerAdapter"></a>MessageListenerAdapter</h2><p>接口回调已经可以实现消息的消费了，这还不够灵活，如果业务需要动态的指定queue或tag对应哪个methodName时，可以继承MessageListenerAdapter。它包含了下面的构造器，使用该构造器时，与前面提到的接口回调本质上是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageListenerAdapter</span><span class="params">(Object delegate)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.queueOrTagToMethodName = <span class="keyword">new</span> HashMap();    </span><br><span class="line">    <span class="keyword">this</span>.defaultListenerMethod = <span class="string">"handleMessage"</span>;</span><br><span class="line">    <span class="keyword">this</span>.doSetDelegate(delegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delegate（代理）即自定义的消费者bean，它必须是ChannelAwareMessageListener或MessageListener的实例，否则，它不会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object delegate = <span class="keyword">this</span>.getDelegate();</span><br><span class="line"><span class="keyword">if</span> (delegate != <span class="keyword">this</span>) &#123;    </span><br><span class="line">	<span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> ChannelAwareMessageListener) &#123;        </span><br><span class="line">		<span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;            	 												 			((ChannelAwareMessageListener)delegate).onMessage(message, channel);                     <span class="keyword">return</span>;        </span><br><span class="line">		&#125;       </span><br><span class="line">        <span class="keyword">if</span> (!(delegate <span class="keyword">instanceof</span> MessageListener)) &#123;           </span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">"MessageListenerAdapter cannot handle a ChannelAwareMessageListener delegate if it hasn't been invoked with a Channel itself"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> MessageListener) &#123;        	  					 							((MessageListener)delegate).onMessage(message);        </span><br><span class="line">     			<span class="keyword">return</span>;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态的指定消息处理method由下面两个接口实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultListenerMethod(String defaultListenerMethod) &#123;</span><br><span class="line">    this.defaultListenerMethod = defaultListenerMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setQueueOrTagToMethodName(Map&lt;String, String&gt; queueOrTagToMethodName) &#123;</span><br><span class="line">    this.queueOrTagToMethodName.putAll(queueOrTagToMethodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们在getListenerMethodName中被调用，如果你没有定义queueOrTagToMethodName，那么将会调用你设置的defaultListenerMethod，如果你都没有设置，那么默认值是“handleMessage”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws Exception &#123;    </span><br><span class="line">	if (this.queueOrTagToMethodName.size() &gt; 0) &#123;        </span><br><span class="line">		MessageProperties props = originalMessage.getMessageProperties();        </span><br><span class="line">		String methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerQueue());        </span><br><span class="line">		if (methodName == null) &#123;            </span><br><span class="line">			methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerTag());        &#125;        </span><br><span class="line">		if (methodName != null) &#123;            </span><br><span class="line">			return methodName;       </span><br><span class="line">        &#125;    </span><br><span class="line">      &#125;    </span><br><span class="line">     </span><br><span class="line">     return this.getDefaultListenerMethod();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器完成了回调"><a href="#容器完成了回调" class="headerlink" title="容器完成了回调"></a>容器完成了回调</h2><p>前面介绍了如何实现异步消费的回调接口，而真正完成回调的是容器（container），容器是有生命周期的，如启动、运行、停止，容器本质上就是桥接AMQP queue和MessageListener的实例。因此，如果想实现消费者的功能，必须为容器配置connectionFactory、队列、MessageLisener, 即告知容器：如何连接MQ服务器、成功连接后哪个队列的消息应该交给哪个消费者。</p>
<p>在springboot 2.0之前，只有一种容器：SimpleMessageListenerContainer。在springboot2.0以后，新增了一种容器：DirectMessageListenerContainer。二者的区别就是消费者的线程与RabbitMQ客户端线程是否共用，对于SimpleMessageListenerContainer，每一个消费者配置一个线程，如果为容器配置了多个队列，可能会使用同一个线程处理多个队列（消费者数量&lt;队列数）。并发性能取决于你设置的消费者的数conCurrentConsumer，它等于消费者线程数。</p>
<p>一个消息的后半生是这样的：spring-amqp负责将消息从MQ服务器传递给消费者，springboot-amqp提供了默认的容器，用来从MQ服务器接收消息，我们提供的消费者完成onMessage()的消息处理逻辑，并将它注册到容器上。</p>
<p>当消息从RabbitMQ客户端传递过来时，客户端线程通过队列将消息传递给消费线程（消息处理线程）。这是由于早期MQ客户端不支持并发传递消息，一个队列只会有一个线程传递消息，更不可能让它完成消息的处理，这个机制的设置当然是低效的，会增加线程之间切换的开销。</p>
<p>在新版本后，MQ客户端已经支持并发了，完全可以使用MQ客户端的线程完成消息的接收、处理工作，在DirectMessageListenerContainer中，不再区分客户端线程和消费线程，并发的控制由参数consumersPerQueue控制，不再使用conCurrentConsumer、maxConCurrentConsumer、txSize（事务大小，一次事务中传递txSize条消息，用来减少ack的次数，这个参数&gt;1且消息消费出现异常时，会导致同一个事务中后续的消息重复消费）。DirectMessageListenerContainer中提供了messagesPerAck，但是它不是事务，每一条消息都有一个独立的事务用来传递和确认，出现异常时，后续的消息会一直处于unack的状态，所以，不会重复消费。</p>
<h2 id="自定义容器"><a href="#自定义容器" class="headerlink" title="自定义容器"></a>自定义容器</h2><p>前面介绍了两种容器，而且springboot-amqp会提供默认地容器，如果想个性化的设置或有需要设置多种容器时，就需要考虑自定义容器了，在实际项目中，建议使用自定义容器。</p>
<p>现在以SimpleMessageListenerContainer为例介绍下容器的使用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAmqpConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setQueueName(<span class="string">"some.queue"</span>);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListener <span class="title">exampleListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"received: "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是使用@RabbitListener注解+Java Config。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"example.queue"</span>, containerFactory = <span class="string">"exampleContainer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器工厂"><a href="#容器工厂" class="headerlink" title="容器工厂"></a>容器工厂</h2><p>容器工厂专门用来配合@RabbitListener使用，前面提到，springboot为@RabbitListener提供了默认的容器，但为了个性化的设置，建议自定义容器工厂，然后在@RabbitListener中设置”containerFactory“属性。容器和容器工厂的对应如下：</p>
<ol>
<li>SimpleMessageListenerContainer   对应   SimpleRabbitListenerContainerFactory</li>
<li>DirectMessageListenerContainer    对应    DirectRabbitListenerContainerFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>（name=<span class="string">"myContainerFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> 				       					SimpleRabbitListenerContainerFactory();</span><br><span class="line">    	factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    	factory.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">    	factory.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = ”myqueue“, containerFactory = <span class="string">"myContainerFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>前文涉及的conCurrentConsumer、connectionFactory都是容器的属性，还有其他常用的属性：</p>
<p><a href="https://docs.spring.io/spring-amqp/docs/2.0.3.RELEASE/reference/html/_reference.html#containerAttributes" target="_blank" rel="noopener">Springboot2.0.3.RELEASE容器属性介绍</a></p>
<h3 id="channelTransacted"><a href="#channelTransacted" class="headerlink" title="channelTransacted"></a>channelTransacted</h3><p>是否在事务中ack（确认）所有消息。为true时表示需要确认事务中的所有消息。</p>
<h3 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h3><p>提供给Listener的外部事务管理器，是channelTransacted的补充，如果channel是事务的，它的事务会与外部事务进行同步。</p>
<h3 id="acknowledgeMode"><a href="#acknowledgeMode" class="headerlink" title="acknowledgeMode"></a>acknowledgeMode</h3><ul>
<li>NONE         配合channelTransacted=false使用，不发送ACK，MQ服务器认为所有的消息都会被确认，所以                        在RabbitMQ中称为自动ACK，但在springboot中，称为NONE ACK，视角不同导致的称谓不同。</li>
<li>MANUAL   消费者必须手动确认所有的消息，包括异常情况</li>
<li>AUTO         容器自动确认消息，除非Listener抛出容器无法自动处理的异常。该模式也是channelTransacted为true时的默认模式。追求并发时可以配合使用。</li>
</ul>
<h3 id="prefetchCount"><a href="#prefetchCount" class="headerlink" title="prefetchCount"></a>prefetchCount</h3><p>每个消费者能够持有的未ack的消息数，该值越大消息传输给消费者的速度越快。该参数越大，消息的顺序处理性越差。值得注意的是：在AcknowledgeMode.NONE模式下，该参数的设置是无效的，这是由于该模式下根本不存在ack。</p>
<h3 id="txSize"><a href="#txSize" class="headerlink" title="txSize"></a>txSize</h3><p>适用于SimpleMessageListenerContainer，该参数仅在AcknowledgeMode.AUTO模式下生效，容器在发送一次ack之前批量处理txSize条消息，这一批消息处于同一个事务中，会一直等待它们到超时时间，如果prefetchCount小于txSize，会自动将prefetchCount设置的与txSize相等。只能用于channelTransacted为true的场景下。</p>
<h3 id="messagePerAck"><a href="#messagePerAck" class="headerlink" title="messagePerAck"></a>messagePerAck</h3><p>适用于DirectMessageListenerContainer，容器在两次ack之间处理的消息数目，目的是减少向MQ服务器发送ack的次数，代价就是在出现异常时，增大重传消息的可能性，往往用在高并发场景下。在出现异常时（比如拒绝了一批消息中的某一条），则其他消息不管有没有消费完都会被ack，异常的消息被拒绝。所以它不能用在channelTransacted为true的场景。</p>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><p>自定义未捕获的异常的处理机制，默认使用ConditionalRejectingErrorHandler</p>
<h3 id="RabbitListener"><a href="#RabbitListener" class="headerlink" title="@RabbitListener"></a>@RabbitListener</h3><p>异步接收消息最简单的方式是通过注解实现，前面的@RabbitListener即是，底层是MessagingMessageListenerAdapter实现的，使用注解，不需要指定methodName，因为@RabbitListener已经注明了该方法用来接收消息。在一个类中，可以定义多个不同的Listener，如下：</p>
<p>processOrder中，使用@QueueBinding声明了队列、routingkey、exchange以及他们的绑定关系</p>
<p>processInvoice中，绑定、声明了一个匿名队列，也可以声明多个@QueueBinding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = &#123;<span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue"</span>,         </span><br><span class="line">                                                         durable = <span class="string">"true"</span>,         </span><br><span class="line">                                                         autoDelete = <span class="string">"false"</span>),         </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss"</span>)),        </span><br><span class="line">                            <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue2"</span>), </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss1"</span>))&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rcv</span><span class="params">(Message message, Channel channel)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>handleWithSimpleDeclare中，没有声明exchange，routingkey，使用默认地exchange，routingkey与队列名称相同，是direct模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"myQueue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>, ignoreDeclarationExceptions = <span class="string">"true"</span>),</span><br><span class="line">        key = <span class="string">"orderRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>),</span><br><span class="line">        key = <span class="string">"invoiceRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInvoice</span><span class="params">(Invoice invoice)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"$&#123;my.queue&#125;"</span>, durable = <span class="string">"true"</span>))</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleWithSimpleDeclare</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多个方法使用同种@RabbitListener时，可以自定义元注解（常用于广播fanout模式）,比如下面的例子，就使用了一个自动删除（默认地，如果不想自动删除，需要设置auto-delete为false）、匿名、广播模式的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"metaFanout"</span>, type = ExchangeTypes.FANOUT)))</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RabbitListener异常处理"><a href="#RabbitListener异常处理" class="headerlink" title="@RabbitListener异常处理"></a>@RabbitListener异常处理</h1><p>Springboot2.0版之后，@RabbitListener注解新增了errorHandler和returnException属性，默认是无配置的。自定义errorHandler，需要实现RabbitListenerErrorHander接口， 并将其配置在@RabbitListener上。第二个参数messaging.Message是Message Converter产生的，ListenerExecutionFailedException是Listener抛出的。可以在自定义的handleError中处理异常，或抛出其他异常至容器，默认地，如果没有自定义errorHandler，异常将会抛至容器中。由容器的errorHandler处理，见后文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RabbitListenerErrorHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">handleError</span><span class="params">(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt;                     message,ListenerExecutionFailedException exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>returnException属性为“true”时，表示异常需要通知到生产者，一般地，不需要设置该属性，毕竟引入MQ的目的是解耦。</p>
<h2 id="容器的errorHandler"><a href="#容器的errorHandler" class="headerlink" title="容器的errorHandler"></a>容器的errorHandler</h2><p>前面提到，没有自定义errorHandler时，异常会抛至容器默认异常处理器ConditionalRejectingErrorHandler，包含两个构造器，一个无参，一个含参，通过含参构造器可以自定义异常处理策略。若使用的无参构造器，则默认使用内部类DefaultExceptionStrategy中定义的异常处理策略。</p>
<p>ConditionalRejectingErrorHandler源码如下，11行是处理异常的接口，在13行中，异常如果不是AmqpRejectAndDontRequeueException而且是致命异常时，会抛出AmqpRejectAndDontRequeueException，致命异常的判断在37行，首先判断异常产生的原因：</p>
<p>MessagingException位于spring-messiging包下的，是异常MessageConversionException、MethodArgumentResolutionException、MessageDeliveryException、MessageHandlingException、DestinationResolutionException、MethodArgumentNotValidException、MethodArgumentTypeMismatchException、MissingSessionUserException的父类。</p>
<p>ListenerExecutionFailedException是所有异常被抛出时的最上层栈信息，所有异常都以该形式抛出。</p>
<p>39~42行是一个for循环，遍历异常产生的栈信息一层层解析异常产生的原因，一旦有MessageConversionException、MethodArgumentResolutionException就跳出循环，处理该异常，如果遍历完整个循环都没有出现，则处理最后一个异常（42行cause = cause.getCause()）。<strong>因此，如果有多个异常均需要处理时，建议重写isFatal方法</strong>。</p>
<p>59-67行判断cause是否致命，有六种：</p>
<ul>
<li>Spring AMQP的MessageConversionException异常</li>
<li>spring-messaging的MessageConversionException异常</li>
<li>spring-messaging的MethodArgumentResolutionException异常</li>
<li>NoSuchMethodException异常</li>
<li>ClassCastException异常</li>
<li>自定义的异常isUserCauseFatal</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.rabbit.listener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// omit the package import for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRejectingErrorHandler</span> <span class="keyword">implements</span> <span class="title">ErrorHandler</span> </span>&#123;    </span><br><span class="line"><span class="number">2</span>    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());    </span><br><span class="line"><span class="number">3</span>    <span class="keyword">private</span> <span class="keyword">final</span> FatalExceptionStrategy exceptionStrategy;    </span><br><span class="line"><span class="number">4</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">5</span>        <span class="keyword">this</span>.exceptionStrategy = <span class="keyword">new</span> </span><br><span class="line"><span class="number">6</span>            ConditionalRejectingErrorHandler.DefaultExceptionStrategy();    </span><br><span class="line"><span class="number">7</span>    &#125;    </span><br><span class="line"><span class="number">8</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">(FatalExceptionStrategy exceptionStrategy)</span> </span>&#123; <span class="number">9</span>       		<span class="keyword">this</span>.exceptionStrategy = exceptionStrategy;                               <span class="number">10</span>          &#125;    </span><br><span class="line"><span class="number">11</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">this</span>.log(t);        </span><br><span class="line"><span class="number">13</span>        <span class="keyword">if</span> (!<span class="keyword">this</span>.causeChainContainsARADRE(t) &amp;&amp; <span class="keyword">this</span>.exceptionStrategy.isFatal(t)) &#123;   <span class="number">14</span>              <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"Error Handler converted     15                       exception to fatal"</span>, t);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125;    </span><br><span class="line"><span class="number">18</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">this</span>.logger.warn(<span class="string">"Execution of Rabbit message listener failed."</span>, t);       </span><br><span class="line"><span class="number">21</span>        &#125;    </span><br><span class="line"><span class="number">22</span>    &#125;    </span><br><span class="line"><span class="number">23</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">causeChainContainsARADRE</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">24</span>        <span class="keyword">for</span>(Throwable cause = t.getCause(); cause != <span class="keyword">null</span>; cause = cause.getCause()) &#123; <span class="number">25</span>               <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> AmqpRejectAndDontRequeueException) &#123;               </span><br><span class="line"><span class="number">26</span>                	<span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">27</span>             &#125;        </span><br><span class="line"><span class="number">28</span>        &#125;        </span><br><span class="line"><span class="number">29</span>        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line"><span class="number">30</span>    &#125;    </span><br><span class="line"><span class="number">31</span>    </span><br><span class="line"><span class="number">32</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExceptionStrategy</span> <span class="keyword">implements</span> <span class="title">FatalExceptionStrategy</span> </span>&#123;   <span class="number">33</span>     </span><br><span class="line"><span class="number">34</span>        <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());        </span><br><span class="line"><span class="number">35</span>        <span class="function"><span class="keyword">public</span> <span class="title">DefaultExceptionStrategy</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">36</span>        &#125;        </span><br><span class="line"><span class="number">37</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFatal</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line"><span class="number">38</span>            Throwable cause;            </span><br><span class="line"><span class="number">39</span>            <span class="keyword">for</span>(cause = t.getCause(); cause <span class="keyword">instanceof</span> MessagingException </span><br><span class="line"><span class="number">40</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MessageConversionException) </span><br><span class="line"><span class="number">41</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MethodArgumentResolutionException); </span><br><span class="line"><span class="number">42</span>                cause = cause.getCause()) &#123;                </span><br><span class="line"><span class="number">43</span>                ;            </span><br><span class="line"><span class="number">44</span>            &#125;            </span><br><span class="line"><span class="number">45</span>            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ListenerExecutionFailedException </span><br><span class="line"><span class="number">46</span>                &amp;&amp; <span class="keyword">this</span>.isCauseFatal(cause)) &#123;                </span><br><span class="line"><span class="number">47</span>                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;                    </span><br><span class="line"><span class="number">48</span>                    <span class="keyword">this</span>.logger.warn(<span class="string">"Fatal message conversion error; message rejected; 49                      it will be dropped or routed to a dead letter exchange, if so     50                        configured: "</span> + ((ListenerExecutionFailedException)t)</span><br><span class="line"><span class="number">51</span>                                     .getFailedMessage());                </span><br><span class="line"><span class="number">52</span>                &#125;                </span><br><span class="line"><span class="number">53</span>                <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">54</span>            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line"><span class="number">55</span>                <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line"><span class="number">56</span>            &#125;        </span><br><span class="line"><span class="number">57</span>        &#125;        </span><br><span class="line"><span class="number">58</span>                                                                                     </span><br><span class="line"><span class="number">59</span>		<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">60</span>            <span class="keyword">return</span> cause <span class="keyword">instanceof</span> </span><br><span class="line"><span class="number">61</span>                org.springframework.amqp.support.converter.MessageConversionException </span><br><span class="line"><span class="number">62</span>                || cause <span class="keyword">instanceof</span> MessageConversionException </span><br><span class="line"><span class="number">63</span>                || cause <span class="keyword">instanceof</span> MethodArgumentResolutionException </span><br><span class="line"><span class="number">64</span>                || cause <span class="keyword">instanceof</span> NoSuchMethodException </span><br><span class="line"><span class="number">65</span>                || cause <span class="keyword">instanceof</span> ClassCastException </span><br><span class="line"><span class="number">66</span>                || <span class="keyword">this</span>.isUserCauseFatal(cause);        </span><br><span class="line"><span class="number">67</span>        &#125;        </span><br><span class="line"><span class="number">68</span>        </span><br><span class="line"><span class="number">69</span>      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isUserCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">70</span>            <span class="keyword">return</span> <span class="keyword">false</span>;        </span><br><span class="line"><span class="number">71</span>      &#125;    </span><br><span class="line"><span class="number">72</span>   &#125;</span><br><span class="line"><span class="number">73</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以选择完全自定义异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listenerContainerFactory.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line">        <span class="comment">// do something handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>对于消息的异常处理springboot2.0.3还不够完善。比如使用的@RabbitListener、AcknowledgeMent.MANUAL发送一条空的消息，这条消息无法到达自定义的onMessage()方法，提前抛出了异常，若尝试通过RabbitListenerErrorHandler处理异常，并按照下面的方式自定义了一个errorHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"myErrorHandler"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerErrorHandler <span class="title">rabbitListenerErrorHandler</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerErrorHandler() &#123;       </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleError</span><span class="params">(Message message, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  org.springframework.messaging.Message&lt;?&gt; message1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ListenerExecutionFailedException e)</span> <span class="keyword">throws</span> Exception </span>&#123;            <span class="comment">// 如果消息是空的，这条消息不再归队            </span></span><br><span class="line">            <span class="keyword">if</span> (message.getBody().length == <span class="number">0</span>) &#123;                </span><br><span class="line">                Channel channel = message1.getHeaders().get(AmqpHeaders.CHANNEL, </span><br><span class="line">                                                            Channel.class);</span><br><span class="line">                logger.error(<span class="string">"rcv error"</span>);</span><br><span class="line">                Channel channel1 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line">                Channel channel2 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line"></span><br><span class="line">                logger.error(<span class="string">"channel1=&#123;&#125;"</span>, channel);</span><br><span class="line">                logger.error(<span class="string">"channel2=&#123;&#125;"</span>, channel2);</span><br><span class="line">                <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.error（”channel <span class="keyword">null</span>，can not send ack...“）</span><br><span class="line">                    <span class="keyword">throw</span> e;                </span><br><span class="line">                &#125;                </span><br><span class="line">                channel.basicReject(message1.getHeaders().get(AmqpHeaders.DELIVERY_TAG, </span><br><span class="line">                                                              Long.class), <span class="keyword">false</span>);              </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"msg format error"</span>);         </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">throw</span> e;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送10条empty的消息，打印了10次：channel null，can not send ack…</p>
<p>这10条消息一直处于unack的状态，消息并没有被reject，而是一直处于unack的状态,但是该消息是无意义的,不应该再重新入队.</p>
<p>原因：<br>springboot ListenerContainer负责传递消息给消费者，容器通过反射调用自定义的Listener并处理消息时出现参数错误异常，message转byte异常报错。<br>由于方法参数反射错误，无法调用到onMessage方法，又采用的手动确认的方式，导致没办法通过channel.basicReject拒绝该消息，所以这条消息会一直处于unack的状态。</p>
<p>解决的方法有四种：<br>1、升级springboot至2.1.6版本，在Listener容器中注册RabbitListenerErrorHandler，该版本中，可以通过org.springframework.messaging.Message获取channel信息。通过channel拒绝该消息。在之前的版本中，获取到的channel都是null(如代码所示，channel、channel1、channel2均为null，说明spring没有将channel信息封装在org.springframework.messaging.Message)，无法给MQ服务器发送ACK。<br>2、修改onMessage()的参数，使用Message类型作为消息的载体，不再使用byte、string等其他类型，定义MessageConverter或使用默认的MessageConverter实现消息格式转换。<br>3、使用springboot的Acknowledge.AUTO模式，该模式下Listener容器会自动发送ACK给MQ服务器</p>
<p>4、自定义MessageConveter</p>
<p>最后使用了方法2，springboot升级会带来兼容性的问题，比如数据库驱动、数据库版本等，方法3中交给容器自动确认更适合高并发设置多个消费者同时消费1个队列、添加一些批量拉取消息、批量事务处理的场景，该场景会牺牲消息的有序性、异常时可能会有重复消费的问题。我们现在的业务场景更偏向于保证消息的可靠性，一个队列只会有一个消费者，消费一条拉取一条，消息处理的线程池也是自定义的，这样的方式更灵活稳定。所以最后否定了方法3，选用方案2</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shipengyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shipengyang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


</body>
</html>
