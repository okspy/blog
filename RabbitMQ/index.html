<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="1 基础知识 暂略，参考rabbitMQ基础，本文主要是对springboot集成RabbitMQ的解读。  2 连接管理spring AMQP默认使用CachingConnectionFactory创建一个应用程序共享的连接工厂，也是用途最广泛的ConnectionFactory构建方法，也为Junit提供了SingleConnectionFactory，SingleConncetionFact">
<meta property="og:type" content="article">
<meta property="og:title" content="springboot+RabbitMQ">
<meta property="og:url" content="http://yoursite.com/RabbitMQ/index.html">
<meta property="og:site_name" content="okspy">
<meta property="og:description" content="1 基础知识 暂略，参考rabbitMQ基础，本文主要是对springboot集成RabbitMQ的解读。  2 连接管理spring AMQP默认使用CachingConnectionFactory创建一个应用程序共享的连接工厂，也是用途最广泛的ConnectionFactory构建方法，也为Junit提供了SingleConnectionFactory，SingleConncetionFact">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-14T13:47:41.223Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="springboot+RabbitMQ">
<meta name="twitter:description" content="1 基础知识 暂略，参考rabbitMQ基础，本文主要是对springboot集成RabbitMQ的解读。  2 连接管理spring AMQP默认使用CachingConnectionFactory创建一个应用程序共享的连接工厂，也是用途最广泛的ConnectionFactory构建方法，也为Junit提供了SingleConnectionFactory，SingleConncetionFact">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/RabbitMQ/">





  <title>springboot+RabbitMQ | okspy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">okspy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shipengyang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="okspy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">springboot+RabbitMQ</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-12T00:29:29+08:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springboot/" itemprop="url" rel="index">
                    <span itemprop="name">springboot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><ul>
<li>暂略，参考rabbitMQ基础，本文主要是对springboot集成RabbitMQ的解读。</li>
</ul>
<h2 id="2-连接管理"><a href="#2-连接管理" class="headerlink" title="2 连接管理"></a>2 连接管理</h2><p>spring AMQP默认使用<code>CachingConnectionFactory</code>创建一个应用程序共享的连接工厂，也是用途最广泛的<code>ConnectionFactory</code>构建方法，也为Junit提供了<code>SingleConnectionFactory</code>，<code>SingleConncetionFactory</code>不常用，不再赘述。</p>
<p>与AMQP通信的工作单元实际上是Channel，TCP连接可以共享。connectionFactory分为两种模式，一种是缓存channel，一种是缓存connection（同时也缓存该connection的channel）。默认是缓存channel的模式，<strong>高可用集群场景下（镜像队列）</strong>，通过负载均衡器连接至集群中不同的实例时，可以通过setCacheMode设置为缓存connection的模式。代码示例中给出了缓存connection的模式，同时也设置了<code>channelCacheSize</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CachingConnectionFactory <span class="title">buildConnFactory</span><span class="params">(String addresses, String username, String password, String vhost)</span> </span>&#123;    </span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    connectionFactory.setAddresses(addresses);    </span><br><span class="line">    connectionFactory.setUsername(username);    </span><br><span class="line">    connectionFactory.setPassword(password);    </span><br><span class="line">    connectionFactory.setVirtualHost(vhost);    </span><br><span class="line">    connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CONNECTION);      </span><br><span class="line">    connectionFactory.setConnectionCacheSize(<span class="number">10</span>);</span><br><span class="line">    connectionFactory.setChannelCacheSize(<span class="number">200</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要采用缓存Channel的模式，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CachingConnectionFactory <span class="title">buildConnFactory</span><span class="params">(String addresses, String username, String password, String vhost)</span> </span>&#123;    </span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    connectionFactory.setAddresses(addresses);    </span><br><span class="line">    connectionFactory.setUsername(username);    </span><br><span class="line">    connectionFactory.setPassword(password);    </span><br><span class="line">    connectionFactory.setVirtualHost(vhost);    </span><br><span class="line">    connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);    </span><br><span class="line">    connectionFactory.setChannelCacheSize(channelCacheSize);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在缓存connection模式下，不支持自动声明队列、exchange、binding等，rabbitmq-client默认只提供了5个线程处理connection，因此，当connection较多时，应该自定义线程池，并配置到<code>CachingConnectionFactory</code>中。自定义的线程池将会被所有connection共享，建议线程池的最大线程数设置的与预期connection数相等，因为可能存在对于大部分connection都有多个channel的情况。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = <span class="keyword">new</span> </span><br><span class="line">    ThreadPoolExecutor(corePoolSize,                            </span><br><span class="line">                       maxPoolSize, keepAliveSeconds,TimeUnit.SECONDS,        </span><br><span class="line">                       <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(queueSize),   </span><br><span class="line">                       <span class="keyword">new</span> ThreadFactory() &#123;            </span><br><span class="line">                           <span class="meta">@Override</span>            </span><br><span class="line">                           <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span></span><br><span class="line"><span class="function">                           </span>&#123;                </span><br><span class="line">                               Thread thread = <span class="keyword">new</span> Thread(r);                 </span><br><span class="line">                               thread.setName(<span class="string">"myThread"</span> + autoInt.getAndIncrement());   </span><br><span class="line">                               thread.setDaemon(<span class="keyword">false</span>);                </span><br><span class="line">                               <span class="keyword">return</span> thread;            </span><br><span class="line">                           &#125;        </span><br><span class="line">                       &#125;,        </span><br><span class="line">                       <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">connectionFactory.setExecutor(executor);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-channelCacheSize"><a href="#2-1-channelCacheSize" class="headerlink" title="2.1 channelCacheSize"></a>2.1 channelCacheSize</h3><p>前面了解到，Spring AMQP通过缓存channel或connection提高吞吐量。<code>connectionFactory</code>分为两种模式，一种是缓存channel，一种是缓存connection（同时也缓存该connection的channel）。本节主要介绍<code>channelCacheSize</code>。<code>ConnectionCacheSize</code>也是类似的，不赘述。</p>
<h4 id="2-1-1-默认仅限制缓存的channelSize"><a href="#2-1-1-默认仅限制缓存的channelSize" class="headerlink" title="2.1.1 默认仅限制缓存的channelSize"></a>2.1.1 默认仅限制缓存的channelSize</h4><p>默认地，最大channelSize是没有限制的，限制的仅仅是缓存的channelSize（connection也一样），默认值是25，缓存channel的目的是减小高并发多线程环境中频繁创建销毁channel的开销，比如：在某一时刻有100个channel处于工作状态，当channel空闲后，只会缓存channelSize个channel，剩下的都会被销毁。</p>
<p>通过RabbitMQ的Web管理插件观察到channel在频繁的被创建和销毁时，应及时的提高<code>channelCacheSize</code>。建议最少要保证线程数&lt;<code>channelCacheSize</code>。可以通过压力测试，观察高峰期channel动态平衡的数量，从而决定<code>channelCacheSize</code>的大小。</p>
<h4 id="2-1-2-channelSize限制"><a href="#2-1-2-channelSize限制" class="headerlink" title="2.1.2 channelSize限制"></a>2.1.2 channelSize限制</h4><p>也可以通过<code>channelCheckoutTimeout</code>参数设置<code>connectionFactory</code>的<code>channelSize</code>限制，当该参数大于0时，表示最大的<code>channel数目</code>=<code>channelCacheSize</code>，达到<code>channelCacheSize</code>的上限后，调用<code>createChannel</code>的线程会阻塞，直至有空闲<code>channel</code>出现或阻塞时间超过<code>chanelCheckoutTimeout</code>，在超时的情况下，抛出<code>AmqpTimeoutException</code>，可以设置一些Retry的策略来处理这些异常。</p>
<h3 id="2-2-为连接命名"><a href="#2-2-为连接命名" class="headerlink" title="2.2 为连接命名"></a>2.2 为连接命名</h3><p>通过<code>ConnectionNameStrategy</code>属性设置<code>connection</code>名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setConnectionNameStrategy(<span class="keyword">new</span> ConnectionNameStrategy() &#123;   </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">obtainNewConnectionName</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> connectionFactory.getHost() + atomicInteger.getAndIncrement();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connectionFactory;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-使用RabbitMQ-client的connectionFactory"><a href="#2-3-使用RabbitMQ-client的connectionFactory" class="headerlink" title="2.3 使用RabbitMQ client的connectionFactory"></a>2.3 使用RabbitMQ client的connectionFactory</h3><p>Spring AMQP也支持使用RabbitMQ Java API提供的<code>connectionFactory</code>，即Rabbit Client的<code>connectionFactory</code>，位于包<code>com.rabbitmq.client.ConnectionFactory</code>中，通过构造器参数设置在<code>CachingConnectionFactory</code>中，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<h4 id="2-3-1-自定义RabbitClient的属性"><a href="#2-3-1-自定义RabbitClient的属性" class="headerlink" title="2.3.1 自定义RabbitClient的属性"></a>2.3.1 自定义RabbitClient的属性</h4><p>上述示例指示了RabbitClient的<code>connectionFactory</code> —–&gt; Spring AMQP的<code>connectionFactiory</code>的转换，Spring也提供了Spring AMQP的<code>connectionFactiory</code> —–&gt; RabbitClient的<code>connectionFactory</code>的转换。</p>
<p>比如可以通过CachingConnectionFactory设置RabbitClient <code>connectionFactory</code>的属性。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-连接恢复"><a href="#2-4-连接恢复" class="headerlink" title="2.4 连接恢复"></a>2.4 连接恢复</h3><p>Rabbit Client4.0后的<code>connectionFactory</code>和Spring AMQP的·<code>connectionFactory</code>均默认提供了自动恢复连接的机制；虽然两者的自动恢复机制是兼容的，但使用构造注入<code>conncetionFactory</code>时建议关闭其中一个。</p>
<p>否则，在MQ服务器节点可用但连接尚未恢复时，出现<code>AutoRecoverConnectionNotCurrentlyOpenException</code> 异常。比如：如果在<code>RabbitTemplate</code>中配置<code>RetryTemplate</code>（Spring AMQP的手动恢复），甚至在故障转移到集群中的另一个代理时，可能抛出上述异常。</p>
<h4 id="2-4-1-关闭Rabbit-Client的自动恢复"><a href="#2-4-1-关闭Rabbit-Client的自动恢复" class="headerlink" title="2.4.1 关闭Rabbit Client的自动恢复"></a>2.4.1 关闭Rabbit Client的自动恢复</h4><p>由于Spring AMQP的自动恢复连接在计时器上恢复，因此可以使用SpringAMQP的恢复机制更快地恢复连接。</p>
<p>springboot-amqp1.7版本以后，默认关闭RabbitClient的<code>connectionFactory</code>的自动重连，<strong>但是，在通过构造参数注入RabbitClient的<code>connectionFactory</code>时，是没有办法默认关闭的，需要手动设置</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>); <span class="comment">// 显示关闭RabbitClient的自动重连</span></span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<p>一般地，关闭掉Rabbit Client的自动恢复，使用Spring AMQP可以满足绝大多数使用场景，而且框架提供的自动恢复机制已经很完善。</p>
<h3 id="2-5-SSL连接"><a href="#2-5-SSL连接" class="headerlink" title="2.5 SSL连接"></a>2.5 SSL连接</h3><p>建议通过注入RabbitMQ client <code>connectionFactory</code>的方式配置SSL连接，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">factory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">File keyFile = <span class="keyword">new</span> File(keyPath);</span><br><span class="line">File certFile = <span class="keyword">new</span> File(cerPath);</span><br><span class="line">SSLContexts sslCtx = SslContextBuilder.forServer(certFile, keyFile).build();</span><br><span class="line">factory.useSslProtocol(sslCtx);</span><br><span class="line"></span><br><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(factory);</span><br></pre></td></tr></table></figure>

<h3 id="2-6-避免Connection死锁"><a href="#2-6-避免Connection死锁" class="headerlink" title="2.6 避免Connection死锁"></a>2.6 避免Connection死锁</h3><p>在内存不足或MQ服务端出现异常时，可能会出现连接阻塞，对于默认的CachingConnectionFactory，MQ服务端导致连接阻塞时，客户端会主动地关闭。</p>
<p>因此，如果生产者消费者共用同一个connectionFactory，MQ服务端导致生产者客户端与消费者客户端关闭，可能死锁的情况：生产者与消费者持有相同的连接资源时，MQ服务器异常触发生产者和消费者中断与服务端的连接，可能会出现死锁。</p>
<p>为避免死锁的产生，<strong>建议对于生产者和消费者分别配置不同的connectionFactory</strong>。需要注意的是：如果生产者消费者处于同一个事物时，不建议生产者消费者配置相同的connectionFactory，因为消费者（或生产者）需要复用对方的channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"myRabbitTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">basicCloudRabbitTemplate</span><span class="params">(CachingConnectionFactory f)</span> </span>&#123;    </span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(f);   </span><br><span class="line">    rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-Routing-ConnectionFactory实现多数据源收发消息"><a href="#2-7-Routing-ConnectionFactory实现多数据源收发消息" class="headerlink" title="2.7 Routing ConnectionFactory实现多数据源收发消息"></a>2.7 Routing ConnectionFactory实现多数据源收发消息</h3><p>spring AMQP提供<code>SimpleRoutingConnectionFactory负责在运行时根据查找键动态选择connectionFactory，通常，以线程的上下文作为查找键，比如地址、vHost</code>等，<code>SimpleRoutingConnectionFactory</code>继承了<code>AbstractRoutingConnectionFactory</code>，通过SimpleResourceHolder获取当前线程的查找键。示例如下：</p>
<p>首先，为RabbitTemplate配置一个以vHost作为查找键的<code>SimpleRoutingConnectionFactory</code>。key分别为<code>factory1</code>的<code>virtualHost</code>和<code>factory2</code>的<code>virtualHost</code>，当然，也可以使用addresses作为查找键。使用方式为<code>factoryMap.put(&quot;#{factory1.addresses}&quot;, factory1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SimpleRoutingConnectionFactory <span class="title">myFactory</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRoutingConnectionFactory routingFactory = <span class="keyword">new</span> SimpleRoutingConnectionFactory();    </span><br><span class="line">    CachingConnectionFactory factory1 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory1.setAddresses(<span class="string">"localhost:5672"</span>);    </span><br><span class="line">    factory1.setUsername(<span class="string">"username1"</span>);    </span><br><span class="line">    factory1.setPassword(<span class="string">"password1"</span>);    </span><br><span class="line">    factory1.setVirtualHost(<span class="string">"v1"</span>);    </span><br><span class="line">    </span><br><span class="line">    CachingConnectionFactory factory2 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory2.setAddresses(<span class="string">"202.130.1.1:5672"</span>);    </span><br><span class="line">    factory2.setUsername(<span class="string">"username2"</span>);    </span><br><span class="line">    factory2.setPassword(<span class="string">"password2"</span>);    </span><br><span class="line">    factory2.setVirtualHost(<span class="string">"v2"</span>);    </span><br><span class="line">    </span><br><span class="line">    Map&lt;Object, ConnectionFactory&gt; factoryMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);    </span><br><span class="line">  	factoryMap.put(<span class="string">"#&#123;factory1.virtualHost&#125;"</span>, factory1);    </span><br><span class="line">    factoryMap.put(<span class="string">"#&#123;factory2.virtualHost&#125;"</span>, factory2);    </span><br><span class="line">    </span><br><span class="line">    routingFactory.setTargetConnectionFactories(factoryMap);     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> routingFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"myRabbitTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">myRabbitTemplate</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();    </span><br><span class="line">    rabbitTemplate.setConnectionFactory(myFactory());        </span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法如下，SimpleResourceHolder的bind和unbind都是必须的，分别指获取当前线程查找键，释放查找键。bind有两个参数，第一个为待获取的connectFactory，第二个为key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"myRabbitTemplate"</span>)</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String vHost, String payload)</span> </span>&#123;</span><br><span class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</span><br><span class="line">        rabbitTemplate.convertAndSend(payload);</span><br><span class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者使用多数据源的方式略有不同</strong>，首先，配置两个不同的containerFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"myContainerFactory1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">containerFactory1</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRabbitListenerContainerFactory containerFactory1 = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();        </span><br><span class="line">    </span><br><span class="line">    CachingConnectionFactory factory1 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory1.setAddresses(<span class="string">"localhost:5672"</span>);    </span><br><span class="line">    factory1.setUsername(<span class="string">"username1"</span>);    </span><br><span class="line">    factory1.setPassword(<span class="string">"password1"</span>);    </span><br><span class="line">    factory1.setVirtualHost(<span class="string">"v1"</span>);        </span><br><span class="line">    </span><br><span class="line">    containerFactory1.setConnectionFactory(factory1);        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> containerFactory1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"myContainerFactory2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">containerFactory2</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    SimpleRabbitListenerContainerFactory containerFactory2 = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();    </span><br><span class="line">   	</span><br><span class="line">    CachingConnectionFactory factory2 = <span class="keyword">new</span> CachingConnectionFactory();    </span><br><span class="line">    factory2.setAddresses(<span class="string">"host2:5672"</span>);    </span><br><span class="line">    factory2.setUsername(<span class="string">"username2"</span>);    </span><br><span class="line">    factory2.setPassword(<span class="string">"password2"</span>);    </span><br><span class="line">    factory2.setVirtualHost(<span class="string">"v2"</span>);    </span><br><span class="line">    </span><br><span class="line">    containerFactory2.setConnectionFactory(factory2);    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> containerFactory2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@RabbitListener接收消息时指定containerFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"queue.test"</span>, containerFactory = <span class="string">"myContainerFactory1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg1</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"> 	String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line"> 	logger.debug(<span class="string">"rcv msg &#123;&#125;"</span>, msg);</span><br><span class="line"> 	channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"queue.test"</span>, containerFactory = <span class="string">"myContainerFactory2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg2</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"> 	String msg = <span class="keyword">new</span> String(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line"> 	logger.debug(<span class="string">"rcv msg &#123;&#125;"</span>, msg);</span><br><span class="line"> 	channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8-集群中的连接管理"><a href="#2-8-集群中的连接管理" class="headerlink" title="2.8 集群中的连接管理"></a>2.8 集群中的连接管理</h3><p>MQ的集群根据集群中各节点队列信息区分为镜像队列和普通队列。只有队列所在节点知道该队列的所有信息，默认情况下，MQ是普通队列，队列只存活于集群中的一个节点上，称为主队列。镜像队列与普通队列的相同点是：队列的主拷贝仅存在于一个节点上（主队列，master节点）。不同点是，镜像节点在集群中的其他节点上拥有从队列的拷贝。一旦队列主节点不可用，最老的从队列自动被选举为新的主队列。</p>
<p>镜像队列的原理：在非镜像队列的集群中，信道负责将消息路由至合适的队列。当加入镜像队列后，信道除了负责将消息路按照路由绑定规则路由至合适的队列外，它也要将消息投递到镜像队列的从拷贝，在某种程度上，可以将镜像队列视为拥有一个隐藏的fanout交换器，它指示着信道将消息分发到队列的从拷贝上。</p>
<p>无论对于普通队列还是镜像队列，所要面临的问题是：主节点崩溃时，消费者该与哪个节点建立连接。</p>
<h4 id="2-8-1-普通队列"><a href="#2-8-1-普通队列" class="headerlink" title="2.8.1 普通队列"></a>2.8.1 普通队列</h4><p>对于普通队列，使用<code>CachingConnectionFactory</code>就足够了，它支持配置多个连接地址，当一个连接失败时，会按顺序尝试与其他地址建立连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">factory.setAddresses(<span class="string">"host1:5672, host2:5672"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-8-2-高可用队列（镜像队列）"><a href="#2-8-2-高可用队列（镜像队列）" class="headerlink" title="2.8.2 高可用队列（镜像队列）"></a>2.8.2 高可用队列（镜像队列）</h4><ul>
<li>消费者</li>
</ul>
<p><code>LocalizedQueueConnectionFactory</code>是Spring AMQP为<strong>消费者</strong>提供的用于高可用集群的连接工厂，使用它时，MQ服务端必须设置enable management plugin。</p>
<p>它通过MQ服务器management 插件提供的REST API 获取哪个节点是主节点，创建<code>CachingConnectionFactory</code>连接至该节点，如果连接失败，将再次调用MQ服务器management 插件提供的REST API 获取新选举的主节点。当无法获取新选举的主节点是，将通过<code>CachingConnectionFactory</code>像普通队列一样按顺序连接至MQ服务器。</p>
<p><code>LocalizedQueueConnectionFactory</code><strong>本质上是一个RoutingConnectionFactory，它的查找键是队列名。</strong></p>
<p>正是由于查找键是对列名，必需保证查找键的唯一性，消费者的<code>ContainerFactory</code>只能配置在一个队列上。</p>
<p>注意：</p>
<p>由于每次创建连接时，都要通过REST API获取连接节点，开销很大，只适用于长连接的场景（消费者），不适用短连接的场景（生产者）。</p>
<p><code>LocalizedQueueConnectionFactory</code>只适用于消费者，比如配置在<code>SimpleMessageListenerContainer</code>中，不适用于生产者（比如将<code>LocalizedQueueConnectionFactory</code>配置在<code>RabbitTemplate</code>中）。</p>
<p>示例如下：<code>LocalizedQueueConnectionFactory</code>构造方法的前三个参数 <code>addresses</code>, <code>adminUris</code> 和<code>nodes</code>都是字符串数组，<code>LocalizedQueueConnectionFactory</code>使用数组下标相同的参数构建连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitProperties props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] adminUris = &#123; <span class="string">"http://host1:15672"</span>, <span class="string">"http://host2:15672"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] nodes = &#123; <span class="string">"rabbit@host1"</span>, <span class="string">"rabbit@host2"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">defaultConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory cf = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    cf.setAddresses(<span class="keyword">this</span>.props.getAddresses());</span><br><span class="line">    cf.setUsername(<span class="keyword">this</span>.props.getUsername());</span><br><span class="line">    cf.setPassword(<span class="keyword">this</span>.props.getPassword());</span><br><span class="line">    cf.setVirtualHost(<span class="keyword">this</span>.props.getVirtualHost());</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">queueAffinityCF</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @Qualifier(<span class="string">"defaultConnectionFactory"</span>)</span> ConnectionFactory defaultCF) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalizedQueueConnectionFactory(defaultCF,</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(<span class="keyword">this</span>.props.getAddresses()),</span><br><span class="line">            <span class="keyword">this</span>.adminUris, <span class="keyword">this</span>.nodes,</span><br><span class="line">            <span class="keyword">this</span>.props.getVirtualHost(), <span class="keyword">this</span>.props.getUsername(), <span class="keyword">this</span>.props.getPassword(),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生产者</li>
</ul>
<p>生产者本身也不需要考虑哪个节点是主节点，对于生产者来说，队列是未知的，消息会发送至集群中所有的节点。节点会判断该消息对应的主队列是否在自己的节点上。</p>
<h3 id="2-9-连接和信道监听"><a href="#2-9-连接和信道监听" class="headerlink" title="2.9 连接和信道监听"></a>2.9 连接和信道监听</h3><p>Spring AMQP提供了connection和channel的监听器接口，通过回调实现自定义的创建和销毁监听逻辑。</p>
<h4 id="2-9-1-ConnectionListener"><a href="#2-9-1-ConnectionListener" class="headerlink" title="2.9.1 ConnectionListener"></a>2.9.1 ConnectionListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">      List&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">ConnectionListener connectionListener = <span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// do something</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      connectionListeners.add(connectionListener);</span><br><span class="line"></span><br><span class="line">      factory.setConnectionListeners(connectionListeners);</span><br></pre></td></tr></table></figure>

<h4 id="2-9-2-ChannelListener"><a href="#2-9-2-ChannelListener" class="headerlink" title="2.9.2 ChannelListener"></a>2.9.2 ChannelListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">List&lt;ChannelListener&gt; channelListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ChannelListener channelListener = <span class="keyword">new</span> ChannelListener() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> b)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// do something    </span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// do something    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channelListeners.add(channelListener);</span><br><span class="line">List&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">factory.setChannelListeners(channelListeners);</span><br></pre></td></tr></table></figure>

<h3 id="2-10-channel关闭的日志级别控制"><a href="#2-10-channel关闭的日志级别控制" class="headerlink" title="2.10 channel关闭的日志级别控制"></a>2.10 channel关闭的日志级别控制</h3><p>当channel关闭时，<code>CachingConnectionFactory</code>的默认日志规则如下：</p>
<ul>
<li>正常的channel销毁，无log</li>
<li>队列声明失败导致的channel关闭，debug级别</li>
<li>在exclusive（独占）队列上，basic.consume因为独占使用条件而关闭channel，info级别</li>
<li>其他的channel关闭情况输出error级别log</li>
</ul>
<p>自定义log级别：为CachingConnectionFactory配置自定义的ConditionalExceptionLogger。</p>
<h2 id="3-生产者"><a href="#3-生产者" class="headerlink" title="3 生产者"></a>3 生产者</h2><p>AMQP定义了普遍适用的消息通信框架，只规定了最底层的协议，有关协议的细节可以有多种实现，因此，Spring AMQP提供了<code>AmqpTemplate</code>作为收发消息的模板，定义了一些常用的收发消息的接口，<code>AmqpTemplate</code>是一个底层的模板，它的上层实现可以根据具体的协议细节定义其他的接口。</p>
<p>目前，Spring AMQP只有一个实现——<code>RabbitTemplate</code>。</p>
<p><code>RabbitTemplate</code>可以用来收发消息，但是一般的，<code>RabbitTemplate</code>只用来发送消息，接收消息使用<code>@RabbitListener</code>与容器工厂。这是生产者和消费者特性导致的：生产者采用阻塞的方式，与MQ服务器之间是短连接，消费者采用非阻塞，一个线程接收线程，另外的线程处理消息，与MQ服务器之间是长连接。本章介绍<code>RabbitTemplate</code>的一些属性的配置，以及如何使用<code>RabbitTemplate</code>发送消息。</p>
<h2 id="3-1-RabbitTemplate配置"><a href="#3-1-RabbitTemplate配置" class="headerlink" title="3.1 RabbitTemplate配置"></a>3.1 RabbitTemplate配置</h2><h4 id="3-1-1-重试机制"><a href="#3-1-1-重试机制" class="headerlink" title="3.1.1 重试机制"></a>3.1.1 重试机制</h4><p>在MQ客户端与MQ服务器之间连接出现异常时，消息收发可能会抛出异常，为了避免频繁抛出异常，可以加入一些重试机制，在抛出异常前，重试几次，通过设置<code>RetryTemplate</code>实现消息的重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    ExponentialBackOffPolicy backOffPolicy = <span class="keyword">new</span> ExponentialBackOffPolicy();</span><br><span class="line">    backOffPolicy.setInitialInterval(<span class="number">500</span>);</span><br><span class="line">    backOffPolicy.setMultiplier(<span class="number">10.0</span>);</span><br><span class="line">    backOffPolicy.setMaxInterval(<span class="number">10000</span>);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line">    template.setRetryTemplate(retryTemplate);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-生产者可靠投递"><a href="#3-1-2-生产者可靠投递" class="headerlink" title="3.1.2 生产者可靠投递"></a>3.1.2 生产者可靠投递</h4><p>生产者是异步的，无法通过返回值知道消息是否成功发送，默认的，无法路由至MQ服务器的消息会直接被丢弃，无任何异常抛出。</p>
<p>(1) <strong>ConfirmCallback</strong>，消息发送到<code>RabbitMQ exchange</code>（消息发送至MQ服务器）后接收ack回调。消息只要被Rabbit服务器接收到就会发调用该回调。但是不能保证消息一定会投递至目标队列，为了确保投递至目标队列，需要设置<code>ReturnCallback</code></p>
<p>注意：必需把<code>CachingConnectionFactory</code>的<code>PublierConfirms</code>设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">factory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line">rabbitTemplate.setConnectionFactory(factory);</span><br><span class="line">rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">			logger.info(<span class="string">"successed send msg to MQ server &#123;&#125;"</span>, correlationDate)</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	logger.info(<span class="string">"failed send msg to MQ server caused by &#123;&#125;"</span>, cause)</span><br><span class="line">    	&#125;</span><br><span class="line">                                                                                  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(2) <strong>ReturnCallback</strong>，消息发送至MQ服务器的exchange，但是无相应队列与该交换器绑定时的回调。发送失败的消息重新返回给生产者，在<code>returnedMessage</code>方法中处理失败的消息。</p>
<p>注意：必需把<code>CachingConnectionFactory</code>的<code>PublierReturns</code>设置为true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory factory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line"></span><br><span class="line">factory.setPublisherReturns(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">rabbitTemplate.setConnectionFactory(factory);</span><br><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> i, String s, String s1, String s2)</span> </span>&#123; </span><br><span class="line">    	<span class="comment">// process message</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：为确保接收到<code>ReturnCallback</code>、<code>ConfirmCallback</code>，channel必须处于alive的状态，当<code>channelCacheSize</code>满时，spring框架默认等待5秒然后关闭channel。所以，使用<code>ReturnCallback</code>、<code>ConfirmCallback</code>时要确保<code>channelCacheSize</code>足够大，尽可能的确保channel处于alive状态。</p>
<p>(3) 消息发送的目的得是一个不存在的exchange，底层会抛出异常并关闭连接，通过addConnectionListener，实现onShutDown方法处理该异常。见2.9节。</p>
<h4 id="3-1-3-连接池"><a href="#3-1-3-连接池" class="headerlink" title="3.1.3 连接池"></a>3.1.3 连接池</h4><p>在2.6节中，了解到为了避免connection释放出现死锁，也避免消费者因生产者阻塞而阻塞，生产者和消费者应使用独立的连接池，springboot2.0.2版本后，<code>CachingConnectionFactory</code>内部有两个连接池，一个是生产者的一个是消费者，但是要显示设置<code>usePublisherConnection</code>为ture，默认是false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>注意：如果是事务性的，此设置无效，生产者和消费者还是会共用同一个连接池。</p>
<h3 id="3-2-生产消息"><a href="#3-2-生产消息" class="headerlink" title="3.2 生产消息"></a>3.2 生产消息</h3><h4 id="3-2-1-构建消息"><a href="#3-2-1-构建消息" class="headerlink" title="3.2.1 构建消息"></a>3.2.1 构建消息</h4><p>可以直接发送字节数组，<code>SimpleMessageConverter</code>默认地封装消息的<code>ContenType、Hearder、MessageId</code>等，但有时，想要控制这些属性的生成规则，需要通过<code>MessageBuiler</code>和<code>MessagePropertiesBuilder</code>构建Spring AMQP <code>Message</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">    .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">    .setHeader(<span class="string">"bar"</span>, <span class="string">"baz"</span>)</span><br><span class="line">    .build();</span><br><span class="line">Message message = MessageBuilder.withBody(<span class="string">"foo"</span>.getBytes())</span><br><span class="line">    .andProperties(props)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-构建CorrelationData"><a href="#3-2-2-构建CorrelationData" class="headerlink" title="3.2.2 构建CorrelationData"></a>3.2.2 构建CorrelationData</h4><p><code>CorrelationData</code>是与消息关联的数据，比如，通过设置分布式的唯一id作为<code>CorrelationData</code>的id，即消息ID。可以实现消费端的去重的功能。它的定义如下，只有一个属性：id。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorrelationData</span> <span class="keyword">implements</span> <span class="title">Correlation</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String id;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorrelationData</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CorrelationData</span><span class="params">(String id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.id = id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.id = id;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CorrelationData [id="</span> + <span class="keyword">this</span>.id + <span class="string">"]"</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者设置CorrelationData</strong>：<code>RabbitTemplate</code>的<code>send()</code>方法或为<code>rabbitTemplate</code>配置<code>setCorrelationDataPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message, CorrelationData correlationData)</span> <span class="keyword">throws</span> AmqpException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者获取CorrelationData</strong>：</p>
<p>在Spring AMQP <code>Message</code>中获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String id = message.getMessageProperties().getCorrelationId();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-统一修改消息和CorrelationData"><a href="#3-2-2-统一修改消息和CorrelationData" class="headerlink" title="3.2.2 统一修改消息和CorrelationData"></a>3.2.2 统一修改消息和CorrelationData</h4><p>在消息Id自定义、消息属性统一修改、消息内容统一修改的场景下，统一的定义修改方法有利于编码和debug。<code>RabbitTemplate</code>比<code>AmqpTemplate</code>在所有send方法底层实现上都新增了关联数据<code>correlationDate</code>信息，<code>correlationDate</code>也是3.1.2中提到的消息可靠投递的支撑。</p>
<p><code>correlationDate</code>和<code>Message</code>的统一修改示例如下。可以用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">rabbitTemplate.setCorrelationDataPostProcessor(<span class="keyword">new</span> CorrelationDataPostProcessor() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorrelationData <span class="title">postProcess</span><span class="params">(Message message, CorrelationData correlationData)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="comment">// modify correlationDate   </span></span><br><span class="line">    	correlationData.setId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rabbitTemplate.setBeforePublishPostProcessors(<span class="keyword">new</span> MessagePostProcessor() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;        </span><br><span class="line">        <span class="comment">// modify message    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-发送消息"><a href="#3-3-发送消息" class="headerlink" title="3.3 发送消息"></a>3.3 发送消息</h3><p>消息的发送很简答，<code>RabbitTemplate</code>提供了众多接口供发送消息。主要有两大类：<code>send()、convertAndSend()</code>。如果使用是字节数组等非Message类型的参数作为消息，考虑采用<code>convertAndSend()</code>。如果使用的是构建好的Message，使用两者皆可。<code>send()</code>接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure>

<p>如果多除调用<code>send()</code>，可以统一为<code>rabbitTemplate</code>配置<code>routingKey、exchange</code>，这样直接调用第一个方法就可以直接实现消息的发送，这种应用场景更多的在<code>rabbitTemplate</code>只对应一个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.setExchange(<span class="string">"marketData.topic"</span>);</span><br><span class="line">amqpTemplate.setRoutingKey(<span class="string">"quotes.nasdaq.FOO"</span>);</span><br><span class="line">amqpTemplate.send(<span class="keyword">new</span> Message(<span class="string">"12.34"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>

<p>使用默认的exchange(简单模式，routingKey==queuename)，发送至固定队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.send(<span class="string">"queue.helloWorld"</span>, <span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>

<p>与上面效果一样。使用默认的exchange，发送至固定队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(); <span class="comment">// using default no-name Exchange</span></span><br><span class="line">template.setRoutingKey(<span class="string">"queue.helloWorld"</span>); <span class="comment">// but we'll always send to this Queue</span></span><br><span class="line">template.send(<span class="keyword">new</span> Message(<span class="string">"Hello World"</span>.getBytes(), someProperties));</span><br></pre></td></tr></table></figure>

<h2 id="4-消费者"><a href="#4-消费者" class="headerlink" title="4 消费者"></a>4 消费者</h2><p><em>消息接收有两种模式，简单的模式是消费者不断地去轮询，轮询到一条就消费一条，复杂些的模式是注册一个异步Listener，由容器负责接收消息并选择对应的Listener处理消息。</em></p>
<h3 id="4-1-轮询模式消费者"><a href="#4-1-轮询模式消费者" class="headerlink" title="4.1 轮询模式消费者"></a>4.1 轮询模式消费者</h3><p>在<code>springboot-amqp</code>中，可使用<code>AmqpTemplate（rabbitTemplate）</code>实现轮询模式接收消息，默认是阻塞的，有消息时就拉去消息，没有消息时，立刻返回null。</p>
<p>从springboot1.5版本以后，可以设置单次轮8询的超时时间，即消费者接收消息的阻塞时间，超时时间设置为负值，意味着无限期阻塞。并发量高时，建议使用异步Listener或将超时时间设为0.</p>
<p>如果需要转换消息格式，需要预先为AmpqTemplate设置<code>MessageConverter</code>，然后调用<code>receiveAndConvert（）</code>方法接收消息。</p>
<p>如果需要Replay，可以在调用<code>amqpTemplate.receiveAndReply()</code>接口时传入<code>ReceiveAndReplyCallBack</code>。</p>
<h3 id="4-2-异步消费者"><a href="#4-2-异步消费者" class="headerlink" title="4.2 异步消费者"></a>4.2 异步消费者</h3><p> 异步消费者中有一个预取消息（prefetch）的概念，即一个消费者预取一定数目的消息，这可能会导致多消费者情况下其他消费者利用率不足。springboot 2.0之前，预取消息默认值是1，spring boot 2.0以后，默认值为250, 预取值的设置取决于你的业务，要尽可能保证所有消费者的高效运行从而提升吞吐量。比如：</p>
<ol>
<li>当单条消息体很大，消息处理的又比较慢时，预取值如果设置的过大，将导致客户端内存占用率飙升。</li>
<li>如果严格的要求执行顺序时，建议预取值设置为1 </li>
<li>在消息吞吐量不高、消费者又多时，预取值设置的过大会导致消费者利用率不足。</li>
<li>在手动确认的模式下，预取值应该设置为1，如果prefech不为1，basicAck是异步的操作，如果出现异常时，消费者会继续处理其他预取消息，但是不会ack（批量成功时才会ack），因此，其他的消息处于unack的状态，其他的消费者会重新获取该消息，消息会出现重复消费的情况。</li>
</ol>
<h4 id="4-2-1-Message-Consuming-callback"><a href="#4-2-1-Message-Consuming-callback" class="headerlink" title="4.2.1 Message Consuming callback"></a>4.2.1 Message Consuming callback</h4><p>异步消费是通过回调实现的，消息的消费逻辑在回调方法onMessage()中实现，springboot AMQP提供了两个回调接口，MessageListener、ChannelAwareMessageListener，究竟用哪个取决于你是否需要获取channel信息，比如手动ack时必须要有channel才可以。</p>
<h4 id="4-2-2-MessageListenerAdapter"><a href="#4-2-2-MessageListenerAdapter" class="headerlink" title="4.2.2 MessageListenerAdapter"></a>4.2.2 MessageListenerAdapter</h4><p>接口回调已经可以实现消息的消费了，这还不够灵活，如果业务需要动态的指定queue或tag对应哪个methodName时，可以继承MessageListenerAdapter。它包含了下面的构造器，使用该构造器时，与前面提到的接口回调本质上是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageListenerAdapter</span><span class="params">(Object delegate)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.queueOrTagToMethodName = <span class="keyword">new</span> HashMap();    </span><br><span class="line">    <span class="keyword">this</span>.defaultListenerMethod = <span class="string">"handleMessage"</span>;</span><br><span class="line">    <span class="keyword">this</span>.doSetDelegate(delegate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delegate（翻译为中文就是代理的意思）即你定义的消费者bean，它必需是ChannelAwareMessageListener或MessageListener的实例，否则，它不会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object delegate = <span class="keyword">this</span>.getDelegate();</span><br><span class="line"><span class="keyword">if</span> (delegate != <span class="keyword">this</span>) &#123;    </span><br><span class="line">	<span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> ChannelAwareMessageListener) &#123;        </span><br><span class="line">		<span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;            	 												 			((ChannelAwareMessageListener)delegate).onMessage(message, channel);                     <span class="keyword">return</span>;        </span><br><span class="line">		&#125;       </span><br><span class="line">        <span class="keyword">if</span> (!(delegate <span class="keyword">instanceof</span> MessageListener)) &#123;           </span><br><span class="line">        		<span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">"MessageListenerAdapter cannot handle a ChannelAwareMessageListener delegate if it hasn't been invoked with a Channel itself"</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> MessageListener) &#123;        	  					 							((MessageListener)delegate).onMessage(message);        </span><br><span class="line">     			<span class="keyword">return</span>;    </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态的指定消息处理method由下面两个接口实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void setDefaultListenerMethod(String defaultListenerMethod) &#123;</span><br><span class="line">    this.defaultListenerMethod = defaultListenerMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setQueueOrTagToMethodName(Map&lt;String, String&gt; queueOrTagToMethodName) &#123;</span><br><span class="line">    this.queueOrTagToMethodName.putAll(queueOrTagToMethodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们在getListenerMethodName中被调用，如果你没有定义queueOrTagToMethodName，那么将会调用你设置的defaultListenerMethod，如果你都没有设置，那么默认值是“handleMessage”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws Exception &#123;    </span><br><span class="line">	if (this.queueOrTagToMethodName.size() &gt; 0) &#123;        </span><br><span class="line">		MessageProperties props = originalMessage.getMessageProperties();        </span><br><span class="line">		String methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerQueue());        </span><br><span class="line">		if (methodName == null) &#123;            </span><br><span class="line">			methodName = (String)this.queueOrTagToMethodName.get(props.getConsumerTag());        &#125;        </span><br><span class="line">		if (methodName != null) &#123;            </span><br><span class="line">			return methodName;       </span><br><span class="line">        &#125;    </span><br><span class="line">      &#125;    </span><br><span class="line">     </span><br><span class="line">     return this.getDefaultListenerMethod();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-容器完成了回调"><a href="#4-2-3-容器完成了回调" class="headerlink" title="4.2.3 容器完成了回调"></a>4.2.3 容器完成了回调</h4><p>现在，你已经了解了如何实现异步消费的回调接口，那么完成回调的是谁？在springboot AMQP中，完成动态处理的是容器（container），容器是有生命周期的，如启动、运行、停止，容器本质上就是桥接AMQP queue和MessageListener的实例。因此，如果想实现消费者的功能，必须为容器配置connectionFactory、队列、MessageLisener, 即告知容器：如何连接MQ服务器、成功连接后哪个队列的消息应该交给哪个消费者。</p>
<p>在springboot 2.0版本之前，只有一种容器：SimpleMessageListenerContainer。在springboot2.0以后，新增了一种容器：DirectMessageListenerContainer。二者的区别就是消费者的线程与RabbitMQ客户端线程是否共用，对于SimpleMessageListenerContainer，每一个消费者配置一个线程，如果为容器配置了多个队列，可能会使用同一个线程处理多个队列（消费者数量&lt;队列数）。并发性能取决于你设置的消费者的数conCurrentConsumer，它等于消费者线程数。</p>
<p>一个消息的后半生是这样的：spring-amqp负责将消息从MQ服务器传递给消费者，springboot-amqp提供了默认的容器，用来从MQ服务器接收消息，我们提供的消费者完成onMessage()的消息处理逻辑，并将它注册到容器上。</p>
<p>当消息从RabbitMQ客户端传递过来时，客户端线程通过队列将消息传递给消费线程（消息处理线程）。这是由于早期MQ客户端不支持并发传递消息，一个队列只会有一个线程传递消息，更不可能让它完成消息的处理，这个机制的设置当然是低效的，会增加线程之间切换的开销。</p>
<p>在新版本后，MQ客户端已经支持并发了，完全可以使用MQ客户端的线程完成消息的接收、处理工作，在DirectMessageListenerContainer中，不再区分客户端线程和消费线程，并发的控制由参数consumersPerQueue控制，不再使用conCurrentConsumer、maxConCurrentConsumer、txSize（事务大小，一次事务中传递txSize条消息，用来减少ack的次数，这个参数&gt;1且消息消费出现异常时，会导致同一个事务中后续的消息重复消费）。DirectMessageListenerContainer中提供了messagesPerAck，但是它不是事务，每一条消息都有一个独立的事务用来传递和确认，出现异常时，后续的消息会一直处于unack的状态，所以，不会重复消费。</p>
<h4 id="4-2-4-自定义容器"><a href="#4-2-4-自定义容器" class="headerlink" title="4.2.4 自定义容器"></a>4.2.4 自定义容器</h4><p>前面介绍了两种容器，而且springboot-amqp会提供默认地容器，如果想个性化的设置或有需要设置多种容器时，就需要考虑自定义容器了，在实际项目中，建议使用自定义容器。</p>
<p>现在以SimpleMessageListenerContainer为例介绍下容器的使用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAmqpConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(rabbitConnectionFactory());</span><br><span class="line">        container.setQueueName(<span class="string">"some.queue"</span>);</span><br><span class="line">        container.setMessageListener(exampleListener());</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory =</span><br><span class="line">            <span class="keyword">new</span> CachingConnectionFactory(<span class="string">"localhost"</span>);</span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListener <span class="title">exampleListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"received: "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是使用@RabbitListener注解+Java Config。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"example.queue"</span>, containerFactory = <span class="string">"exampleContainer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-容器工厂"><a href="#4-2-5-容器工厂" class="headerlink" title="4.2.5 容器工厂"></a>4.2.5 容器工厂</h4><p>容器工厂专门用来配合@RabbitListener使用，前面提到，springboot为@RabbitListener提供了默认的容器，但为了个性化的设置，建议自定义容器工厂，然后在@RabbitListener中设置”containerFactory“属性。容器和容器工厂的对应如下：</p>
<ol>
<li>SimpleMessageListenerContainer   对应   SimpleRabbitListenerContainerFactory</li>
<li>DirectMessageListenerContainer    对应    DirectRabbitListenerContainerFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>（name=<span class="string">"myContainerFactory"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> 				       					SimpleRabbitListenerContainerFactory();</span><br><span class="line">    	factory.setConnectionFactory(connectionFactory());</span><br><span class="line">    	factory.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">    	factory.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = ”myqueue“, containerFactory = <span class="string">"myContainerFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-6-容器属性"><a href="#4-2-6-容器属性" class="headerlink" title="4.2.6 容器属性"></a>4.2.6 容器属性</h4><p>前面的例子中conCurrentConsumer、connectionFactory等都是容器的属性，还有其他常用的属性：</p>
<p><a href="https://docs.spring.io/spring-amqp/docs/2.0.3.RELEASE/reference/html/_reference.html#containerAttributes" target="_blank" rel="noopener">Springboot2.0.3.RELEASE容器属性介绍</a></p>
<h5 id="（1）channelTransacted"><a href="#（1）channelTransacted" class="headerlink" title="（1）channelTransacted"></a>（1）channelTransacted</h5><p>是否在事务中ack（确认）所有消息。为true时表示需要确认事务中的所有消息。</p>
<h5 id="（2）-transactionManager"><a href="#（2）-transactionManager" class="headerlink" title="（2） transactionManager"></a>（2） transactionManager</h5><p>提供给Listener的外部事务管理器，是channelTransacted的补充，如果channel是事务的，它的事务会与外部事务进行同步。</p>
<h5 id="（3）-acknowledgeMode"><a href="#（3）-acknowledgeMode" class="headerlink" title="（3） acknowledgeMode"></a>（3） acknowledgeMode</h5><ul>
<li>NONE         配合channelTransacted=false使用，不发送ACK，MQ服务器认为所有的消息都会被确认，所以                        在RabbitMQ中称为自动ACK，但在springboot中，称为NONE ACK，视角不同导致的称谓不同。</li>
<li>MANUAL   消费者必须手动确认所有的消息，包括异常情况</li>
<li>AUTO         容器自动确认消息，除非Listener抛出容器无法自动处理的异常。该模式也是channelTransacted为true时的默认模式。追求并发时可以配合使用。</li>
</ul>
<h5 id="（4）-prefetchCount"><a href="#（4）-prefetchCount" class="headerlink" title="（4） prefetchCount"></a>（4） prefetchCount</h5><p>每个消费者能够持有的未ack的消息数，该值越大消息传输给消费者的速度越快。该参数越大，消息的顺序处理性越差。值得注意的是：在AcknowledgeMode.NONE模式下，该参数的设置是无效的，这是由于该模式下根本不存在ack。</p>
<h5 id="（5）txSize"><a href="#（5）txSize" class="headerlink" title="（5）txSize"></a>（5）txSize</h5><p>适用于SimpleMessageListenerContainer，该参数仅在AcknowledgeMode.AUTO模式下生效，容器在发送一次ack之前批量处理txSize条消息，这一批消息处于同一个事务中，会一直等待它们到超时时间，如果prefetchCount小于txSize，会自动将prefetchCount设置的与txSize相等。只能用于channelTransacted为true的场景下。</p>
<h5 id="（6）-messagePerAck"><a href="#（6）-messagePerAck" class="headerlink" title="（6） messagePerAck"></a>（6） messagePerAck</h5><p>适用于DirectMessageListenerContainer，容器在两次ack之间处理的消息数目，目的是减少向MQ服务器发送ack的次数，代价就是在出现异常时，增大重传消息的可能性，往往用在高并发场景下。在出现异常时（比如拒绝了一批消息中的某一条），则其他消息不管有没有消费完都会被ack，异常的消息被拒绝。所以它不能用在channelTransacted为true的场景。</p>
<h5 id="（7）-errorHandler"><a href="#（7）-errorHandler" class="headerlink" title="（7） errorHandler"></a>（7） errorHandler</h5><p>自定义未捕获的异常的处理机制，默认使用ConditionalRejectingErrorHandler</p>
<h4 id="4-2-7-RabbitListener"><a href="#4-2-7-RabbitListener" class="headerlink" title="4.2.7 @RabbitListener"></a>4.2.7 @RabbitListener</h4><p>异步接收消息最简单的方式是通过注解实现，前面的@RabbitListener即是，底层是MessagingMessageListenerAdapter实现的，使用注解，不需要指定methodName，因为@RabbitListener已经注明了该方法用来接收消息。在一个类中，可以定义多个不同的Listener，如下：</p>
<p>processOrder中，使用@QueueBinding声明了队列、routingkey、exchange以及他们的绑定关系</p>
<p>processInvoice中，绑定、声明了一个匿名队列，也可以声明多个@QueueBinding</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(bindings = &#123;<span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue"</span>,         </span><br><span class="line">                                                         durable = <span class="string">"true"</span>,         </span><br><span class="line">                                                         autoDelete = <span class="string">"false"</span>),         </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss"</span>)),        </span><br><span class="line">                            <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>(value = <span class="string">"myqueue2"</span>), </span><br><span class="line">                                          exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ss1"</span>))&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rcv</span><span class="params">(Message message, Channel channel)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>handleWithSimpleDeclare中，没有声明exchange，routingkey，使用默认地exchange，routingkey与队列名称相同，是direct模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>(value = <span class="string">"myQueue"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>, ignoreDeclarationExceptions = <span class="string">"true"</span>),</span><br><span class="line">        key = <span class="string">"orderRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"auto.exch"</span>),</span><br><span class="line">        key = <span class="string">"invoiceRoutingKey"</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInvoice</span><span class="params">(Invoice invoice)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(queuesToDeclare = <span class="meta">@Queue</span>(name = <span class="string">"$&#123;my.queue&#125;"</span>, durable = <span class="string">"true"</span>))</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">handleWithSimpleDeclare</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多个方法使用同种@RabbitListener时，可以自定义元注解（常用于广播fanout模式）,比如下面的例子，就使用了一个自动删除（默认地，如果不想自动删除，需要设置auto-delete为false）、匿名、广播模式的队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"metaFanout"</span>, type = ExchangeTypes.FANOUT)))</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnonFanoutListener &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnonFanoutListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">(String foo)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-异常处理"><a href="#4-3-异常处理" class="headerlink" title="4.3 异常处理"></a>4.3 异常处理</h3><h4 id="4-3-1-RabbitListener异常处理"><a href="#4-3-1-RabbitListener异常处理" class="headerlink" title="4.3.1 @RabbitListener异常处理"></a>4.3.1 @RabbitListener异常处理</h4><p>Springboot2.0版之后，@RabbitListener注解新增了errorHandler和returnException属性，默认是无配置的。</p>
<p>自定义errorHandler，需要实现RabbitListenerErrorHander接口， 并将其配置在@RabbitListener上。第二个参数messaging.Message是Message Converter产生的，ListenerExecutionFailedException是Listener抛出的。可以在自定义的handleError中处理异常，或抛出其他异常至容器，默认地，如果没有自定义errorHandler，异常将会抛至容器中。由容器的errorHandler处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RabbitListenerErrorHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">handleError</span><span class="params">(Message amqpMessage, org.springframework.messaging.Message&lt;?&gt;                     message,ListenerExecutionFailedException exception)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>returnException属性为“true”时，表示异常需要通知到生产者，一般地，不需要设置该属性，毕竟引入MQ的目的是解耦。</p>
<h4 id="4-3-2-为容器配置errorHandler"><a href="#4-3-2-为容器配置errorHandler" class="headerlink" title="4.3.2 为容器配置errorHandler"></a>4.3.2 为容器配置errorHandler</h4><p>前面提到，没有自定义errorHandler时，异常会抛至容器默认异常处理器ConditionalRejectingErrorHandler。源码如下，包含两个构造器，一个无参，一个含参，通过含参构造器可以自定义异常处理策略。若使用的无参构造器，则默认使用内部类DefaultExceptionStrategy中定义的异常处理策略。</p>
<p>11行是处理异常的接口，在13行中，异常如果不是AmqpRejectAndDontRequeueException而且是致命异常时，会抛出AmqpRejectAndDontRequeueException，致命异常的判断在37行，首先判断异常产生的原因：</p>
<p>MessagingException位于spring-messiging包下的，是异常MessageConversionException、MethodArgumentResolutionException、MessageDeliveryException、MessageHandlingException、DestinationResolutionException、MethodArgumentNotValidException、MethodArgumentTypeMismatchException、MissingSessionUserException的父类。</p>
<p>ListenerExecutionFailedException是所有异常被抛出时的最上层栈信息，所有异常都以该形式抛出。</p>
<p>39~42行是一个for循环，遍历异常产生的栈信息一层层解析异常产生的原因，一旦有MessageConversionException、MethodArgumentResolutionException就跳出循环，处理该异常，如果遍历完整个循环都没有出现，则处理最后一个异常（42行cause = cause.getCause()）。<strong>因此，如果有多个异常均需要处理时，建议重写isFatal方法</strong>。</p>
<p>59-67行判断cause是否致命，有六种：</p>
<ul>
<li>Spring AMQP的MessageConversionException异常</li>
<li>spring-messaging的MessageConversionException异常</li>
<li>spring-messaging的MethodArgumentResolutionException异常</li>
<li>NoSuchMethodException异常</li>
<li>ClassCastException异常</li>
<li>自定义的异常isUserCauseFatal</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.rabbit.listener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// omit the package import for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRejectingErrorHandler</span> <span class="keyword">implements</span> <span class="title">ErrorHandler</span> </span>&#123;    </span><br><span class="line"><span class="number">2</span>    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());    </span><br><span class="line"><span class="number">3</span>    <span class="keyword">private</span> <span class="keyword">final</span> FatalExceptionStrategy exceptionStrategy;    </span><br><span class="line"><span class="number">4</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">5</span>        <span class="keyword">this</span>.exceptionStrategy = <span class="keyword">new</span> </span><br><span class="line"><span class="number">6</span>            ConditionalRejectingErrorHandler.DefaultExceptionStrategy();    </span><br><span class="line"><span class="number">7</span>    &#125;    </span><br><span class="line"><span class="number">8</span>    <span class="function"><span class="keyword">public</span> <span class="title">ConditionalRejectingErrorHandler</span><span class="params">(FatalExceptionStrategy exceptionStrategy)</span> </span>&#123; <span class="number">9</span>       		<span class="keyword">this</span>.exceptionStrategy = exceptionStrategy;                               <span class="number">10</span>          &#125;    </span><br><span class="line"><span class="number">11</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">this</span>.log(t);        </span><br><span class="line"><span class="number">13</span>        <span class="keyword">if</span> (!<span class="keyword">this</span>.causeChainContainsARADRE(t) &amp;&amp; <span class="keyword">this</span>.exceptionStrategy.isFatal(t)) &#123;   <span class="number">14</span>              <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"Error Handler converted     15                       exception to fatal"</span>, t);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125;    </span><br><span class="line"><span class="number">18</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">this</span>.logger.warn(<span class="string">"Execution of Rabbit message listener failed."</span>, t);       </span><br><span class="line"><span class="number">21</span>        &#125;    </span><br><span class="line"><span class="number">22</span>    &#125;    </span><br><span class="line"><span class="number">23</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">causeChainContainsARADRE</span><span class="params">(Throwable t)</span> </span>&#123;        </span><br><span class="line"><span class="number">24</span>        <span class="keyword">for</span>(Throwable cause = t.getCause(); cause != <span class="keyword">null</span>; cause = cause.getCause()) &#123; <span class="number">25</span>               <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> AmqpRejectAndDontRequeueException) &#123;               </span><br><span class="line"><span class="number">26</span>                	<span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">27</span>             &#125;        </span><br><span class="line"><span class="number">28</span>        &#125;        </span><br><span class="line"><span class="number">29</span>        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line"><span class="number">30</span>    &#125;    </span><br><span class="line"><span class="number">31</span>    </span><br><span class="line"><span class="number">32</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExceptionStrategy</span> <span class="keyword">implements</span> <span class="title">FatalExceptionStrategy</span> </span>&#123;   <span class="number">33</span>     </span><br><span class="line"><span class="number">34</span>        <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());        </span><br><span class="line"><span class="number">35</span>        <span class="function"><span class="keyword">public</span> <span class="title">DefaultExceptionStrategy</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="number">36</span>        &#125;        </span><br><span class="line"><span class="number">37</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFatal</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line"><span class="number">38</span>            Throwable cause;            </span><br><span class="line"><span class="number">39</span>            <span class="keyword">for</span>(cause = t.getCause(); cause <span class="keyword">instanceof</span> MessagingException </span><br><span class="line"><span class="number">40</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MessageConversionException) </span><br><span class="line"><span class="number">41</span>                &amp;&amp; !(cause <span class="keyword">instanceof</span> MethodArgumentResolutionException); </span><br><span class="line"><span class="number">42</span>                cause = cause.getCause()) &#123;                </span><br><span class="line"><span class="number">43</span>                ;            </span><br><span class="line"><span class="number">44</span>            &#125;            </span><br><span class="line"><span class="number">45</span>            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ListenerExecutionFailedException </span><br><span class="line"><span class="number">46</span>                &amp;&amp; <span class="keyword">this</span>.isCauseFatal(cause)) &#123;                </span><br><span class="line"><span class="number">47</span>                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;                    </span><br><span class="line"><span class="number">48</span>                    <span class="keyword">this</span>.logger.warn(<span class="string">"Fatal message conversion error; message rejected; 49                      it will be dropped or routed to a dead letter exchange, if so     50                        configured: "</span> + ((ListenerExecutionFailedException)t)</span><br><span class="line"><span class="number">51</span>                                     .getFailedMessage());                </span><br><span class="line"><span class="number">52</span>                &#125;                </span><br><span class="line"><span class="number">53</span>                <span class="keyword">return</span> <span class="keyword">true</span>;            </span><br><span class="line"><span class="number">54</span>            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line"><span class="number">55</span>                <span class="keyword">return</span> <span class="keyword">false</span>;            </span><br><span class="line"><span class="number">56</span>            &#125;        </span><br><span class="line"><span class="number">57</span>        &#125;        </span><br><span class="line"><span class="number">58</span>                                                                                     </span><br><span class="line"><span class="number">59</span>		<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">60</span>            <span class="keyword">return</span> cause <span class="keyword">instanceof</span> </span><br><span class="line"><span class="number">61</span>                org.springframework.amqp.support.converter.MessageConversionException </span><br><span class="line"><span class="number">62</span>                || cause <span class="keyword">instanceof</span> MessageConversionException </span><br><span class="line"><span class="number">63</span>                || cause <span class="keyword">instanceof</span> MethodArgumentResolutionException </span><br><span class="line"><span class="number">64</span>                || cause <span class="keyword">instanceof</span> NoSuchMethodException </span><br><span class="line"><span class="number">65</span>                || cause <span class="keyword">instanceof</span> ClassCastException </span><br><span class="line"><span class="number">66</span>                || <span class="keyword">this</span>.isUserCauseFatal(cause);        </span><br><span class="line"><span class="number">67</span>        &#125;        </span><br><span class="line"><span class="number">68</span>        </span><br><span class="line"><span class="number">69</span>      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isUserCauseFatal</span><span class="params">(Throwable cause)</span> </span>&#123;            </span><br><span class="line"><span class="number">70</span>            <span class="keyword">return</span> <span class="keyword">false</span>;        </span><br><span class="line"><span class="number">71</span>      &#125;    </span><br><span class="line"><span class="number">72</span>   &#125;</span><br><span class="line"><span class="number">73</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以选择完全自定义异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listenerContainerFactory.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;            </span><br><span class="line">        <span class="comment">// do something handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-补充说明"><a href="#4-3-3-补充说明" class="headerlink" title="4.3.3 补充说明"></a>4.3.3 补充说明</h4><p>对于消息的异常处理springboot2.0.3还不够完善。比如使用的@RabbitListener、AcknowledgeMent.MANUAL发送一条空的消息，这条消息无法到达自定义的onMessage()方法，提前抛出了异常，若尝试通过RabbitListenerErrorHandler处理异常，并按照下面的方式自定义了一个errorHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"myErrorHandler"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerErrorHandler <span class="title">rabbitListenerErrorHandler</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerErrorHandler() &#123;       </span><br><span class="line">        <span class="meta">@Override</span>        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleError</span><span class="params">(Message message, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  org.springframework.messaging.Message&lt;?&gt; message1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  ListenerExecutionFailedException e)</span> <span class="keyword">throws</span> Exception </span>&#123;            <span class="comment">// 如果消息是空的，这条消息不再归队            </span></span><br><span class="line">            <span class="keyword">if</span> (message.getBody().length == <span class="number">0</span>) &#123;                </span><br><span class="line">                Channel channel = message1.getHeaders().get(AmqpHeaders.CHANNEL, </span><br><span class="line">                                                            Channel.class);</span><br><span class="line">                logger.error(<span class="string">"rcv error"</span>);</span><br><span class="line">                Channel channel1 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line">                Channel channel2 = (Channel)message1.getHeaders().getReplyChannel();</span><br><span class="line"></span><br><span class="line">                logger.error(<span class="string">"channel1=&#123;&#125;"</span>, channel);</span><br><span class="line">                logger.error(<span class="string">"channel2=&#123;&#125;"</span>, channel2);</span><br><span class="line">                <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logger.error（”channel <span class="keyword">null</span>，can not send ack...“）</span><br><span class="line">                    <span class="keyword">throw</span> e;                </span><br><span class="line">                &#125;                </span><br><span class="line">                channel.basicReject(message1.getHeaders().get(AmqpHeaders.DELIVERY_TAG, </span><br><span class="line">                                                              Long.class), <span class="keyword">false</span>);              </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"msg format error"</span>);         </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">throw</span> e;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送10条empty的消息，打印了10次：channel null，can not send ack…</p>
<p>这10条消息一直处于unack的状态，消息并没有被reject，而是一直处于unack的状态,但是该消息是无意义的,不应该再重新入队.</p>
<p>原因：<br>springboot ListenerContainer负责传递消息给消费者，容器通过反射调用自定义的Listener并处理消息时出现参数错误异常，message转byte异常报错。<br>由于方法参数反射错误，无法调用到onMessage方法，又采用的手动确认的方式，导致没办法通过channel.basicReject拒绝该消息，所以这条消息会一直处于unack的状态。</p>
<p>解决的方法有三种：<br>1、升级springboot至2.1.6版本，在Listener容器中注册RabbitListenerErrorHandler，该版本中，可以通过org.springframework.messaging.Message获取channel信息。通过channel拒绝该消息。在之前的版本中，获取到的channel都是null(如代码所示，channel、channel1、channel2均为null，说明spring没有将channel信息封装在org.springframework.messaging.Message)，无法给MQ服务器发送ACK。<br>2、修改onMessage()的参数，使用Message类型作为消息的载体，不再使用byte、string等其他类型，定义MessageConverter或使用默认的MessageConverter实现消息格式转换。<br>3、使用springboot的Acknowledge.AUTO模式，该模式下Listener容器会自动发送ACK给MQ服务器</p>
<p>4、自定义MessageConveter</p>
<p>最后使用了方法2，springboot升级会带来兼容性的问题，比如数据库驱动、数据库版本等，方法3中交给容器自动确认更适合高并发设置多个消费者同时消费1个队列、添加一些批量拉取消息、批量事务处理的场景，该场景会牺牲消息的有序性、异常时可能会有重复消费的问题。我们现在的业务场景更偏向于保证消息的可靠性，一个队列只会有一个消费者，消费一条拉取一条，消息处理的线程池也是自定义的，这样的方式更灵活稳定。所以最后否定了方法3，选用方案2</p>
<h2 id="5-Message-Convert"><a href="#5-Message-Convert" class="headerlink" title="5 Message Convert"></a>5 Message Convert</h2><p>可以为<code>ListenerContainer</code>和<code>RabbitTemplate</code>设置<code>MessageConverter</code>。这样就不用每次都写重复的消息格式转换代码了。spring提供的Message Converter均是双向的，负责将入站消息转换为特定结构（如：字节数组、序列化java对象、字符串、自定义的消息domain对象），将特定格式转换为出站消息。</p>
<h3 id="5-1-消息格式"><a href="#5-1-消息格式" class="headerlink" title="5.1 消息格式"></a>5.1 消息格式</h3><p>springboot-amqp涉及到两种消息格式，定义如下：</p>
<ol>
<li><p>org.springframework.messaging.Message&lt;?&gt; message，spring框架中通用的Message。简称<code>spring-messaging Message</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">		<span class="function">T <span class="title">getPayload</span><span class="params">()</span></span>;    </span><br><span class="line">		<span class="function">MessageHeaders <span class="title">getHeaders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>spring AMQP Message</code>，spring为了适配AMQP协议，简化接口参数引入的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>spring-messaging Message</code>中的<code>payload</code>对应了<code>spring AMQP Message</code>中的<code>byte[] body</code>，他们均是Rabbit Client 中的body，即消息内容。</p>
<p><code>spring-messaging Message</code>中的<code>MessageHeaders</code>对应了<code>spring AMQP Message</code>中的<code>MessageProperties</code>，他们均是Rabbit Client 中的<code>BasicProperties</code>，即消息头。</p>
<p>因此，后文的MessgeConverter如不加特殊说明，均指的消息内容的格式转换。消息头的格式转换见<code>2.3.7 MessagePropertiesConverter</code></p>
<h3 id="5-2-RabbitListener底层实现原理"><a href="#5-2-RabbitListener底层实现原理" class="headerlink" title="5.2 @RabbitListener底层实现原理"></a>5.2 @RabbitListener底层实现原理</h3><p>在了解MessageConveter之前，有必要清楚spring底层消息处理机制，此处以最常用的<code>@RabbitListener</code>为例。</p>
<p>通过注解<code>@RabbitListener</code>声明一个消费者时，底层由<code>MessagingMessageListenerAdapter</code>的<code>onMessage()</code>负责处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message amqpMessage, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    org.springframework.messaging.Message&lt;?&gt; message = </span><br><span class="line"><span class="number">4</span>        <span class="keyword">this</span>.toMessagingMessage(amqpMessage);    </span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">6</span>    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;        </span><br><span class="line"><span class="number">7</span>        <span class="keyword">this</span>.logger.debug(<span class="string">"Processing ["</span> + message + <span class="string">"]"</span>);    </span><br><span class="line"><span class="number">8</span>    &#125;</span><br><span class="line"><span class="number">9</span>    </span><br><span class="line"><span class="number">10</span>    <span class="keyword">try</span> &#123;        </span><br><span class="line"><span class="number">11</span>        Object result = <span class="keyword">this</span>.invokeHandler(amqpMessage, channel, message);        </span><br><span class="line"><span class="number">12</span>        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">13</span>            <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);        </span><br><span class="line"><span class="number">14</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">15</span>            <span class="keyword">this</span>.logger.trace(<span class="string">"No result object given - no result to handle"</span>);        </span><br><span class="line"><span class="number">16</span>        &#125;    </span><br><span class="line"><span class="number">17</span>    &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException var7) &#123;       </span><br><span class="line"><span class="number">18</span>        ListenerExecutionFailedException e = var7;        </span><br><span class="line"><span class="number">19</span>        <span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;            </span><br><span class="line"><span class="number">20</span>            <span class="keyword">try</span> &#123;               </span><br><span class="line"><span class="number">21</span>                Object result = <span class="keyword">this</span>.errorHandler.handleError(amqpMessage, message, e); <span class="number">22</span>               </span><br><span class="line"><span class="number">23</span>                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;                    </span><br><span class="line"><span class="number">24</span>                    <span class="keyword">this</span>.handleResult(result, amqpMessage, channel, message);           <span class="number">25</span>  </span><br><span class="line"><span class="number">26</span>                &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line"><span class="number">27</span>                    <span class="keyword">this</span>.logger.trace(<span class="string">"Error handler returned no result"</span>);             <span class="number">28</span>  </span><br><span class="line"><span class="number">29</span>                &#125;            </span><br><span class="line"><span class="number">30</span>            &#125; <span class="keyword">catch</span> (Exception var6) &#123;                </span><br><span class="line"><span class="number">31</span>                <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var6, var6);         <span class="number">32</span>  </span><br><span class="line"><span class="number">33</span>            &#125;        </span><br><span class="line"><span class="number">34</span>        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line"><span class="number">35</span>            <span class="keyword">this</span>.returnOrThrow(amqpMessage, channel, message, var7.getCause(), var7);   <span class="number">36</span>     </span><br><span class="line"><span class="number">37</span>        &#125;    </span><br><span class="line"><span class="number">38</span>    &#125;</span><br><span class="line"><span class="number">39</span> &#125;</span><br></pre></td></tr></table></figure>

<p>3~4行，通过<code>toMessagingMessage()</code>将spring AMQP的Message转换为spring-messaging的Message。<code>this.getMessagingMessageConverter</code>是一个内部类的实例，内部类继承了<code>MessagingMessageConverter</code>，最终调用的是<code>MessagingMessageConverter</code>的<code>fromMessage</code>。完成Spring AMQP Message至spring-messaging Message的转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> org.springframework.messaging.Message&lt;?&gt; toMessagingMessage(Message amqpMessage) &#123;    </span><br><span class="line">    <span class="keyword">return</span> (org.springframework.messaging.Message)<span class="keyword">this</span></span><br><span class="line">        .getMessagingMessageConverter()</span><br><span class="line">        .fromMessage(amqpMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fromMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        Map&lt;String, Object&gt; mappedHeaders = </span><br><span class="line">            <span class="keyword">this</span>.headerMapper.toHeaders(message.getMessageProperties()); </span><br><span class="line">        </span><br><span class="line">        Object convertedObject = <span class="keyword">this</span>.extractPayload(message);  </span><br><span class="line">        </span><br><span class="line">        MessageBuilder&lt;Object&gt; builder = convertedObject <span class="keyword">instanceof</span> </span><br><span class="line">            org.springframework.messaging.Message ? </span><br><span class="line">       MessageBuilder.fromMessage((org.springframework.messaging.Message)convertedObject) </span><br><span class="line">            : MessageBuilder.withPayload(convertedObject);        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> builder.copyHeadersIfAbsent(mappedHeaders).build();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11行通过反射处理消息，调用的是<code>HandlerAdapter</code>中的<code>invoke()</code>，为了简便，把这些调用全部放在了同一个代码块中，一般地，使用<code>@RabbitListener</code>时不会自定义<code>invokHandler</code>，所以调用的是代理的反射方法：<code>delegatingHandler.invoke()</code></p>
<p>再继续关注下<code>getMethodArgumentValues</code>，包含了两部分，一部分是预设参数转换，如：<code>Message</code>、<code>Channel</code>，这个也是最开始传入Spring AMQP的<code>Message</code>的原因，它的作用就是作为预设参数，另一部分是Listener中消息处理的其他自定义参数，如@Payload注解、@Headers注解等声明的参数，<code>args[i] == null</code>时，抛出<code>MethodArgumentResolutionException</code>异常，这就是1.3中异常抛出的地方，参数为空。该异常会一直向上抛，直至17行被捕获，如果在Listener容器中注册了<code>errorHandler</code>，调用<code>errorHandler</code>处理异常。</p>
<p>还有一点值得注意的是：在整个过程中，真正作为消息载体的就是<code>spring-messaging.Message</code>而不是Spring AMQP的`Message。因此，<strong>消息处理的过程实际如下：</strong></p>
<p><strong>调用RabbitMQ JAVA API接收消息并封装为<code>Spring AMQP Message</code>，在消息处理onMessage中调用<code>toMessagingMessage(Message amqpMessage)</code>将消息转换至<code>spring-messaging.Message</code>,通过反射处理消息。</strong></p>
<p><strong>因此，消息转换实际上包含了两个过程，一个是消息的反序列化并封装为<code>Spring AMQP Message</code>，另一个是<code>Spring AMQP Message</code>与<code>spring-messaging.Message</code>之间的转换。</strong>后文中所指的消息转换如果不加特别说明，均指第一个转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeHandler</span><span class="params">(Message amqpMessage, Channel channel, org.springframework.messaging.Message&lt;?&gt; message)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.handlerMethod.invoke(message, <span class="keyword">new</span> Object[]&#123;amqpMessage, channel&#125;);   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException var5) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">            ListenerExecutionFailedException(<span class="keyword">this</span>.createMessagingErrorMessage(<span class="string">"Listener         	  method could not be invoked with the incoming message"</span>,                                   message.getPayload()),             </span><br><span class="line">            var5, amqpMessage);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (Exception var6) &#123;        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">"Listener method '"</span> +                  		  <span class="keyword">this</span>.handlerMethod.getMethodAsString(message.getPayload())                               + <span class="string">"' threw exception"</span>, var6, amqpMessage);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandlerAdapter中的invoke</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.invokerHandlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.invokerHandlerMethod.invoke(message, providedArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.delegatingHandler.hasDefaultHandler()) &#123;</span><br><span class="line">            Object[] args = <span class="keyword">new</span> Object[providedArgs.length + <span class="number">1</span>];</span><br><span class="line">            args[<span class="number">0</span>] = message.getPayload();</span><br><span class="line">            System.arraycopy(providedArgs, <span class="number">0</span>, args, <span class="number">1</span>, providedArgs.length);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.delegatingHandler.invoke(message, providedArgs);</span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegatingHandler.invoke()</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;? extends Object&gt; payloadClass = message.getPayload().getClass();</span><br><span class="line">        InvocableHandlerMethod handler = <span class="keyword">this</span>.getHandlerForPayload(payloadClass);</span><br><span class="line">        Object result = handler.invoke(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (message.getHeaders().get(<span class="string">"amqp_replyTo"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Expression replyTo = (Expression)<span class="keyword">this</span>.handlerSendTo.get(handler);</span><br><span class="line">            <span class="keyword">if</span> (replyTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = <span class="keyword">new</span> ResultHolder(result, replyTo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理完成的invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Message&lt;?&gt; message, Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object[] args = <span class="keyword">this</span>.getMethodArgumentValues(message, providedArgs);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Invoking '"</span> + 	 	                                                 ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(), <span class="keyword">this</span>.getBeanType())</span><br><span class="line">                              + <span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object returnValue = <span class="keyword">this</span>.doInvoke(args);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Method ["</span> + 				    			                             ClassUtils.getQualifiedMethodName(<span class="keyword">this</span>.getMethod(),<span class="keyword">this</span>.getBeanType()) </span><br><span class="line">            + <span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注下getMethodArgumentValues</span></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(Message&lt;?&gt; message, Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        MethodParameter[] parameters = <span class="keyword">this</span>.getMethodParameters();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; ++i) &#123;</span><br><span class="line">            MethodParameter parameter = parameters[i];</span><br><span class="line">            parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">            args[i] = <span class="keyword">this</span>.resolveProvidedArgument(parameter, providedArgs);<span class="comment">//预设参数的转换</span></span><br><span class="line">            <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        args[i] = <span class="keyword">this</span>.argumentResolvers</span><br><span class="line">                            .resolveArgument(parameter, message);<span class="comment">// 自定义的参数的转换</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.debug(<span class="keyword">this</span>.getArgumentResolutionErrorMessage(</span><br><span class="line">                                <span class="string">"Failed to resolve"</span>, i), var8);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> var8;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentResolutionException(</span><br><span class="line">                        message, parameter, <span class="keyword">this</span>.getArgumentResolutionErrorMessage( </span><br><span class="line">                                            <span class="string">"No suitable resolver for"</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    <span class="keyword">return</span> args;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-已有的MessageConverter"><a href="#5-3-已有的MessageConverter" class="headerlink" title="5.3 已有的MessageConverter"></a>5.3 已有的MessageConverter</h3><p>前面提到，消息格式转换有两次，第一次转换完成序列化与反序列化的工作，被称为<code>Message Converter</code>，spring AMQP提供了默认的转换器<code>SimpleMessageConverter</code>。以反序列化为例，将Spring AMQP Message转换为字符串、序列化对象、字节数组，这次转换也是文中所指的Message Convert。反序列化源码如下：</p>
<p>第二次转换，springboot默认使用的是GenericMessageConverter。它是属于org.springframework.messaging.包下的，继承了该包下的SimpleMessageConverter（第一次转换的SimpleMessageConverter在org.springframework.amqp包下），默认情况下，不需要特别的设置。</p>
<p>spring-messaging的<code>MessageConverter</code>是所有消息转换器（无论是<code>spring-messaging</code>还是spring AMQP`）最底层的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.messaging.converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageHeaders;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;   </span><br><span class="line">    <span class="meta">@Nullable</span>    </span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message&lt;?&gt; var1, Class&lt;?&gt; var2)</span></span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span>    Message&lt;?&gt; toMessage(Object var1, <span class="meta">@Nullable</span> MessageHeaders var2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-1-SimpleMessageConverter"><a href="#5-3-1-SimpleMessageConverter" class="headerlink" title="5.3.1 SimpleMessageConverter"></a>5.3.1 SimpleMessageConverter</h4><p>spring AMQP的<code>SimpleMessageConverter</code>实现了<code>MessageConverter</code>接口（最底层），是默认的消息转换器。在未给<code>RabbitTemplate</code>配置message conveter时，将会调用<code>SimpleMessageConverter</code>的<code>fromMessage</code>和<code>createMessage</code>处理消息，从源码可以看出，支持三种类型：字符串、序列化java对象，字节数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.support.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamClass;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.utils.SerializationUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.remoting.rmi.CodebaseAwareObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ClassUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMessageConverter</span> <span class="keyword">extends</span> <span class="title">WhiteListDeserializingMessageConverter</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CHARSET = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String defaultCharset = <span class="string">"UTF-8"</span>;    </span><br><span class="line">    <span class="keyword">private</span> String codebaseUrl;    </span><br><span class="line">    <span class="keyword">private</span> ClassLoader beanClassLoader = ClassUtils.getDefaultClassLoader();    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMessageConverter</span><span class="params">()</span> </span>&#123;    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader beanClassLoader)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.beanClassLoader = beanClassLoader;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCodebaseUrl</span><span class="params">(String codebaseUrl)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.codebaseUrl = codebaseUrl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultCharset</span><span class="params">(String defaultCharset)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.defaultCharset = defaultCharset != <span class="keyword">null</span> ? defaultCharset : <span class="string">"UTF-8"</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123; </span><br><span class="line">        Object content = <span class="keyword">null</span>;        </span><br><span class="line">        MessageProperties properties = message.getMessageProperties();        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (properties != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            String contentType = properties.getContentType();            </span><br><span class="line">            <span class="keyword">if</span> (contentType != <span class="keyword">null</span> &amp;&amp; contentType.startsWith(<span class="string">"text"</span>)) &#123;                </span><br><span class="line">                String encoding = properties.getContentEncoding();                </span><br><span class="line">                <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                    encoding = <span class="keyword">this</span>.defaultCharset;                </span><br><span class="line">                &#125;                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    content = <span class="keyword">new</span> String(message.getBody(), encoding);                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var8) &#123;                    </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert text-based                                                            Message content"</span>, var8);         </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (contentType != <span class="keyword">null</span> </span><br><span class="line">                       &amp;&amp; contentType.equals(<span class="string">"application/x-java-serialized-object"</span>)) &#123;                </span><br><span class="line">              		<span class="keyword">try</span> &#123;                    </span><br><span class="line">                        content = SerializationUtils</span><br><span class="line">                            .deserialize(<span class="keyword">this</span>.createObjectInputStream(</span><br><span class="line">                       <span class="keyword">new</span> ByteArrayInputStream(message.getBody()),<span class="keyword">this</span>.codebaseUrl));                &#125; <span class="keyword">catch</span> (IllegalArgumentException                                                                 | IllegalStateException                                                                   | IOException var7) &#123;                    </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert                                                           serialized Message content"</span>, var7);       </span><br><span class="line">                    &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            content = message.getBody();        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> content;    </span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Message <span class="title">createMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span> </span></span><br><span class="line"><span class="function">                                                    <span class="keyword">throws</span> MessageConversionException </span>&#123;        </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;            </span><br><span class="line">            bytes = (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])object);            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/octet-stream"</span>);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = ((String)object).getBytes(<span class="keyword">this</span>.defaultCharset);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var6) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to Message                                                             content"</span>, var6);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"text/plain"</span>);           </span><br><span class="line">            messageProperties.setContentEncoding(<span class="keyword">this</span>.defaultCharset);        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Serializable) &#123;            </span><br><span class="line">            <span class="keyword">try</span> &#123;                </span><br><span class="line">                bytes = SerializationUtils.serialize(object);            </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;                </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MessageConversionException(<span class="string">"failed to convert to serialized                                                          Message content"</span>, var5);            </span><br><span class="line">            &#125;            </span><br><span class="line">            messageProperties.setContentType(<span class="string">"application/x-java-serialized-object"</span>);        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;            </span><br><span class="line">            messageProperties.setContentLength((<span class="keyword">long</span>)bytes.length);            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Message(bytes, messageProperties);        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" only                            supports String, byte[] and Serializable payloads, received: "</span> + </span><br><span class="line">                                               object.getClass().getName());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">createObjectInputStream</span><span class="params">(InputStream is, String </span></span></span><br><span class="line"><span class="function"><span class="params">                                                        codebaseUrl)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CodebaseAwareObjectInputStream(is, <span class="keyword">this</span>.beanClassLoader, codebaseUrl) </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass classDesc) <span class="keyword">throws</span> </span><br><span class="line">                IOException, ClassNotFoundException &#123;                </span><br><span class="line">                Class&lt;?&gt; clazz = <span class="keyword">super</span>.resolveClass(classDesc);                </span><br><span class="line">                SimpleMessageConverter.<span class="keyword">this</span>.checkWhiteList(clazz);                </span><br><span class="line">                <span class="keyword">return</span> clazz;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-SerializerMessageConverter"><a href="#5-3-2-SerializerMessageConverter" class="headerlink" title="5.3.2 SerializerMessageConverter"></a>5.3.2 SerializerMessageConverter</h4><p>与<code>SimpleMessageConverter</code>类似，唯一不同的是，多了一个属性用来自定义序列化与反序列化规则。</p>
<h4 id="5-3-3-Jackson2JsonMessageConverter"><a href="#5-3-3-Jackson2JsonMessageConverter" class="headerlink" title="5.3.3 Jackson2JsonMessageConverter"></a>5.3.3 Jackson2JsonMessageConverter</h4><p>消息载体是网络字节序时，使用默认的<code>SimpleMessageConverter</code>就足够了，但是消息载体为java序列化对象<code>application/x-java-serialized-object</code>时，不利于跨语言和跨平台，更推荐使用JSON作为消息的载体，<code>Jackson2JsonMessageConverter</code>负责JSON和java bean之间转换。使用时将<code>jsonConverter</code>注入<code>rabbitTemplate</code>实例中,替换<code>SimpleMessageConverter</code>。在替换后，收发消息可以直接发送消息Object的实例，大大得简化了开发。</p>
<p><strong>注意事项：</strong></p>
<p>使用时，需要生产者额外在消息头中添加一个字段<code>”__ TypeId __ “</code>用于注明该消息映射的domain对象，在下方的示例中，头信息中的字段<code>&quot;__ TypeId __&quot;</code>分别<code>&quot;foo&quot;</code>和<code>”bar“</code>如果生产者未注明，可以为classMapper设置默认值映射domain对象，例如：<code>classMapper.setDefaultType(MyMessage.class)</code>。</p>
<p>需要生产者在消息头注明contentType为<code>application/json或text/x-json</code> 或者生产者也使用 <code>Jackson2JsonMessageConverter</code>，它会自动在消息头中声明contentType。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Jackson2JsonMessageConverter jsonConverter = <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    jsonConverter.setClassMapper(classMapper());</span><br><span class="line">    <span class="keyword">return</span> jsonConverter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultClassMapper <span class="title">classMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultClassMapper classMapper = <span class="keyword">new</span> DefaultClassMapper();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    idClassMapping.put(<span class="string">"foo"</span>, Foo.class);</span><br><span class="line">    idClassMapping.put(<span class="string">"bar"</span>, Bar.class);</span><br><span class="line">    classMapper.setIdClassMapping(idClassMapping);</span><br><span class="line">    <span class="keyword">return</span> classMapper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-4-ContentTypeDelegatingMessageConverter"><a href="#5-3-4-ContentTypeDelegatingMessageConverter" class="headerlink" title="5.3.4  ContentTypeDelegatingMessageConverter"></a>5.3.4  ContentTypeDelegatingMessageConverter</h4><p>顾名思义，<code>ContentTypeDelegatingMessageConverter</code>是一个根据消息头中<code>content-Type</code>动态选择<code>MessageConverter</code>的Message Converter。当<code>content-Type</code>为空或根据<code>content-Type</code>匹配不到<code>MessageConverter</code>时，将Message Convert的任务委托给<code>SimpleMessageConverter</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"contentTypeConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"ContentTypeDelegatingMessageConverter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"delegates"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/json"</span> value-ref=<span class="string">"jsonMessageConverter"</span> /&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"application/xml"</span> value-ref=<span class="string">"xmlMessageConverter"</span> /&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-MarshallingMessageConverter"><a href="#2-3-5-MarshallingMessageConverter" class="headerlink" title="2.3.5 MarshallingMessageConverter"></a>2.3.5 MarshallingMessageConverter</h4><p>负责Spring的Object与XML之间的转换。</p>
<h4 id="5-3-6-为默认的Message-Converter设置反序列化权限"><a href="#5-3-6-为默认的Message-Converter设置反序列化权限" class="headerlink" title="5.3.6 为默认的Message Converter设置反序列化权限"></a>5.3.6 为默认的Message Converter设置反序列化权限</h4><p>在处理 <code>content-type</code> 为<code>application/x-java-serialized-object</code>的java序列化对象时，默认会扫描所有的packages/classes，为了提高安全性，可以设置白名单，所有的Message Converter都有一个属性whiteListPatterns，示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SimpleMessageConverter messageConverter = <span class="keyword">new</span> SimpleMessageConverter();List&lt;String&gt; </span><br><span class="line"></span><br><span class="line">myWhiteList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"safe.*"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"unstable.recent.SafeClass"</span>);</span><br><span class="line">myWhiteList.add(<span class="string">"*.MySafeClass"</span>);</span><br><span class="line"></span><br><span class="line">messageConverter.setWhiteListPatterns(myWhiteList);</span><br></pre></td></tr></table></figure>

<p>注意：该属性仅在<code>Message Converter</code>使用<code>DefaultDeserializer</code>有效，即不要主动去配置<code>DefaultDeserializer</code>。</p>
<h4 id="5-3-7-MessagePropertiesConverter"><a href="#5-3-7-MessagePropertiesConverter" class="headerlink" title="5.3.7 MessagePropertiesConverter"></a>5.3.7 MessagePropertiesConverter</h4><p>前面介绍的MessageConverter负责body的转换，MessagePropertiesConverter 负责Rabbit Client的<code>BasicProperties</code>与Spring AMQP <code>MessageProperties</code>之间的转换，它的默认实现是<code>DefaultMessagePropertiesConverter</code>，足以满足绝多数场景下的需求。部分源码如下，仅截取了构造器和属性声明，当<code>BasicProperties</code>中的某一元素长度小于等于<code>longStringLimit</code>时，转化为<code>MessageProperties</code>中的String属性，当<code>BasicProperties</code>中的某一元素长度超过<code>longStringLimit</code>时，根据<code>convertLongLongStrings</code>判断是否需要转换为LongString，如果不需要则转换为<code>DataInputStream</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMessagePropertiesConverter</span> <span class="keyword">implements</span> <span class="title">MessagePropertiesConverter</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LONG_STRING_LIMIT = <span class="number">1024</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> longStringLimit;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> convertLongLongStrings;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(<span class="number">1024</span>, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>(longStringLimit, <span class="keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultMessagePropertiesConverter</span><span class="params">(<span class="keyword">int</span> longStringLimit, </span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">boolean</span> convertLongLongStrings)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.longStringLimit = longStringLimit;        </span><br><span class="line">        <span class="keyword">this</span>.convertLongLongStrings = convertLongLongStrings;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">convertLongString</span><span class="params">(LongString longString, String charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (longString.length() &lt;= (<span class="keyword">long</span>)<span class="keyword">this</span>.longStringLimit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(longString.getBytes(), charset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.convertLongLongStrings ? longString.getStream() : longString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/threadLocal/" rel="prev" title="threadLocal原理">
                threadLocal原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shipengyang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基础知识"><span class="nav-number">1.</span> <span class="nav-text">1 基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-连接管理"><span class="nav-number">2.</span> <span class="nav-text">2 连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-channelCacheSize"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 channelCacheSize</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-默认仅限制缓存的channelSize"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 默认仅限制缓存的channelSize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-channelSize限制"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 channelSize限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-为连接命名"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 为连接命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-使用RabbitMQ-client的connectionFactory"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 使用RabbitMQ client的connectionFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-自定义RabbitClient的属性"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 自定义RabbitClient的属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-连接恢复"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 连接恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-关闭Rabbit-Client的自动恢复"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 关闭Rabbit Client的自动恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-SSL连接"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 SSL连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-避免Connection死锁"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 避免Connection死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-Routing-ConnectionFactory实现多数据源收发消息"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 Routing ConnectionFactory实现多数据源收发消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-集群中的连接管理"><span class="nav-number">2.8.</span> <span class="nav-text">2.8 集群中的连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-普通队列"><span class="nav-number">2.8.1.</span> <span class="nav-text">2.8.1 普通队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-高可用队列（镜像队列）"><span class="nav-number">2.8.2.</span> <span class="nav-text">2.8.2 高可用队列（镜像队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-连接和信道监听"><span class="nav-number">2.9.</span> <span class="nav-text">2.9 连接和信道监听</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1-ConnectionListener"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.9.1 ConnectionListener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-2-ChannelListener"><span class="nav-number">2.9.2.</span> <span class="nav-text">2.9.2 ChannelListener</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-channel关闭的日志级别控制"><span class="nav-number">2.10.</span> <span class="nav-text">2.10 channel关闭的日志级别控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-生产者"><span class="nav-number">3.</span> <span class="nav-text">3 生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-RabbitTemplate配置"><span class="nav-number">4.</span> <span class="nav-text">3.1 RabbitTemplate配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-重试机制"><span class="nav-number">4.0.1.</span> <span class="nav-text">3.1.1 重试机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-生产者可靠投递"><span class="nav-number">4.0.2.</span> <span class="nav-text">3.1.2 生产者可靠投递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-连接池"><span class="nav-number">4.0.3.</span> <span class="nav-text">3.1.3 连接池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-生产消息"><span class="nav-number">4.1.</span> <span class="nav-text">3.2 生产消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-构建消息"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.2.1 构建消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-构建CorrelationData"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.2.2 构建CorrelationData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-统一修改消息和CorrelationData"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.2.2 统一修改消息和CorrelationData</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-发送消息"><span class="nav-number">4.2.</span> <span class="nav-text">3.3 发送消息</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#4-消费者"><span class="nav-number">5.</span> <span class="nav-text">4 消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-轮询模式消费者"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 轮询模式消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-异步消费者"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 异步消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-Message-Consuming-callback"><span class="nav-number">5.2.1.</span> <span class="nav-text">4.2.1 Message Consuming callback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-MessageListenerAdapter"><span class="nav-number">5.2.2.</span> <span class="nav-text">4.2.2 MessageListenerAdapter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-容器完成了回调"><span class="nav-number">5.2.3.</span> <span class="nav-text">4.2.3 容器完成了回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-自定义容器"><span class="nav-number">5.2.4.</span> <span class="nav-text">4.2.4 自定义容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-容器工厂"><span class="nav-number">5.2.5.</span> <span class="nav-text">4.2.5 容器工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6-容器属性"><span class="nav-number">5.2.6.</span> <span class="nav-text">4.2.6 容器属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）channelTransacted"><span class="nav-number">5.2.6.1.</span> <span class="nav-text">（1）channelTransacted</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）-transactionManager"><span class="nav-number">5.2.6.2.</span> <span class="nav-text">（2） transactionManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）-acknowledgeMode"><span class="nav-number">5.2.6.3.</span> <span class="nav-text">（3） acknowledgeMode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）-prefetchCount"><span class="nav-number">5.2.6.4.</span> <span class="nav-text">（4） prefetchCount</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）txSize"><span class="nav-number">5.2.6.5.</span> <span class="nav-text">（5）txSize</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（6）-messagePerAck"><span class="nav-number">5.2.6.6.</span> <span class="nav-text">（6） messagePerAck</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（7）-errorHandler"><span class="nav-number">5.2.6.7.</span> <span class="nav-text">（7） errorHandler</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-7-RabbitListener"><span class="nav-number">5.2.7.</span> <span class="nav-text">4.2.7 @RabbitListener</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-异常处理"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-RabbitListener异常处理"><span class="nav-number">5.3.1.</span> <span class="nav-text">4.3.1 @RabbitListener异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-为容器配置errorHandler"><span class="nav-number">5.3.2.</span> <span class="nav-text">4.3.2 为容器配置errorHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-补充说明"><span class="nav-number">5.3.3.</span> <span class="nav-text">4.3.3 补充说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Message-Convert"><span class="nav-number">6.</span> <span class="nav-text">5 Message Convert</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-消息格式"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 消息格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-RabbitListener底层实现原理"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 @RabbitListener底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-已有的MessageConverter"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 已有的MessageConverter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-SimpleMessageConverter"><span class="nav-number">6.3.1.</span> <span class="nav-text">5.3.1 SimpleMessageConverter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-SerializerMessageConverter"><span class="nav-number">6.3.2.</span> <span class="nav-text">5.3.2 SerializerMessageConverter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-Jackson2JsonMessageConverter"><span class="nav-number">6.3.3.</span> <span class="nav-text">5.3.3 Jackson2JsonMessageConverter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-ContentTypeDelegatingMessageConverter"><span class="nav-number">6.3.4.</span> <span class="nav-text">5.3.4  ContentTypeDelegatingMessageConverter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-MarshallingMessageConverter"><span class="nav-number">6.3.5.</span> <span class="nav-text">2.3.5 MarshallingMessageConverter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-6-为默认的Message-Converter设置反序列化权限"><span class="nav-number">6.3.6.</span> <span class="nav-text">5.3.6 为默认的Message Converter设置反序列化权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-7-MessagePropertiesConverter"><span class="nav-number">6.3.7.</span> <span class="nav-text">5.3.7 MessagePropertiesConverter</span></a></li></ol></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shipengyang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
